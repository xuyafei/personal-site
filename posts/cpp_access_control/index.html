<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++访问控制详解 | 我的博客</title><meta name=keywords content="C++,面向对象,访问控制,封装,继承"><meta name=description content="深入解析C++访问控制机制，从基础概念到高级应用，从原理到实践"><meta name=author content="徐亚飞"><link rel=canonical href=https://xuyafei.github.io/personal-site/posts/cpp_access_control/><link crossorigin=anonymous href=/personal-site/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as=style><link rel=icon href=https://xuyafei.github.io/personal-site/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xuyafei.github.io/personal-site/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://xuyafei.github.io/personal-site/favicon-32x32.png><link rel=apple-touch-icon href=https://xuyafei.github.io/personal-site/apple-touch-icon.png><link rel=mask-icon href=https://xuyafei.github.io/personal-site/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://xuyafei.github.io/personal-site/posts/cpp_access_control/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAYQHy+K8nqKdr1EzvFzSQC+TAXx6gNQgoRxKtj+P9vvCCQTRWiV crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})})</script><script>MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta property="og:url" content="https://xuyafei.github.io/personal-site/posts/cpp_access_control/"><meta property="og:site_name" content="我的博客"><meta property="og:title" content="C++访问控制详解"><meta property="og:description" content="深入解析C++访问控制机制，从基础概念到高级应用，从原理到实践"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-27T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-27T00:00:00+00:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="面向对象"><meta property="article:tag" content="访问控制"><meta property="article:tag" content="封装"><meta property="article:tag" content="继承"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++访问控制详解"><meta name=twitter:description content="深入解析C++访问控制机制，从基础概念到高级应用，从原理到实践"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://xuyafei.github.io/personal-site/posts/"},{"@type":"ListItem","position":2,"name":"C++访问控制详解","item":"https://xuyafei.github.io/personal-site/posts/cpp_access_control/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++访问控制详解","name":"C\u002b\u002b访问控制详解","description":"深入解析C++访问控制机制，从基础概念到高级应用，从原理到实践","keywords":["C++","面向对象","访问控制","封装","继承"],"articleBody":"C++访问控制详解 一、基本概念 1. 访问控制修饰符 C++ 中的类成员默认是 private，结构体成员默认是 public。\n三种访问控制修饰符：\n修饰符 类内访问 派生类访问 类外访问 public ✅ ✅ ✅ protected ✅ ✅ ❌ private ✅ ❌ ❌ 2. 访问控制与继承 派生类是否可以访问基类的成员，还受到**继承方式（public/protected/private）**的影响。\n继承方式 基类 public 成员在派生类中变为 基类 protected 成员变为 基类 private 成员变为 public public protected 不可访问 protected protected protected 不可访问 private private private 不可访问 示例：\nclass Base { public: int a; protected: int b; private: int c; }; class Derived1 : public Base { // a 是 public，b 是 protected，c 无法访问 }; class Derived2 : protected Base { // a 和 b 都变为 protected，c 无法访问 }; class Derived3 : private Base { // a 和 b 都变为 private，c 无法访问 }; 二、访问控制详解 1. public 公有成员 特点 表示这个成员对所有人都可见：类自身、派生类、外部代码 常用于类的接口函数（如 getX()、setX()），是对外的\"公共入口\" 应用场景 接口类中的函数： class Animal { public: virtual void speak() = 0; // 公共接口 }; 用户调用方法或访问数据时： obj.print(); 2. protected 受保护成员 基本定义 protected 成员只能被：\n当前类访问 其派生类访问 类外无法访问 它介于 private（更封闭）和 public（完全开放）之间。\n访问权限详解 protected 成员的访问权限如下： 访问者 private protected public 本类 ✅ ✅ ✅ 子类 ❌ ✅ ✅ 外部类或对象 ❌ ❌ ✅ 所以 protected 成员：\n✅ 子类可以访问 ❌ 外部不能访问（包括 main 函数、别的类、用户代码） ✅ 本类自然可以访问 使用场景 让子类复用父类实现（但不暴露给外部）： class Base { protected: int internalCounter = 0; public: void reset() { internalCounter = 0; } }; class Derived : public Base { public: void increment() { internalCounter++; } // 可以访问 }; 在模板方法模式中保护基础逻辑： class Game { public: void run() { init(); // 固定的初始化流程 play(); // 留给子类决定怎么实现 cleanup(); // 固定的收尾流程 } protected: virtual void init() { std::cout \u003c\u003c \"Base init\\n\"; } virtual void play() = 0; virtual void cleanup() { std::cout \u003c\u003c \"Base cleanup\\n\"; } }; class Chess : public Game { protected: void play() override { std::cout \u003c\u003c \"Playing chess\\n\"; // init(); // ✅ 可以写，但设计上不推荐这么做 } }; 受控开放（Controlled Extensibility） “子类内部可以访问 init()，为什么说不能调用？”\n✅ 答案是：语法上可以调用，但设计上\"不建议\"调用\n这正是面向对象设计中的一个重要思想：“受控开放（Controlled Extensibility）\"。\n🚧 为什么说是\"受控开放”？\nrun() 是父类控制的流程，父类负责\"何时\"调用 init() 虽然子类可以访问 init()（因为是 protected），但子类不应该改变流程的调用时机，否则就打破了框架设计的封装性 🧠 举个现实例子理解：\n你有一个电饭锅（父类），内部流程是：\n加热（init） 蒸煮（play） 保温（cleanup） 你继承它做了一个\"智能电饭锅\"（子类）——你可以重写\"蒸煮\"的逻辑，但你不能插手何时开始加热、保温。\n如果你在 play() 里面又调用一次 init()，你其实在\"偷偷重新加热\"，破坏了流程，结果可能\"煮坏饭\"。\n✅ 总结你的疑问：\n问题 回答 子类能不能调用 init()？ ✅ 语法上可以调用，因为是 protected，对子类可见 为什么说\"子类不能调用 init()\"？ ❌ 不是语法限制，而是设计上的约束，避免子类破坏父类设计好的流程 谁能调用 init()？ Game 类自己可以，Chess 子类也可以——但设计上只允许 run() 控制它 什么是\"受控开放\"？ 父类允许子类扩展部分行为（如 play()），但保留流程控制权（如 init()） 🔍 如果你硬要让 init() 不能被子类调用？ 那就把它设为 private，但这样子类连 override 都做不了，这就牺牲了灵活性。因此我们用 protected，是一种对子类开放、但约定俗成要遵守使用边界的方式。\n这种设计模式（称为模板方法模式）正好是面向对象三大特性——封装、继承、多态的经典应用体现之一。下面我们来深入讲清楚这个设计模式，并结合 OOP 三大特性逐步解析：\n🎯 一、什么是模板方法模式？\n模板方法模式定义： 在基类中定义一个算法的骨架（固定的执行流程），而将某些步骤延迟到子类中实现。 基类控制整体流程，子类负责实现细节，流程不可更改，细节可扩展。\n🔧 二、结构原型代码（经典案例）\nclass Game { public: void run() { init(); // 第一步：初始化 play(); // 第二步：进行游戏（延迟到子类） cleanup(); // 第三步：清理资源 } protected: virtual void init() { std::cout \u003c\u003c \"Game init\\n\"; } virtual void play() = 0; // 抽象方法，强制子类实现 virtual void cleanup() { std::cout \u003c\u003c \"Game cleanup\\n\"; } }; class ChessGame : public Game { protected: void play() override { std::cout \u003c\u003c \"Playing Chess\\n\"; } }; // 使用： int main() { Game* g = new ChessGame(); g-\u003erun(); // 只暴露一个 run()，调用流程由父类控制 delete g; } 🧱 三、和 OOP 三大特性关系详解\n✅ 封装（Encapsulation） 封装的是**“整体流程”**，不允许外部和子类干扰 run() 方法中固定的执行顺序 init()、cleanup() 甚至 run() 都可以设置为 protected / private，暴露最小的接口（如 run() 为 public，其余为 protected），隐藏实现细节、对外暴露统一入口 🟩 封装体现：\n对外只暴露 run() 内部怎么初始化和清理，外部无权干涉 ✅ 继承（Inheritance） 子类继承父类 Game 利用继承来扩展具体的 play() 实现，支持多种不同玩法，如 ChessGame、FootballGame 等 🟩 继承体现：\n复用父类代码结构 子类扩展定制化逻辑 ✅ 多态（Polymorphism） play() 是 virtual 的（甚至纯虚函数），父类指针 Game* 可以指向任何具体子类 运行时根据对象类型动态调用 play()，达到多态效果 🟩 多态体现：\nGame* g = new ChessGame(); 调用 g-\u003erun() 时，内部实际调用的是子类 ChessGame 的 play() 实现 📦 四、模板方法模式的优点总结\n优点 解释 ✅ 统一流程控制 父类封装整个算法结构，子类不能乱改顺序，确保流程一致性 ✅ 扩展灵活 子类可以自由定制 play() 的细节 ✅ 避免重复代码 公共的 init() 和 cleanup() 由父类统一实现 ✅ 支持开闭原则 添加新玩法只需新建子类，不动原有父类代码 🧠 五、类比现实世界帮助理解\n想象一个\"点外卖\"的流程（父类控制）：\nclass OrderFood { public: void order() { selectRestaurant(); chooseFood(); // 不同人点的菜不同 pay(); } protected: void selectRestaurant() { std::cout \u003c\u003c \"Choose restaurant\\n\"; } virtual void chooseFood() = 0; void pay() { std::cout \u003c\u003c \"Pay for food\\n\"; } }; // 不同人继承这个流程定制 chooseFood()： class AliceOrder : public OrderFood { void chooseFood() override { std::cout \u003c\u003c \"Alice orders sushi\\n\"; } }; class BobOrder : public OrderFood { void chooseFood() override { std::cout \u003c\u003c \"Bob orders burger\\n\"; } }; 你只管调用 order()，点餐流程就全跑完了，外部不需要知道细节，这就叫模板方法模式的魅力。\n🧭 六、模板方法模式应用场景\n游戏开发：通用流程，扩展玩法 网络请求：模板封装请求流程、回调子类处理响应 框架设计：如 Qt、Java 的 GUI 框架中 paintEvent() 就是典型的模板方法模式 🔚 总结一张表：OOP 特性如何在模板方法中体现\n特性 模板方法中的体现 封装 run() 封装整体流程，对外隐藏细节 继承 子类继承父类结构，自定义部分逻辑 多态 子类实现虚函数，运行时动态决定调用哪一版 避免\"朋友外人\"乱改状态： class BankAccount { protected: double balance; public: BankAccount(double initial) : balance(initial) {} virtual void deposit(double amount) { balance += amount; } }; class PremiumAccount : public BankAccount { public: PremiumAccount(double initial) : BankAccount(initial) {} void bonusInterest() { balance += balance * 0.05; } // 访问受保护的 balance }; 3. private 私有成员 特点 表示成员只能被当前类访问，外部和派生类都不能访问 是最严格的访问控制，通常用于保护内部数据，防止误用 应用场景 成员变量几乎总是设为 private，以实现封装： class User { private: std::string password; public: void setPassword(const std::string\u0026 pwd); }; 阻止派生类访问内部实现细节： class Connection { private: void openSocket(); // 外部和子类都不能调用 }; 三、友元机制 1. 基本概念 C++ 中可以通过 friend 声明，使某些函数或类可以访问另一个类的私有/受保护成员。\nclass A { private: int secret = 42; friend void reveal(A\u0026); }; void reveal(A\u0026 a) { std::cout \u003c\u003c a.secret \u003c\u003c std::endl; // 合法 } 2. 应用场景 1. 操作符重载（非成员） class Vector { private: int x, y; public: Vector(int x, int y) : x(x), y(y) {} friend Vector operator+(const Vector\u0026 a, const Vector\u0026 b); }; Vector operator+(const Vector\u0026 a, const Vector\u0026 b) { return Vector(a.x + b.x, a.y + b.y); // 可以访问 private 成员 } 2. 辅助类（Builder、Iterator）访问内部状态 class House; class HouseBuilder { public: House create(); }; class House { private: std::string wallType; int windows; friend class HouseBuilder; }; 3. 友元的注意点 特点 说明 不受继承限制 friend 不会被继承给子类 单向关系 A 是 B 的 friend，不代表 B 是 A 的 friend 会破坏封装 滥用会导致类之间高度耦合，失去模块边界 4. friend vs protected 区别 特性 protected friend 可访问权限 类和子类 被授权的类/函数 是否继承可见 ✅ ❌ 是否破坏封装 否（较弱） 是（较强） 使用典型场景 继承设计 / 模板方法 / 抽象类 操作符重载 / 辅助类 / 高效协作类设计 四、设计建议与最佳实践 1. 访问控制的设计建议 类成员 建议使用的访问控制 原因 成员变量 private（或 protected） 封装、控制访问 公共 API 接口 public 暴露外部接口 辅助函数 private 仅限类内部调用 可被子类重用的基础功能 protected 子类共享但不对外暴露 2. 常见设计陷阱与误区 误将数据成员设为 public\n会破坏封装性，使对象数据暴露在外部，易于出错 改进方法：使用 getter/setter 将所有函数设为 public\n会暴露太多无关内部逻辑，导致接口复杂、难维护 滥用 protected\n只有当你确信子类需要访问时才使用，否则就应当 private 3. 实战建议 什么时候用 protected？ 你希望子类扩展/控制行为，但又不希望外部使用 比如状态、模板方法的步骤、受保护工具函数等 什么时候用 friend？ 函数需要跨类访问私有数据，但不希望改变数据的所有者 比如双向关联类、操作符重载、构建器类、调试工具等 五、总结 核心概念回顾 private：最严格的访问控制，仅类内可访问 protected：类内和派生类可访问，外部不可访问 public：完全开放，所有地方都可访问 friend：特殊机制，允许指定外部访问私有成员 最佳实践 优先使用 private 保护数据 谨慎使用 protected，只在确实需要时使用 合理使用 public 暴露接口 谨慎使用 friend，避免破坏封装 一句话总结 private 是\"最安全\" protected 是\"给子类留口子\" public 是\"对外的窗口\" friend 是\"把钥匙交给别人\" 参考文献：\n“The C++ Programming Language” by Bjarne Stroustrup “Effective C++” by Scott Meyers “C++ Primer” by Stanley Lippman “Design Patterns” by Erich Gamma “Clean Code” by Robert C. Martin ","wordCount":"935","inLanguage":"en","datePublished":"2025-05-27T00:00:00Z","dateModified":"2025-05-27T00:00:00Z","author":{"@type":"Person","name":"徐亚飞"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xuyafei.github.io/personal-site/posts/cpp_access_control/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://xuyafei.github.io/personal-site/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xuyafei.github.io/personal-site/ accesskey=h title="我的博客 (Alt + H)">我的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xuyafei.github.io/personal-site/categories/ title=分类><span>分类</span></a></li><li><a href=https://xuyafei.github.io/personal-site/tags/ title=标签><span>标签</span></a></li><li><a href=https://xuyafei.github.io/personal-site/archives/ title=归档><span>归档</span></a></li><li><a href=https://xuyafei.github.io/personal-site/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xuyafei.github.io/personal-site/>Home</a>&nbsp;»&nbsp;<a href=https://xuyafei.github.io/personal-site/posts/>文章</a></div><h1 class="post-title entry-hint-parent">C++访问控制详解</h1><div class=post-description>深入解析C++访问控制机制，从基础概念到高级应用，从原理到实践</div><div class=post-meta><span title='2025-05-27 00:00:00 +0000 UTC'>May 27, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;徐亚飞</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#c%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e8%af%a6%e8%a7%a3 aria-label=C++访问控制详解>C++访问控制详解</a><ul><li><a href=#%e4%b8%80%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=一、基本概念>一、基本概念</a><ul><li><a href=#1-%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e4%bf%ae%e9%a5%b0%e7%ac%a6 aria-label="1. 访问控制修饰符">1. 访问控制修饰符</a></li><li><a href=#2-%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e4%b8%8e%e7%bb%a7%e6%89%bf aria-label="2. 访问控制与继承">2. 访问控制与继承</a></li></ul></li><li><a href=#%e4%ba%8c%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e8%af%a6%e8%a7%a3 aria-label=二、访问控制详解>二、访问控制详解</a><ul><li><a href=#1-public-%e5%85%ac%e6%9c%89%e6%88%90%e5%91%98 aria-label="1. public 公有成员">1. public 公有成员</a><ul><li><a href=#%e7%89%b9%e7%82%b9 aria-label=特点>特点</a></li><li><a href=#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af aria-label=应用场景>应用场景</a></li></ul></li><li><a href=#2-protected-%e5%8f%97%e4%bf%9d%e6%8a%a4%e6%88%90%e5%91%98 aria-label="2. protected 受保护成员">2. protected 受保护成员</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e5%ae%9a%e4%b9%89 aria-label=基本定义>基本定义</a></li><li><a href=#%e8%ae%bf%e9%97%ae%e6%9d%83%e9%99%90%e8%af%a6%e8%a7%a3 aria-label=访问权限详解>访问权限详解</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af aria-label=使用场景>使用场景</a></li><li><a href=#%e5%8f%97%e6%8e%a7%e5%bc%80%e6%94%becontrolled-extensibility aria-label="受控开放（Controlled Extensibility）">受控开放（Controlled Extensibility）</a></li></ul></li><li><a href=#3-private-%e7%a7%81%e6%9c%89%e6%88%90%e5%91%98 aria-label="3. private 私有成员">3. private 私有成员</a><ul><li><a href=#%e7%89%b9%e7%82%b9-1 aria-label=特点>特点</a></li><li><a href=#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-1 aria-label=应用场景>应用场景</a></li></ul></li></ul></li><li><a href=#%e4%b8%89%e5%8f%8b%e5%85%83%e6%9c%ba%e5%88%b6 aria-label=三、友元机制>三、友元机制</a><ul><li><a href=#1-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label="1. 基本概念">1. 基本概念</a></li><li><a href=#2-%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af aria-label="2. 应用场景">2. 应用场景</a><ul><li><a href=#1-%e6%93%8d%e4%bd%9c%e7%ac%a6%e9%87%8d%e8%bd%bd%e9%9d%9e%e6%88%90%e5%91%98 aria-label="1. 操作符重载（非成员）">1. 操作符重载（非成员）</a></li><li><a href=#2-%e8%be%85%e5%8a%a9%e7%b1%bbbuilderiterator%e8%ae%bf%e9%97%ae%e5%86%85%e9%83%a8%e7%8a%b6%e6%80%81 aria-label="2. 辅助类（Builder、Iterator）访问内部状态">2. 辅助类（Builder、Iterator）访问内部状态</a></li></ul></li><li><a href=#3-%e5%8f%8b%e5%85%83%e7%9a%84%e6%b3%a8%e6%84%8f%e7%82%b9 aria-label="3. 友元的注意点">3. 友元的注意点</a></li><li><a href=#4-friend-vs-protected-%e5%8c%ba%e5%88%ab aria-label="4. friend vs protected 区别">4. friend vs protected 区别</a></li></ul></li><li><a href=#%e5%9b%9b%e8%ae%be%e8%ae%a1%e5%bb%ba%e8%ae%ae%e4%b8%8e%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5 aria-label=四、设计建议与最佳实践>四、设计建议与最佳实践</a><ul><li><a href=#1-%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e7%9a%84%e8%ae%be%e8%ae%a1%e5%bb%ba%e8%ae%ae aria-label="1. 访问控制的设计建议">1. 访问控制的设计建议</a></li><li><a href=#2-%e5%b8%b8%e8%a7%81%e8%ae%be%e8%ae%a1%e9%99%b7%e9%98%b1%e4%b8%8e%e8%af%af%e5%8c%ba aria-label="2. 常见设计陷阱与误区">2. 常见设计陷阱与误区</a></li><li><a href=#3-%e5%ae%9e%e6%88%98%e5%bb%ba%e8%ae%ae aria-label="3. 实战建议">3. 实战建议</a><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e7%94%a8-protected aria-label="什么时候用 protected？">什么时候用 protected？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e7%94%a8-friend aria-label="什么时候用 friend？">什么时候用 friend？</a></li></ul></li></ul></li><li><a href=#%e4%ba%94%e6%80%bb%e7%bb%93 aria-label=五、总结>五、总结</a><ul><li><a href=#%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5%e5%9b%9e%e9%a1%be aria-label=核心概念回顾>核心概念回顾</a></li><li><a href=#%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5 aria-label=最佳实践>最佳实践</a></li><li><a href=#%e4%b8%80%e5%8f%a5%e8%af%9d%e6%80%bb%e7%bb%93 aria-label=一句话总结>一句话总结</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=c访问控制详解>C++访问控制详解<a hidden class=anchor aria-hidden=true href=#c访问控制详解>#</a></h1><h2 id=一基本概念>一、基本概念<a hidden class=anchor aria-hidden=true href=#一基本概念>#</a></h2><h3 id=1-访问控制修饰符>1. 访问控制修饰符<a hidden class=anchor aria-hidden=true href=#1-访问控制修饰符>#</a></h3><p>C++ 中的类成员默认是 private，结构体成员默认是 public。</p><p>三种访问控制修饰符：</p><table><thead><tr><th>修饰符</th><th>类内访问</th><th>派生类访问</th><th>类外访问</th></tr></thead><tbody><tr><td>public</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>protected</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>private</td><td>✅</td><td>❌</td><td>❌</td></tr></tbody></table><h3 id=2-访问控制与继承>2. 访问控制与继承<a hidden class=anchor aria-hidden=true href=#2-访问控制与继承>#</a></h3><p>派生类是否可以访问基类的成员，还受到**继承方式（public/protected/private）**的影响。</p><table><thead><tr><th>继承方式</th><th>基类 public 成员在派生类中变为</th><th>基类 protected 成员变为</th><th>基类 private 成员变为</th></tr></thead><tbody><tr><td>public</td><td>public</td><td>protected</td><td>不可访问</td></tr><tr><td>protected</td><td>protected</td><td>protected</td><td>不可访问</td></tr><tr><td>private</td><td>private</td><td>private</td><td>不可访问</td></tr></tbody></table><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>    <span style=color:#66d9ef>int</span> a;
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> b;
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>   <span style=color:#66d9ef>int</span> c;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived1</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// a 是 public，b 是 protected，c 无法访问
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived2</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>protected</span> Base {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// a 和 b 都变为 protected，c 无法访问
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived3</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>private</span> Base {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// a 和 b 都变为 private，c 无法访问
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h2 id=二访问控制详解>二、访问控制详解<a hidden class=anchor aria-hidden=true href=#二访问控制详解>#</a></h2><h3 id=1-public-公有成员>1. public 公有成员<a hidden class=anchor aria-hidden=true href=#1-public-公有成员>#</a></h3><h4 id=特点>特点<a hidden class=anchor aria-hidden=true href=#特点>#</a></h4><ul><li>表示这个成员对所有人都可见：类自身、派生类、外部代码</li><li>常用于类的接口函数（如 getX()、setX()），是对外的"公共入口"</li></ul><h4 id=应用场景>应用场景<a hidden class=anchor aria-hidden=true href=#应用场景>#</a></h4><ol><li>接口类中的函数：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Animal</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> speak() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 公共接口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><ol start=2><li>用户调用方法或访问数据时：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>obj.print();
</span></span></code></pre></div><h3 id=2-protected-受保护成员>2. protected 受保护成员<a hidden class=anchor aria-hidden=true href=#2-protected-受保护成员>#</a></h3><h4 id=基本定义>基本定义<a hidden class=anchor aria-hidden=true href=#基本定义>#</a></h4><p>protected 成员只能被：</p><ul><li>当前类访问</li><li>其派生类访问</li><li>类外无法访问</li></ul><p>它介于 private（更封闭）和 public（完全开放）之间。</p><h4 id=访问权限详解>访问权限详解<a hidden class=anchor aria-hidden=true href=#访问权限详解>#</a></h4><ol><li>protected 成员的访问权限如下：</li></ol><table><thead><tr><th>访问者</th><th>private</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>本类</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>子类</td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td>外部类或对象</td><td>❌</td><td>❌</td><td>✅</td></tr></tbody></table><p>所以 protected 成员：</p><ul><li>✅ 子类可以访问</li><li>❌ 外部不能访问（包括 main 函数、别的类、用户代码）</li><li>✅ 本类自然可以访问</li></ul><h4 id=使用场景>使用场景<a hidden class=anchor aria-hidden=true href=#使用场景>#</a></h4><ol><li>让子类复用父类实现（但不暴露给外部）：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> internalCounter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> reset() { internalCounter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> increment() { internalCounter<span style=color:#f92672>++</span>; }  <span style=color:#75715e>// 可以访问
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><ol start=2><li>在模板方法模式中保护基础逻辑：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Game</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> run() {
</span></span><span style=display:flex><span>        init();    <span style=color:#75715e>// 固定的初始化流程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        play();    <span style=color:#75715e>// 留给子类决定怎么实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cleanup(); <span style=color:#75715e>// 固定的收尾流程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> init() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Base init</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>play</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cleanup</span>() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Base cleanup</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Chess</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Game {
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> play() <span style=color:#66d9ef>override</span> {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Playing chess</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// init(); // ✅ 可以写，但设计上不推荐这么做
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=受控开放controlled-extensibility>受控开放（Controlled Extensibility）<a hidden class=anchor aria-hidden=true href=#受控开放controlled-extensibility>#</a></h4><p>&ldquo;子类内部可以访问 init()，为什么说不能调用？&rdquo;</p><p>✅ 答案是：语法上可以调用，但设计上"不建议"调用</p><p>这正是面向对象设计中的一个重要思想：&ldquo;受控开放（Controlled Extensibility）"。</p><p>🚧 为什么说是"受控开放&rdquo;？</p><ul><li>run() 是父类控制的流程，父类负责"何时"调用 init()</li><li>虽然子类可以访问 init()（因为是 protected），但子类不应该改变流程的调用时机，否则就打破了框架设计的封装性</li></ul><p>🧠 举个现实例子理解：</p><p>你有一个电饭锅（父类），内部流程是：</p><ol><li>加热（init）</li><li>蒸煮（play）</li><li>保温（cleanup）</li></ol><p>你继承它做了一个"智能电饭锅"（子类）——你可以重写"蒸煮"的逻辑，但你不能插手何时开始加热、保温。</p><p>如果你在 play() 里面又调用一次 init()，你其实在"偷偷重新加热"，破坏了流程，结果可能"煮坏饭"。</p><p>✅ 总结你的疑问：</p><table><thead><tr><th>问题</th><th>回答</th></tr></thead><tbody><tr><td>子类能不能调用 init()？</td><td>✅ 语法上可以调用，因为是 protected，对子类可见</td></tr><tr><td>为什么说"子类不能调用 init()"？</td><td>❌ 不是语法限制，而是设计上的约束，避免子类破坏父类设计好的流程</td></tr><tr><td>谁能调用 init()？</td><td>Game 类自己可以，Chess 子类也可以——但设计上只允许 run() 控制它</td></tr><tr><td>什么是"受控开放"？</td><td>父类允许子类扩展部分行为（如 play()），但保留流程控制权（如 init()）</td></tr></tbody></table><p>🔍 如果你硬要让 init() 不能被子类调用？
那就把它设为 private，但这样子类连 override 都做不了，这就牺牲了灵活性。因此我们用 protected，是一种对子类开放、但约定俗成要遵守使用边界的方式。</p><p>这种设计模式（称为模板方法模式）正好是面向对象三大特性——封装、继承、多态的经典应用体现之一。下面我们来深入讲清楚这个设计模式，并结合 OOP 三大特性逐步解析：</p><p>🎯 一、什么是模板方法模式？</p><p>模板方法模式定义：
在基类中定义一个算法的骨架（固定的执行流程），而将某些步骤延迟到子类中实现。
基类控制整体流程，子类负责实现细节，流程不可更改，细节可扩展。</p><p>🔧 二、结构原型代码（经典案例）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Game</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> run() {
</span></span><span style=display:flex><span>        init();       <span style=color:#75715e>// 第一步：初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        play();       <span style=color:#75715e>// 第二步：进行游戏（延迟到子类）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cleanup();    <span style=color:#75715e>// 第三步：清理资源
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> init()    { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Game init</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>play</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>// 抽象方法，强制子类实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cleanup</span>() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Game cleanup</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ChessGame</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Game {
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> play() <span style=color:#66d9ef>override</span> {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Playing Chess</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Game<span style=color:#f92672>*</span> g <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ChessGame();
</span></span><span style=display:flex><span>    g<span style=color:#f92672>-&gt;</span>run(); <span style=color:#75715e>// 只暴露一个 run()，调用流程由父类控制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>delete</span> g;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>🧱 三、和 OOP 三大特性关系详解</p><ol><li>✅ 封装（Encapsulation）<ul><li>封装的是**&ldquo;整体流程&rdquo;**，不允许外部和子类干扰 run() 方法中固定的执行顺序</li><li>init()、cleanup() 甚至 run() 都可以设置为 protected / private，暴露最小的接口（如 run() 为 public，其余为 protected），隐藏实现细节、对外暴露统一入口</li></ul></li></ol><p>🟩 封装体现：</p><ul><li>对外只暴露 run()</li><li>内部怎么初始化和清理，外部无权干涉</li></ul><ol start=2><li>✅ 继承（Inheritance）<ul><li>子类继承父类 Game</li><li>利用继承来扩展具体的 play() 实现，支持多种不同玩法，如 ChessGame、FootballGame 等</li></ul></li></ol><p>🟩 继承体现：</p><ul><li>复用父类代码结构</li><li>子类扩展定制化逻辑</li></ul><ol start=3><li>✅ 多态（Polymorphism）<ul><li>play() 是 virtual 的（甚至纯虚函数），父类指针 Game* 可以指向任何具体子类</li><li>运行时根据对象类型动态调用 play()，达到多态效果</li></ul></li></ol><p>🟩 多态体现：</p><ul><li>Game* g = new ChessGame();</li><li>调用 g->run() 时，内部实际调用的是子类 ChessGame 的 play() 实现</li></ul><p>📦 四、模板方法模式的优点总结</p><table><thead><tr><th>优点</th><th>解释</th></tr></thead><tbody><tr><td>✅ 统一流程控制</td><td>父类封装整个算法结构，子类不能乱改顺序，确保流程一致性</td></tr><tr><td>✅ 扩展灵活</td><td>子类可以自由定制 play() 的细节</td></tr><tr><td>✅ 避免重复代码</td><td>公共的 init() 和 cleanup() 由父类统一实现</td></tr><tr><td>✅ 支持开闭原则</td><td>添加新玩法只需新建子类，不动原有父类代码</td></tr></tbody></table><p>🧠 五、类比现实世界帮助理解</p><p>想象一个"点外卖"的流程（父类控制）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderFood</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> order() {
</span></span><span style=display:flex><span>        selectRestaurant();
</span></span><span style=display:flex><span>        chooseFood();      <span style=color:#75715e>// 不同人点的菜不同
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        pay();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> selectRestaurant() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Choose restaurant</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>chooseFood</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pay</span>() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Pay for food</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 不同人继承这个流程定制 chooseFood()：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AliceOrder</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> OrderFood {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>chooseFood</span>() <span style=color:#66d9ef>override</span> { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Alice orders sushi</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BobOrder</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> OrderFood {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>chooseFood</span>() <span style=color:#66d9ef>override</span> { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Bob orders burger</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>你只管调用 order()，点餐流程就全跑完了，外部不需要知道细节，这就叫模板方法模式的魅力。</p><p>🧭 六、模板方法模式应用场景</p><ul><li>游戏开发：通用流程，扩展玩法</li><li>网络请求：模板封装请求流程、回调子类处理响应</li><li>框架设计：如 Qt、Java 的 GUI 框架中 paintEvent() 就是典型的模板方法模式</li></ul><p>🔚 总结一张表：OOP 特性如何在模板方法中体现</p><table><thead><tr><th>特性</th><th>模板方法中的体现</th></tr></thead><tbody><tr><td>封装</td><td>run() 封装整体流程，对外隐藏细节</td></tr><tr><td>继承</td><td>子类继承父类结构，自定义部分逻辑</td></tr><tr><td>多态</td><td>子类实现虚函数，运行时动态决定调用哪一版</td></tr></tbody></table><ol start=3><li>避免"朋友外人"乱改状态：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BankAccount</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> balance;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    BankAccount(<span style=color:#66d9ef>double</span> initial) <span style=color:#f92672>:</span> balance(initial) {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>deposit</span>(<span style=color:#66d9ef>double</span> amount) { balance <span style=color:#f92672>+=</span> amount; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PremiumAccount</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> BankAccount {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    PremiumAccount(<span style=color:#66d9ef>double</span> initial) <span style=color:#f92672>:</span> BankAccount(initial) {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bonusInterest</span>() { balance <span style=color:#f92672>+=</span> balance <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.05</span>; }  <span style=color:#75715e>// 访问受保护的 balance
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h3 id=3-private-私有成员>3. private 私有成员<a hidden class=anchor aria-hidden=true href=#3-private-私有成员>#</a></h3><h4 id=特点-1>特点<a hidden class=anchor aria-hidden=true href=#特点-1>#</a></h4><ul><li>表示成员只能被当前类访问，外部和派生类都不能访问</li><li>是最严格的访问控制，通常用于保护内部数据，防止误用</li></ul><h4 id=应用场景-1>应用场景<a hidden class=anchor aria-hidden=true href=#应用场景-1>#</a></h4><ol><li>成员变量几乎总是设为 private，以实现封装：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string password;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> setPassword(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> pwd);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ol start=2><li>阻止派生类访问内部实现细节：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Connection</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> openSocket(); <span style=color:#75715e>// 外部和子类都不能调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h2 id=三友元机制>三、友元机制<a hidden class=anchor aria-hidden=true href=#三友元机制>#</a></h2><h3 id=1-基本概念>1. 基本概念<a hidden class=anchor aria-hidden=true href=#1-基本概念>#</a></h3><p>C++ 中可以通过 friend 声明，使某些函数或类可以访问另一个类的私有/受保护成员。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> secret <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>reveal</span>(A<span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>reveal</span>(A<span style=color:#f92672>&amp;</span> a) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> a.secret <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;  <span style=color:#75715e>// 合法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=2-应用场景>2. 应用场景<a hidden class=anchor aria-hidden=true href=#2-应用场景>#</a></h3><h4 id=1-操作符重载非成员>1. 操作符重载（非成员）<a hidden class=anchor aria-hidden=true href=#1-操作符重载非成员>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Vector</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x, y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Vector(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) <span style=color:#f92672>:</span> x(x), y(y) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>friend</span> Vector <span style=color:#66d9ef>operator</span><span style=color:#f92672>+</span>(<span style=color:#66d9ef>const</span> Vector<span style=color:#f92672>&amp;</span> a, <span style=color:#66d9ef>const</span> Vector<span style=color:#f92672>&amp;</span> b);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Vector <span style=color:#66d9ef>operator</span><span style=color:#f92672>+</span>(<span style=color:#66d9ef>const</span> Vector<span style=color:#f92672>&amp;</span> a, <span style=color:#66d9ef>const</span> Vector<span style=color:#f92672>&amp;</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Vector</span>(a.x <span style=color:#f92672>+</span> b.x, a.y <span style=color:#f92672>+</span> b.y);  <span style=color:#75715e>// 可以访问 private 成员
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=2-辅助类builderiterator访问内部状态>2. 辅助类（Builder、Iterator）访问内部状态<a hidden class=anchor aria-hidden=true href=#2-辅助类builderiterator访问内部状态>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>House</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HouseBuilder</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    House create();
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>House</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string wallType;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> windows;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HouseBuilder</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=3-友元的注意点>3. 友元的注意点<a hidden class=anchor aria-hidden=true href=#3-友元的注意点>#</a></h3><table><thead><tr><th>特点</th><th>说明</th></tr></thead><tbody><tr><td>不受继承限制</td><td>friend 不会被继承给子类</td></tr><tr><td>单向关系</td><td>A 是 B 的 friend，不代表 B 是 A 的 friend</td></tr><tr><td>会破坏封装</td><td>滥用会导致类之间高度耦合，失去模块边界</td></tr></tbody></table><h3 id=4-friend-vs-protected-区别>4. friend vs protected 区别<a hidden class=anchor aria-hidden=true href=#4-friend-vs-protected-区别>#</a></h3><table><thead><tr><th>特性</th><th>protected</th><th>friend</th></tr></thead><tbody><tr><td>可访问权限</td><td>类和子类</td><td>被授权的类/函数</td></tr><tr><td>是否继承可见</td><td>✅</td><td>❌</td></tr><tr><td>是否破坏封装</td><td>否（较弱）</td><td>是（较强）</td></tr><tr><td>使用典型场景</td><td>继承设计 / 模板方法 / 抽象类</td><td>操作符重载 / 辅助类 / 高效协作类设计</td></tr></tbody></table><h2 id=四设计建议与最佳实践>四、设计建议与最佳实践<a hidden class=anchor aria-hidden=true href=#四设计建议与最佳实践>#</a></h2><h3 id=1-访问控制的设计建议>1. 访问控制的设计建议<a hidden class=anchor aria-hidden=true href=#1-访问控制的设计建议>#</a></h3><table><thead><tr><th>类成员</th><th>建议使用的访问控制</th><th>原因</th></tr></thead><tbody><tr><td>成员变量</td><td>private（或 protected）</td><td>封装、控制访问</td></tr><tr><td>公共 API 接口</td><td>public</td><td>暴露外部接口</td></tr><tr><td>辅助函数</td><td>private</td><td>仅限类内部调用</td></tr><tr><td>可被子类重用的基础功能</td><td>protected</td><td>子类共享但不对外暴露</td></tr></tbody></table><h3 id=2-常见设计陷阱与误区>2. 常见设计陷阱与误区<a hidden class=anchor aria-hidden=true href=#2-常见设计陷阱与误区>#</a></h3><ol><li><p>误将数据成员设为 public</p><ul><li>会破坏封装性，使对象数据暴露在外部，易于出错</li><li>改进方法：使用 getter/setter</li></ul></li><li><p>将所有函数设为 public</p><ul><li>会暴露太多无关内部逻辑，导致接口复杂、难维护</li></ul></li><li><p>滥用 protected</p><ul><li>只有当你确信子类需要访问时才使用，否则就应当 private</li></ul></li></ol><h3 id=3-实战建议>3. 实战建议<a hidden class=anchor aria-hidden=true href=#3-实战建议>#</a></h3><h4 id=什么时候用-protected>什么时候用 protected？<a hidden class=anchor aria-hidden=true href=#什么时候用-protected>#</a></h4><ul><li>你希望子类扩展/控制行为，但又不希望外部使用</li><li>比如状态、模板方法的步骤、受保护工具函数等</li></ul><h4 id=什么时候用-friend>什么时候用 friend？<a hidden class=anchor aria-hidden=true href=#什么时候用-friend>#</a></h4><ul><li>函数需要跨类访问私有数据，但不希望改变数据的所有者</li><li>比如双向关联类、操作符重载、构建器类、调试工具等</li></ul><h2 id=五总结>五、总结<a hidden class=anchor aria-hidden=true href=#五总结>#</a></h2><h3 id=核心概念回顾>核心概念回顾<a hidden class=anchor aria-hidden=true href=#核心概念回顾>#</a></h3><ul><li>private：最严格的访问控制，仅类内可访问</li><li>protected：类内和派生类可访问，外部不可访问</li><li>public：完全开放，所有地方都可访问</li><li>friend：特殊机制，允许指定外部访问私有成员</li></ul><h3 id=最佳实践>最佳实践<a hidden class=anchor aria-hidden=true href=#最佳实践>#</a></h3><ol><li>优先使用 private 保护数据</li><li>谨慎使用 protected，只在确实需要时使用</li><li>合理使用 public 暴露接口</li><li>谨慎使用 friend，避免破坏封装</li></ol><h3 id=一句话总结>一句话总结<a hidden class=anchor aria-hidden=true href=#一句话总结>#</a></h3><ul><li>private 是"最安全"</li><li>protected 是"给子类留口子"</li><li>public 是"对外的窗口"</li><li>friend 是"把钥匙交给别人"</li></ul><hr><p><em>参考文献：</em></p><ol><li>&ldquo;The C++ Programming Language&rdquo; by Bjarne Stroustrup</li><li>&ldquo;Effective C++&rdquo; by Scott Meyers</li><li>&ldquo;C++ Primer&rdquo; by Stanley Lippman</li><li>&ldquo;Design Patterns&rdquo; by Erich Gamma</li><li>&ldquo;Clean Code&rdquo; by Robert C. Martin</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://xuyafei.github.io/personal-site/tags/c++/>C++</a></li><li><a href=https://xuyafei.github.io/personal-site/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/>面向对象</a></li><li><a href=https://xuyafei.github.io/personal-site/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/>访问控制</a></li><li><a href=https://xuyafei.github.io/personal-site/tags/%E5%B0%81%E8%A3%85/>封装</a></li><li><a href=https://xuyafei.github.io/personal-site/tags/%E7%BB%A7%E6%89%BF/>继承</a></li></ul><nav class=paginav><a class=prev href=https://xuyafei.github.io/personal-site/posts/cpp_inheritance_polymorphism/><span class=title>« Prev</span><br><span>C++继承与多态详解</span>
</a><a class=next href=https://xuyafei.github.io/personal-site/posts/cpp_memory_guide/><span class=title>Next »</span><br><span>C++ 内存管理完全指南</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share C++访问控制详解 on x" href="https://x.com/intent/tweet/?text=C%2b%2b%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e8%af%a6%e8%a7%a3&amp;url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp_access_control%2f&amp;hashtags=C%2b%2b%2c%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%2c%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%2c%e5%b0%81%e8%a3%85%2c%e7%bb%a7%e6%89%bf"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++访问控制详解 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp_access_control%2f&amp;title=C%2b%2b%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e8%af%a6%e8%a7%a3&amp;summary=C%2b%2b%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e8%af%a6%e8%a7%a3&amp;source=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp_access_control%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++访问控制详解 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp_access_control%2f&title=C%2b%2b%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e8%af%a6%e8%a7%a3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++访问控制详解 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp_access_control%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++访问控制详解 on whatsapp" href="https://api.whatsapp.com/send?text=C%2b%2b%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e8%af%a6%e8%a7%a3%20-%20https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp_access_control%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++访问控制详解 on telegram" href="https://telegram.me/share/url?text=C%2b%2b%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e8%af%a6%e8%a7%a3&amp;url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp_access_control%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++访问控制详解 on ycombinator" href="https://news.ycombinator.com/submitlink?t=C%2b%2b%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e8%af%a6%e8%a7%a3&u=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp_access_control%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://xuyafei.github.io/personal-site/>我的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>