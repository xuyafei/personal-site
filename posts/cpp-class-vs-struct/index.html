<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>全面解析C++中类(class)与结构体(struct)的区别 | 我的博客</title><meta name=keywords content><meta name=description content='全面解析C++中类(class)与结构体(struct)的区别
一、最核心区别：默认访问控制
在C++中，class和struct的唯一语法区别在于默认访问权限：
// 结构体示例
struct MyStruct {
    int x;       // 默认public访问权限
    void foo() {} // 默认public
};

// 类示例
class MyClass {
    int x;       // 默认private访问权限
    void bar() {} // 默认private
};
继承时的默认权限
struct D1 : Base {};   // 默认public继承
class D2 : Base {};    // 默认private继承
二、历史起源与设计哲学

  
      
          特性
          struct (结构体)
          class (类)
      
  
  
      
          诞生时间
          源自C语言
          C++新增概念
      
      
          设计初衷
          数据打包聚合
          面向对象封装
      
      
          核心理念
          &ldquo;这是一个数据集合&rdquo;
          &ldquo;这是一个具有行为的对象&rdquo;
      
  

三、实际开发中的惯用准则
应该使用struct的场景

纯数据集合

struct Color {
    uint8_t r, g, b, a;  // 全部公有
};

简单值类型

struct Point {
    double x, y;
    // 可以包含简单方法
    double distance() const { return sqrt(x*x + y*y); }
};

接口配置参数

struct Config {
    string title;
    int width;
    int height;
};
应该使用class的场景

需要封装的业务对象

class BankAccount {
private:
    string owner_;
    double balance_;
public:
    void deposit(double amount) { /*...*/ }
    bool withdraw(double amount) { /*...*/ }
};

需要复杂生命周期的资源管理

class DatabaseConnection {
    Connection* conn_;
public:
    explicit DatabaseConnection(string url) { /*...*/ }
    ~DatabaseConnection() { /* 自动释放资源 */ }
};

需要多态继承的体系

class Shape {
public:
    virtual double area() const = 0;
};
四、技术能力完全对比

  
      
          语言特性
          struct支持情况
          class支持情况
          示例代码
      
  
  
      
          成员变量
          ✓
          ✓
          int x;
      
      
          成员函数
          ✓
          ✓
          void f() {}
      
      
          访问控制
          ✓
          ✓
          public:
      
      
          构造函数/析构函数
          ✓
          ✓
          ~T() {}
      
      
          运算符重载
          ✓
          ✓
          T operator+()
      
      
          继承
          ✓
          ✓
          struct D : B {};
      
      
          虚函数
          ✓
          ✓
          virtual void f() = 0;
      
      
          友元
          ✓
          ✓
          friend class F;
      
      
          模板
          ✓
          ✓
          template<typename T>
      
  

五、模板元编程中的差异实践
struct在元编程中的优势
// 类型特征检查通常用struct实现
template<typename T>
struct is_pointer {
    static constexpr bool value = false;
};

template<typename T>
struct is_pointer<T*> {
    static constexpr bool value = true;
};

// 使用示例
static_assert(is_pointer<int*>::value, "必须是指针类型");
原因分析

元编程通常需要公开所有成员
避免频繁写public关键字
符合"数据即接口"的元编程哲学

六、内存布局完全一致
struct S {
    int a;
    double b;
};

class C {
    int a;
    double b;
};

// 验证内存布局相同
static_assert(sizeof(S) == sizeof(C));
static_assert(offsetof(S, b) == offsetof(C, b));
继承时的特殊情况
struct A { int x; };
class B : A { int y; };  // 私有继承可能影响空基类优化
七、与C语言的兼容性细节

  
      
          特性
          C struct
          C++ struct
      
  
  
      
          类型声明
          必须带struct关键字
          可直接作为类型名
      
      
          成员函数
          不支持
          支持
      
      
          访问控制
          无
          支持
      
      
          静态成员
          不支持
          支持
      
  

C/C++混合编程注意事项：
#ifdef __cplusplus
extern "C" {
#endif

// 确保C兼容的布局
struct CCompatStruct {
    int x;
    float y;
};

#ifdef __cplusplus
}
#endif
八、现代C++中的最佳实践

结构化绑定(struct适用)

struct Employee {
    string name;
    int id;
    double salary;
};

auto [name, id, salary] = getEmployee(); // C++17结构化绑定

类的不变量维护(class适用)

class Temperature {
    double kelvin_;
public:
    void setCelsius(double c) {
        kelvin_ = c + 273.15;
        assert(kelvin_ > 0 && "绝对温度不能为负");
    }
};

移动语义支持(两者均可)

struct Buffer {
    vector<uint8_t> data;
    Buffer(Buffer&& other) noexcept : data(std::move(other.data)) {}
};

class FileHandle {
    FILE* handle_;
public:
    FileHandle(FileHandle&& other) : handle_(other.handle_) {
        other.handle_ = nullptr;
    }
};
九、完整特性对比表格

  
      
          对比维度
          struct
          class
      
  
  
      
          基本性质
          
          
      
      
          关键字
          struct
          class
      
      
          默认访问权限
          public
          private
      
      
          默认继承方式
          public
          private
      
      
          设计用途
          
          
      
      
          数据聚合
          首选
          可用但不惯用
      
      
          对象封装
          可用但不惯用
          首选
      
      
          接口定义
          适合POD接口
          适合抽象接口
      
      
          语法特性
          
          
      
      
          成员函数
          支持
          支持
      
      
          虚函数
          支持
          支持
      
      
          友元声明
          支持
          支持
      
      
          其他特性
          
          
      
      
          模板元编程
          更常用
          较少使用
      
      
          C兼容性
          部分兼容
          不兼容
      
      
          内存布局
          与class相同
          与struct相同
      
      
          结构化绑定
          天然适合
          需要显式tuple接口
      
  

十、经典面试题解析
Q1：以下代码有何问题？
class Circle {
    double radius;
public:
    double area() const { return 3.14 * radius * radius; }
};

struct Square {
    double side;
    double area() const { return side * side; }
};
答案：'><meta name=author content><link rel=canonical href=https://xuyafei.github.io/personal-site/posts/cpp-class-vs-struct/><link crossorigin=anonymous href=/personal-site/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as=style><link rel=icon href=https://xuyafei.github.io/personal-site/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xuyafei.github.io/personal-site/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://xuyafei.github.io/personal-site/favicon-32x32.png><link rel=apple-touch-icon href=https://xuyafei.github.io/personal-site/apple-touch-icon.png><link rel=mask-icon href=https://xuyafei.github.io/personal-site/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://xuyafei.github.io/personal-site/posts/cpp-class-vs-struct/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAYQHy+K8nqKdr1EzvFzSQC+TAXx6gNQgoRxKtj+P9vvCCQTRWiV crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})})</script><script>MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta property="og:url" content="https://xuyafei.github.io/personal-site/posts/cpp-class-vs-struct/"><meta property="og:site_name" content="我的博客"><meta property="og:title" content="全面解析C++中类(class)与结构体(struct)的区别"><meta property="og:description" content='全面解析C++中类(class)与结构体(struct)的区别 一、最核心区别：默认访问控制 在C++中，class和struct的唯一语法区别在于默认访问权限：
// 结构体示例 struct MyStruct { int x; // 默认public访问权限 void foo() {} // 默认public }; // 类示例 class MyClass { int x; // 默认private访问权限 void bar() {} // 默认private }; 继承时的默认权限 struct D1 : Base {}; // 默认public继承 class D2 : Base {}; // 默认private继承 二、历史起源与设计哲学 特性 struct (结构体) class (类) 诞生时间 源自C语言 C++新增概念 设计初衷 数据打包聚合 面向对象封装 核心理念 “这是一个数据集合” “这是一个具有行为的对象” 三、实际开发中的惯用准则 应该使用struct的场景 纯数据集合 struct Color { uint8_t r, g, b, a; // 全部公有 }; 简单值类型 struct Point { double x, y; // 可以包含简单方法 double distance() const { return sqrt(x*x + y*y); } }; 接口配置参数 struct Config { string title; int width; int height; }; 应该使用class的场景 需要封装的业务对象 class BankAccount { private: string owner_; double balance_; public: void deposit(double amount) { /*...*/ } bool withdraw(double amount) { /*...*/ } }; 需要复杂生命周期的资源管理 class DatabaseConnection { Connection* conn_; public: explicit DatabaseConnection(string url) { /*...*/ } ~DatabaseConnection() { /* 自动释放资源 */ } }; 需要多态继承的体系 class Shape { public: virtual double area() const = 0; }; 四、技术能力完全对比 语言特性 struct支持情况 class支持情况 示例代码 成员变量 ✓ ✓ int x; 成员函数 ✓ ✓ void f() {} 访问控制 ✓ ✓ public: 构造函数/析构函数 ✓ ✓ ~T() {} 运算符重载 ✓ ✓ T operator+() 继承 ✓ ✓ struct D : B {}; 虚函数 ✓ ✓ virtual void f() = 0; 友元 ✓ ✓ friend class F; 模板 ✓ ✓ template<typename T> 五、模板元编程中的差异实践 struct在元编程中的优势 // 类型特征检查通常用struct实现 template<typename T> struct is_pointer { static constexpr bool value = false; }; template<typename T> struct is_pointer<T*> { static constexpr bool value = true; }; // 使用示例 static_assert(is_pointer<int*>::value, "必须是指针类型"); 原因分析 元编程通常需要公开所有成员 避免频繁写public关键字 符合"数据即接口"的元编程哲学 六、内存布局完全一致 struct S { int a; double b; }; class C { int a; double b; }; // 验证内存布局相同 static_assert(sizeof(S) == sizeof(C)); static_assert(offsetof(S, b) == offsetof(C, b)); 继承时的特殊情况 struct A { int x; }; class B : A { int y; }; // 私有继承可能影响空基类优化 七、与C语言的兼容性细节 特性 C struct C++ struct 类型声明 必须带struct关键字 可直接作为类型名 成员函数 不支持 支持 访问控制 无 支持 静态成员 不支持 支持 C/C++混合编程注意事项： #ifdef __cplusplus extern "C" { #endif // 确保C兼容的布局 struct CCompatStruct { int x; float y; }; #ifdef __cplusplus } #endif 八、现代C++中的最佳实践 结构化绑定(struct适用) struct Employee { string name; int id; double salary; }; auto [name, id, salary] = getEmployee(); // C++17结构化绑定 类的不变量维护(class适用) class Temperature { double kelvin_; public: void setCelsius(double c) { kelvin_ = c + 273.15; assert(kelvin_ > 0 && "绝对温度不能为负"); } }; 移动语义支持(两者均可) struct Buffer { vector<uint8_t> data; Buffer(Buffer&& other) noexcept : data(std::move(other.data)) {} }; class FileHandle { FILE* handle_; public: FileHandle(FileHandle&& other) : handle_(other.handle_) { other.handle_ = nullptr; } }; 九、完整特性对比表格 对比维度 struct class 基本性质 关键字 struct class 默认访问权限 public private 默认继承方式 public private 设计用途 数据聚合 首选 可用但不惯用 对象封装 可用但不惯用 首选 接口定义 适合POD接口 适合抽象接口 语法特性 成员函数 支持 支持 虚函数 支持 支持 友元声明 支持 支持 其他特性 模板元编程 更常用 较少使用 C兼容性 部分兼容 不兼容 内存布局 与class相同 与struct相同 结构化绑定 天然适合 需要显式tuple接口 十、经典面试题解析 Q1：以下代码有何问题？ class Circle { double radius; public: double area() const { return 3.14 * radius * radius; } }; struct Square { double side; double area() const { return side * side; } }; 答案：'><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-26T00:14:00+08:00"><meta property="article:modified_time" content="2025-04-26T00:14:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="全面解析C++中类(class)与结构体(struct)的区别"><meta name=twitter:description content='全面解析C++中类(class)与结构体(struct)的区别
一、最核心区别：默认访问控制
在C++中，class和struct的唯一语法区别在于默认访问权限：
// 结构体示例
struct MyStruct {
    int x;       // 默认public访问权限
    void foo() {} // 默认public
};

// 类示例
class MyClass {
    int x;       // 默认private访问权限
    void bar() {} // 默认private
};
继承时的默认权限
struct D1 : Base {};   // 默认public继承
class D2 : Base {};    // 默认private继承
二、历史起源与设计哲学

  
      
          特性
          struct (结构体)
          class (类)
      
  
  
      
          诞生时间
          源自C语言
          C++新增概念
      
      
          设计初衷
          数据打包聚合
          面向对象封装
      
      
          核心理念
          &ldquo;这是一个数据集合&rdquo;
          &ldquo;这是一个具有行为的对象&rdquo;
      
  

三、实际开发中的惯用准则
应该使用struct的场景

纯数据集合

struct Color {
    uint8_t r, g, b, a;  // 全部公有
};

简单值类型

struct Point {
    double x, y;
    // 可以包含简单方法
    double distance() const { return sqrt(x*x + y*y); }
};

接口配置参数

struct Config {
    string title;
    int width;
    int height;
};
应该使用class的场景

需要封装的业务对象

class BankAccount {
private:
    string owner_;
    double balance_;
public:
    void deposit(double amount) { /*...*/ }
    bool withdraw(double amount) { /*...*/ }
};

需要复杂生命周期的资源管理

class DatabaseConnection {
    Connection* conn_;
public:
    explicit DatabaseConnection(string url) { /*...*/ }
    ~DatabaseConnection() { /* 自动释放资源 */ }
};

需要多态继承的体系

class Shape {
public:
    virtual double area() const = 0;
};
四、技术能力完全对比

  
      
          语言特性
          struct支持情况
          class支持情况
          示例代码
      
  
  
      
          成员变量
          ✓
          ✓
          int x;
      
      
          成员函数
          ✓
          ✓
          void f() {}
      
      
          访问控制
          ✓
          ✓
          public:
      
      
          构造函数/析构函数
          ✓
          ✓
          ~T() {}
      
      
          运算符重载
          ✓
          ✓
          T operator+()
      
      
          继承
          ✓
          ✓
          struct D : B {};
      
      
          虚函数
          ✓
          ✓
          virtual void f() = 0;
      
      
          友元
          ✓
          ✓
          friend class F;
      
      
          模板
          ✓
          ✓
          template<typename T>
      
  

五、模板元编程中的差异实践
struct在元编程中的优势
// 类型特征检查通常用struct实现
template<typename T>
struct is_pointer {
    static constexpr bool value = false;
};

template<typename T>
struct is_pointer<T*> {
    static constexpr bool value = true;
};

// 使用示例
static_assert(is_pointer<int*>::value, "必须是指针类型");
原因分析

元编程通常需要公开所有成员
避免频繁写public关键字
符合"数据即接口"的元编程哲学

六、内存布局完全一致
struct S {
    int a;
    double b;
};

class C {
    int a;
    double b;
};

// 验证内存布局相同
static_assert(sizeof(S) == sizeof(C));
static_assert(offsetof(S, b) == offsetof(C, b));
继承时的特殊情况
struct A { int x; };
class B : A { int y; };  // 私有继承可能影响空基类优化
七、与C语言的兼容性细节

  
      
          特性
          C struct
          C++ struct
      
  
  
      
          类型声明
          必须带struct关键字
          可直接作为类型名
      
      
          成员函数
          不支持
          支持
      
      
          访问控制
          无
          支持
      
      
          静态成员
          不支持
          支持
      
  

C/C++混合编程注意事项：
#ifdef __cplusplus
extern "C" {
#endif

// 确保C兼容的布局
struct CCompatStruct {
    int x;
    float y;
};

#ifdef __cplusplus
}
#endif
八、现代C++中的最佳实践

结构化绑定(struct适用)

struct Employee {
    string name;
    int id;
    double salary;
};

auto [name, id, salary] = getEmployee(); // C++17结构化绑定

类的不变量维护(class适用)

class Temperature {
    double kelvin_;
public:
    void setCelsius(double c) {
        kelvin_ = c + 273.15;
        assert(kelvin_ > 0 && "绝对温度不能为负");
    }
};

移动语义支持(两者均可)

struct Buffer {
    vector<uint8_t> data;
    Buffer(Buffer&& other) noexcept : data(std::move(other.data)) {}
};

class FileHandle {
    FILE* handle_;
public:
    FileHandle(FileHandle&& other) : handle_(other.handle_) {
        other.handle_ = nullptr;
    }
};
九、完整特性对比表格

  
      
          对比维度
          struct
          class
      
  
  
      
          基本性质
          
          
      
      
          关键字
          struct
          class
      
      
          默认访问权限
          public
          private
      
      
          默认继承方式
          public
          private
      
      
          设计用途
          
          
      
      
          数据聚合
          首选
          可用但不惯用
      
      
          对象封装
          可用但不惯用
          首选
      
      
          接口定义
          适合POD接口
          适合抽象接口
      
      
          语法特性
          
          
      
      
          成员函数
          支持
          支持
      
      
          虚函数
          支持
          支持
      
      
          友元声明
          支持
          支持
      
      
          其他特性
          
          
      
      
          模板元编程
          更常用
          较少使用
      
      
          C兼容性
          部分兼容
          不兼容
      
      
          内存布局
          与class相同
          与struct相同
      
      
          结构化绑定
          天然适合
          需要显式tuple接口
      
  

十、经典面试题解析
Q1：以下代码有何问题？
class Circle {
    double radius;
public:
    double area() const { return 3.14 * radius * radius; }
};

struct Square {
    double side;
    double area() const { return side * side; }
};
答案：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://xuyafei.github.io/personal-site/posts/"},{"@type":"ListItem","position":2,"name":"全面解析C++中类(class)与结构体(struct)的区别","item":"https://xuyafei.github.io/personal-site/posts/cpp-class-vs-struct/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"全面解析C++中类(class)与结构体(struct)的区别","name":"全面解析C\u002b\u002b中类(class)与结构体(struct)的区别","description":"全面解析C++中类(class)与结构体(struct)的区别 一、最核心区别：默认访问控制 在C++中，class和struct的唯一语法区别在于默认访问权限：\n// 结构体示例 struct MyStruct { int x; // 默认public访问权限 void foo() {} // 默认public }; // 类示例 class MyClass { int x; // 默认private访问权限 void bar() {} // 默认private }; 继承时的默认权限 struct D1 : Base {}; // 默认public继承 class D2 : Base {}; // 默认private继承 二、历史起源与设计哲学 特性 struct (结构体) class (类) 诞生时间 源自C语言 C++新增概念 设计初衷 数据打包聚合 面向对象封装 核心理念 \u0026ldquo;这是一个数据集合\u0026rdquo; \u0026ldquo;这是一个具有行为的对象\u0026rdquo; 三、实际开发中的惯用准则 应该使用struct的场景 纯数据集合 struct Color { uint8_t r, g, b, a; // 全部公有 }; 简单值类型 struct Point { double x, y; // 可以包含简单方法 double distance() const { return sqrt(x*x + y*y); } }; 接口配置参数 struct Config { string title; int width; int height; }; 应该使用class的场景 需要封装的业务对象 class BankAccount { private: string owner_; double balance_; public: void deposit(double amount) { /*...*/ } bool withdraw(double amount) { /*...*/ } }; 需要复杂生命周期的资源管理 class DatabaseConnection { Connection* conn_; public: explicit DatabaseConnection(string url) { /*...*/ } ~DatabaseConnection() { /* 自动释放资源 */ } }; 需要多态继承的体系 class Shape { public: virtual double area() const = 0; }; 四、技术能力完全对比 语言特性 struct支持情况 class支持情况 示例代码 成员变量 ✓ ✓ int x; 成员函数 ✓ ✓ void f() {} 访问控制 ✓ ✓ public: 构造函数/析构函数 ✓ ✓ ~T() {} 运算符重载 ✓ ✓ T operator+() 继承 ✓ ✓ struct D : B {}; 虚函数 ✓ ✓ virtual void f() = 0; 友元 ✓ ✓ friend class F; 模板 ✓ ✓ template\u0026lt;typename T\u0026gt; 五、模板元编程中的差异实践 struct在元编程中的优势 // 类型特征检查通常用struct实现 template\u0026lt;typename T\u0026gt; struct is_pointer { static constexpr bool value = false; }; template\u0026lt;typename T\u0026gt; struct is_pointer\u0026lt;T*\u0026gt; { static constexpr bool value = true; }; // 使用示例 static_assert(is_pointer\u0026lt;int*\u0026gt;::value, \u0026#34;必须是指针类型\u0026#34;); 原因分析 元编程通常需要公开所有成员 避免频繁写public关键字 符合\u0026quot;数据即接口\u0026quot;的元编程哲学 六、内存布局完全一致 struct S { int a; double b; }; class C { int a; double b; }; // 验证内存布局相同 static_assert(sizeof(S) == sizeof(C)); static_assert(offsetof(S, b) == offsetof(C, b)); 继承时的特殊情况 struct A { int x; }; class B : A { int y; }; // 私有继承可能影响空基类优化 七、与C语言的兼容性细节 特性 C struct C++ struct 类型声明 必须带struct关键字 可直接作为类型名 成员函数 不支持 支持 访问控制 无 支持 静态成员 不支持 支持 C/C++混合编程注意事项： #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif // 确保C兼容的布局 struct CCompatStruct { int x; float y; }; #ifdef __cplusplus } #endif 八、现代C++中的最佳实践 结构化绑定(struct适用) struct Employee { string name; int id; double salary; }; auto [name, id, salary] = getEmployee(); // C++17结构化绑定 类的不变量维护(class适用) class Temperature { double kelvin_; public: void setCelsius(double c) { kelvin_ = c + 273.15; assert(kelvin_ \u0026gt; 0 \u0026amp;\u0026amp; \u0026#34;绝对温度不能为负\u0026#34;); } }; 移动语义支持(两者均可) struct Buffer { vector\u0026lt;uint8_t\u0026gt; data; Buffer(Buffer\u0026amp;\u0026amp; other) noexcept : data(std::move(other.data)) {} }; class FileHandle { FILE* handle_; public: FileHandle(FileHandle\u0026amp;\u0026amp; other) : handle_(other.handle_) { other.handle_ = nullptr; } }; 九、完整特性对比表格 对比维度 struct class 基本性质 关键字 struct class 默认访问权限 public private 默认继承方式 public private 设计用途 数据聚合 首选 可用但不惯用 对象封装 可用但不惯用 首选 接口定义 适合POD接口 适合抽象接口 语法特性 成员函数 支持 支持 虚函数 支持 支持 友元声明 支持 支持 其他特性 模板元编程 更常用 较少使用 C兼容性 部分兼容 不兼容 内存布局 与class相同 与struct相同 结构化绑定 天然适合 需要显式tuple接口 十、经典面试题解析 Q1：以下代码有何问题？ class Circle { double radius; public: double area() const { return 3.14 * radius * radius; } }; struct Square { double side; double area() const { return side * side; } }; 答案：\n","keywords":[],"articleBody":"全面解析C++中类(class)与结构体(struct)的区别 一、最核心区别：默认访问控制 在C++中，class和struct的唯一语法区别在于默认访问权限：\n// 结构体示例 struct MyStruct { int x; // 默认public访问权限 void foo() {} // 默认public }; // 类示例 class MyClass { int x; // 默认private访问权限 void bar() {} // 默认private }; 继承时的默认权限 struct D1 : Base {}; // 默认public继承 class D2 : Base {}; // 默认private继承 二、历史起源与设计哲学 特性 struct (结构体) class (类) 诞生时间 源自C语言 C++新增概念 设计初衷 数据打包聚合 面向对象封装 核心理念 “这是一个数据集合” “这是一个具有行为的对象” 三、实际开发中的惯用准则 应该使用struct的场景 纯数据集合 struct Color { uint8_t r, g, b, a; // 全部公有 }; 简单值类型 struct Point { double x, y; // 可以包含简单方法 double distance() const { return sqrt(x*x + y*y); } }; 接口配置参数 struct Config { string title; int width; int height; }; 应该使用class的场景 需要封装的业务对象 class BankAccount { private: string owner_; double balance_; public: void deposit(double amount) { /*...*/ } bool withdraw(double amount) { /*...*/ } }; 需要复杂生命周期的资源管理 class DatabaseConnection { Connection* conn_; public: explicit DatabaseConnection(string url) { /*...*/ } ~DatabaseConnection() { /* 自动释放资源 */ } }; 需要多态继承的体系 class Shape { public: virtual double area() const = 0; }; 四、技术能力完全对比 语言特性 struct支持情况 class支持情况 示例代码 成员变量 ✓ ✓ int x; 成员函数 ✓ ✓ void f() {} 访问控制 ✓ ✓ public: 构造函数/析构函数 ✓ ✓ ~T() {} 运算符重载 ✓ ✓ T operator+() 继承 ✓ ✓ struct D : B {}; 虚函数 ✓ ✓ virtual void f() = 0; 友元 ✓ ✓ friend class F; 模板 ✓ ✓ template 五、模板元编程中的差异实践 struct在元编程中的优势 // 类型特征检查通常用struct实现 template\u003ctypename T\u003e struct is_pointer { static constexpr bool value = false; }; template\u003ctypename T\u003e struct is_pointer\u003cT*\u003e { static constexpr bool value = true; }; // 使用示例 static_assert(is_pointer\u003cint*\u003e::value, \"必须是指针类型\"); 原因分析 元编程通常需要公开所有成员 避免频繁写public关键字 符合\"数据即接口\"的元编程哲学 六、内存布局完全一致 struct S { int a; double b; }; class C { int a; double b; }; // 验证内存布局相同 static_assert(sizeof(S) == sizeof(C)); static_assert(offsetof(S, b) == offsetof(C, b)); 继承时的特殊情况 struct A { int x; }; class B : A { int y; }; // 私有继承可能影响空基类优化 七、与C语言的兼容性细节 特性 C struct C++ struct 类型声明 必须带struct关键字 可直接作为类型名 成员函数 不支持 支持 访问控制 无 支持 静态成员 不支持 支持 C/C++混合编程注意事项： #ifdef __cplusplus extern \"C\" { #endif // 确保C兼容的布局 struct CCompatStruct { int x; float y; }; #ifdef __cplusplus } #endif 八、现代C++中的最佳实践 结构化绑定(struct适用) struct Employee { string name; int id; double salary; }; auto [name, id, salary] = getEmployee(); // C++17结构化绑定 类的不变量维护(class适用) class Temperature { double kelvin_; public: void setCelsius(double c) { kelvin_ = c + 273.15; assert(kelvin_ \u003e 0 \u0026\u0026 \"绝对温度不能为负\"); } }; 移动语义支持(两者均可) struct Buffer { vector\u003cuint8_t\u003e data; Buffer(Buffer\u0026\u0026 other) noexcept : data(std::move(other.data)) {} }; class FileHandle { FILE* handle_; public: FileHandle(FileHandle\u0026\u0026 other) : handle_(other.handle_) { other.handle_ = nullptr; } }; 九、完整特性对比表格 对比维度 struct class 基本性质 关键字 struct class 默认访问权限 public private 默认继承方式 public private 设计用途 数据聚合 首选 可用但不惯用 对象封装 可用但不惯用 首选 接口定义 适合POD接口 适合抽象接口 语法特性 成员函数 支持 支持 虚函数 支持 支持 友元声明 支持 支持 其他特性 模板元编程 更常用 较少使用 C兼容性 部分兼容 不兼容 内存布局 与class相同 与struct相同 结构化绑定 天然适合 需要显式tuple接口 十、经典面试题解析 Q1：以下代码有何问题？ class Circle { double radius; public: double area() const { return 3.14 * radius * radius; } }; struct Square { double side; double area() const { return side * side; } }; 答案：\n从技术上讲没有问题 但从设计角度看： Circle将数据隐藏是合理的 Square作为简单的几何图形，使用struct更合适 Q2：为什么STL中用struct实现迭代器特性？ template\u003cclass Iterator\u003e struct iterator_traits { using value_type = typename Iterator::value_type; // ... }; 答案：\n特性类需要所有成员公开 避免频繁写public关键字 符合\"特性即数据\"的元编程哲学 总结选择策略 默认选择class当：\n需要维护不变量的类型 需要复杂生命周期的对象 需要多态继承的体系 默认选择struct当：\n纯数据集合 简单的值类型 需要与C交互的数据结构 模板元编程场景 永远保持一致：\n同一个项目中保持统一风格 在混合使用时明确标注原因 ","wordCount":"529","inLanguage":"en","datePublished":"2025-04-26T00:14:00+08:00","dateModified":"2025-04-26T00:14:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://xuyafei.github.io/personal-site/posts/cpp-class-vs-struct/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://xuyafei.github.io/personal-site/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xuyafei.github.io/personal-site/ accesskey=h title="我的博客 (Alt + H)">我的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xuyafei.github.io/personal-site/categories/ title=分类><span>分类</span></a></li><li><a href=https://xuyafei.github.io/personal-site/tags/ title=标签><span>标签</span></a></li><li><a href=https://xuyafei.github.io/personal-site/archives/ title=归档><span>归档</span></a></li><li><a href=https://xuyafei.github.io/personal-site/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xuyafei.github.io/personal-site/>Home</a>&nbsp;»&nbsp;<a href=https://xuyafei.github.io/personal-site/posts/>文章</a></div><h1 class="post-title entry-hint-parent">全面解析C++中类(class)与结构体(struct)的区别</h1><div class=post-meta><span title='2025-04-26 00:14:00 +0800 +0800'>April 26, 2025</span>&nbsp;·&nbsp;3 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90c%e4%b8%ad%e7%b1%bbclass%e4%b8%8e%e7%bb%93%e6%9e%84%e4%bd%93struct%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=全面解析C++中类(class)与结构体(struct)的区别>全面解析C++中类(class)与结构体(struct)的区别</a><ul><li><a href=#%e4%b8%80%e6%9c%80%e6%a0%b8%e5%bf%83%e5%8c%ba%e5%88%ab%e9%bb%98%e8%ae%a4%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6 aria-label=一、最核心区别：默认访问控制>一、最核心区别：默认访问控制</a><ul><li><a href=#%e7%bb%a7%e6%89%bf%e6%97%b6%e7%9a%84%e9%bb%98%e8%ae%a4%e6%9d%83%e9%99%90 aria-label=继承时的默认权限>继承时的默认权限</a></li></ul></li><li><a href=#%e4%ba%8c%e5%8e%86%e5%8f%b2%e8%b5%b7%e6%ba%90%e4%b8%8e%e8%ae%be%e8%ae%a1%e5%93%b2%e5%ad%a6 aria-label=二、历史起源与设计哲学>二、历史起源与设计哲学</a></li><li><a href=#%e4%b8%89%e5%ae%9e%e9%99%85%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e6%83%af%e7%94%a8%e5%87%86%e5%88%99 aria-label=三、实际开发中的惯用准则>三、实际开发中的惯用准则</a><ul><li><a href=#%e5%ba%94%e8%af%a5%e4%bd%bf%e7%94%a8struct%e7%9a%84%e5%9c%ba%e6%99%af aria-label=应该使用struct的场景>应该使用struct的场景</a></li><li><a href=#%e5%ba%94%e8%af%a5%e4%bd%bf%e7%94%a8class%e7%9a%84%e5%9c%ba%e6%99%af aria-label=应该使用class的场景>应该使用class的场景</a></li></ul></li><li><a href=#%e5%9b%9b%e6%8a%80%e6%9c%af%e8%83%bd%e5%8a%9b%e5%ae%8c%e5%85%a8%e5%af%b9%e6%af%94 aria-label=四、技术能力完全对比>四、技术能力完全对比</a></li><li><a href=#%e4%ba%94%e6%a8%a1%e6%9d%bf%e5%85%83%e7%bc%96%e7%a8%8b%e4%b8%ad%e7%9a%84%e5%b7%ae%e5%bc%82%e5%ae%9e%e8%b7%b5 aria-label=五、模板元编程中的差异实践>五、模板元编程中的差异实践</a><ul><li><a href=#struct%e5%9c%a8%e5%85%83%e7%bc%96%e7%a8%8b%e4%b8%ad%e7%9a%84%e4%bc%98%e5%8a%bf aria-label=struct在元编程中的优势>struct在元编程中的优势</a></li><li><a href=#%e5%8e%9f%e5%9b%a0%e5%88%86%e6%9e%90 aria-label=原因分析>原因分析</a></li></ul></li><li><a href=#%e5%85%ad%e5%86%85%e5%ad%98%e5%b8%83%e5%b1%80%e5%ae%8c%e5%85%a8%e4%b8%80%e8%87%b4 aria-label=六、内存布局完全一致>六、内存布局完全一致</a><ul><li><a href=#%e7%bb%a7%e6%89%bf%e6%97%b6%e7%9a%84%e7%89%b9%e6%ae%8a%e6%83%85%e5%86%b5 aria-label=继承时的特殊情况>继承时的特殊情况</a></li></ul></li><li><a href=#%e4%b8%83%e4%b8%8ec%e8%af%ad%e8%a8%80%e7%9a%84%e5%85%bc%e5%ae%b9%e6%80%a7%e7%bb%86%e8%8a%82 aria-label=七、与C语言的兼容性细节>七、与C语言的兼容性细节</a><ul><li><a href=#cc%e6%b7%b7%e5%90%88%e7%bc%96%e7%a8%8b%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9 aria-label=C/C++混合编程注意事项：>C/C++混合编程注意事项：</a></li></ul></li><li><a href=#%e5%85%ab%e7%8e%b0%e4%bb%a3c%e4%b8%ad%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5 aria-label=八、现代C++中的最佳实践>八、现代C++中的最佳实践</a></li><li><a href=#%e4%b9%9d%e5%ae%8c%e6%95%b4%e7%89%b9%e6%80%a7%e5%af%b9%e6%af%94%e8%a1%a8%e6%a0%bc aria-label=九、完整特性对比表格>九、完整特性对比表格</a></li><li><a href=#%e5%8d%81%e7%bb%8f%e5%85%b8%e9%9d%a2%e8%af%95%e9%a2%98%e8%a7%a3%e6%9e%90 aria-label=十、经典面试题解析>十、经典面试题解析</a><ul><li><a href=#q1%e4%bb%a5%e4%b8%8b%e4%bb%a3%e7%a0%81%e6%9c%89%e4%bd%95%e9%97%ae%e9%a2%98 aria-label=Q1：以下代码有何问题？>Q1：以下代码有何问题？</a></li><li><a href=#q2%e4%b8%ba%e4%bb%80%e4%b9%88stl%e4%b8%ad%e7%94%a8struct%e5%ae%9e%e7%8e%b0%e8%bf%ad%e4%bb%a3%e5%99%a8%e7%89%b9%e6%80%a7 aria-label=Q2：为什么STL中用struct实现迭代器特性？>Q2：为什么STL中用struct实现迭代器特性？</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93%e9%80%89%e6%8b%a9%e7%ad%96%e7%95%a5 aria-label=总结选择策略>总结选择策略</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=全面解析c中类class与结构体struct的区别>全面解析C++中类(class)与结构体(struct)的区别<a hidden class=anchor aria-hidden=true href=#全面解析c中类class与结构体struct的区别>#</a></h1><h2 id=一最核心区别默认访问控制>一、最核心区别：默认访问控制<a hidden class=anchor aria-hidden=true href=#一最核心区别默认访问控制>#</a></h2><p>在C++中，<code>class</code>和<code>struct</code>的唯一语法区别在于默认访问权限：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// 结构体示例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyStruct</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;       <span style=color:#75715e>// 默认public访问权限
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>() {} <span style=color:#75715e>// 默认public
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 类示例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;       <span style=color:#75715e>// 默认private访问权限
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bar</span>() {} <span style=color:#75715e>// 默认private
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h3 id=继承时的默认权限>继承时的默认权限<a hidden class=anchor aria-hidden=true href=#继承时的默认权限>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>D1</span> <span style=color:#f92672>:</span> Base {};   <span style=color:#75715e>// 默认public继承
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>D2</span> <span style=color:#f92672>:</span> Base {};    <span style=color:#75715e>// 默认private继承
</span></span></span></code></pre></div><h2 id=二历史起源与设计哲学>二、历史起源与设计哲学<a hidden class=anchor aria-hidden=true href=#二历史起源与设计哲学>#</a></h2><table><thead><tr><th>特性</th><th>struct (结构体)</th><th>class (类)</th></tr></thead><tbody><tr><td>诞生时间</td><td>源自C语言</td><td>C++新增概念</td></tr><tr><td>设计初衷</td><td>数据打包聚合</td><td>面向对象封装</td></tr><tr><td>核心理念</td><td>&ldquo;这是一个数据集合&rdquo;</td><td>&ldquo;这是一个具有行为的对象&rdquo;</td></tr></tbody></table><h2 id=三实际开发中的惯用准则>三、实际开发中的惯用准则<a hidden class=anchor aria-hidden=true href=#三实际开发中的惯用准则>#</a></h2><h3 id=应该使用struct的场景>应该使用struct的场景<a hidden class=anchor aria-hidden=true href=#应该使用struct的场景>#</a></h3><ol><li>纯数据集合</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Color</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> r, g, b, a;  <span style=color:#75715e>// 全部公有
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><ol start=2><li>简单值类型</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> x, y;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 可以包含简单方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>distance</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> sqrt(x<span style=color:#f92672>*</span>x <span style=color:#f92672>+</span> y<span style=color:#f92672>*</span>y); }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ol start=3><li>接口配置参数</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Config</span> {
</span></span><span style=display:flex><span>    string title;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> width;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> height;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=应该使用class的场景>应该使用class的场景<a hidden class=anchor aria-hidden=true href=#应该使用class的场景>#</a></h3><ol><li>需要封装的业务对象</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BankAccount</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    string owner_;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> balance_;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> deposit(<span style=color:#66d9ef>double</span> amount) { <span style=color:#75715e>/*...*/</span> }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>withdraw</span>(<span style=color:#66d9ef>double</span> amount) { <span style=color:#75715e>/*...*/</span> }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ol start=2><li>需要复杂生命周期的资源管理</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DatabaseConnection</span> {
</span></span><span style=display:flex><span>    Connection<span style=color:#f92672>*</span> conn_;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> DatabaseConnection(string url) { <span style=color:#75715e>/*...*/</span> }
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>DatabaseConnection() { <span style=color:#75715e>/* 自动释放资源 */</span> }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ol start=3><li>需要多态继承的体系</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Shape</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>double</span> area() <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=四技术能力完全对比>四、技术能力完全对比<a hidden class=anchor aria-hidden=true href=#四技术能力完全对比>#</a></h2><table><thead><tr><th>语言特性</th><th>struct支持情况</th><th>class支持情况</th><th>示例代码</th></tr></thead><tbody><tr><td>成员变量</td><td>✓</td><td>✓</td><td><code>int x;</code></td></tr><tr><td>成员函数</td><td>✓</td><td>✓</td><td><code>void f() {}</code></td></tr><tr><td>访问控制</td><td>✓</td><td>✓</td><td><code>public:</code></td></tr><tr><td>构造函数/析构函数</td><td>✓</td><td>✓</td><td><code>~T() {}</code></td></tr><tr><td>运算符重载</td><td>✓</td><td>✓</td><td><code>T operator+()</code></td></tr><tr><td>继承</td><td>✓</td><td>✓</td><td><code>struct D : B {};</code></td></tr><tr><td>虚函数</td><td>✓</td><td>✓</td><td><code>virtual void f() = 0;</code></td></tr><tr><td>友元</td><td>✓</td><td>✓</td><td><code>friend class F;</code></td></tr><tr><td>模板</td><td>✓</td><td>✓</td><td><code>template&lt;typename T></code></td></tr></tbody></table><h2 id=五模板元编程中的差异实践>五、模板元编程中的差异实践<a hidden class=anchor aria-hidden=true href=#五模板元编程中的差异实践>#</a></h2><h3 id=struct在元编程中的优势>struct在元编程中的优势<a hidden class=anchor aria-hidden=true href=#struct在元编程中的优势>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// 类型特征检查通常用struct实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>is_pointer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>bool</span> value <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>is_pointer</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>*&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>bool</span> value <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用示例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static_assert</span>(is_pointer<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>*&gt;::</span>value, <span style=color:#e6db74>&#34;必须是指针类型&#34;</span>);
</span></span></code></pre></div><h3 id=原因分析>原因分析<a hidden class=anchor aria-hidden=true href=#原因分析>#</a></h3><ol><li>元编程通常需要公开所有成员</li><li>避免频繁写public关键字</li><li>符合"数据即接口"的元编程哲学</li></ol><h2 id=六内存布局完全一致>六、内存布局完全一致<a hidden class=anchor aria-hidden=true href=#六内存布局完全一致>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>S</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> b;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>C</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> b;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 验证内存布局相同
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static_assert</span>(<span style=color:#66d9ef>sizeof</span>(S) <span style=color:#f92672>==</span> <span style=color:#66d9ef>sizeof</span>(C));
</span></span><span style=display:flex><span><span style=color:#66d9ef>static_assert</span>(offsetof(S, b) <span style=color:#f92672>==</span> offsetof(C, b));
</span></span></code></pre></div><h3 id=继承时的特殊情况>继承时的特殊情况<a hidden class=anchor aria-hidden=true href=#继承时的特殊情况>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>A</span> { <span style=color:#66d9ef>int</span> x; };
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#f92672>:</span> A { <span style=color:#66d9ef>int</span> y; };  <span style=color:#75715e>// 私有继承可能影响空基类优化
</span></span></span></code></pre></div><h2 id=七与c语言的兼容性细节>七、与C语言的兼容性细节<a hidden class=anchor aria-hidden=true href=#七与c语言的兼容性细节>#</a></h2><table><thead><tr><th>特性</th><th>C struct</th><th>C++ struct</th></tr></thead><tbody><tr><td>类型声明</td><td>必须带struct关键字</td><td>可直接作为类型名</td></tr><tr><td>成员函数</td><td>不支持</td><td>支持</td></tr><tr><td>访问控制</td><td>无</td><td>支持</td></tr><tr><td>静态成员</td><td>不支持</td><td>支持</td></tr></tbody></table><h3 id=cc混合编程注意事项>C/C++混合编程注意事项：<a hidden class=anchor aria-hidden=true href=#cc混合编程注意事项>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#ifdef __cplusplus
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 确保C兼容的布局
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CCompatStruct</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> y;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __cplusplus
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span></code></pre></div><h2 id=八现代c中的最佳实践>八、现代C++中的最佳实践<a hidden class=anchor aria-hidden=true href=#八现代c中的最佳实践>#</a></h2><ol><li>结构化绑定(struct适用)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Employee</span> {
</span></span><span style=display:flex><span>    string name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> id;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> salary;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> [name, id, salary] <span style=color:#f92672>=</span> getEmployee(); <span style=color:#75715e>// C++17结构化绑定
</span></span></span></code></pre></div><ol start=2><li>类的不变量维护(class适用)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Temperature</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> kelvin_;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> setCelsius(<span style=color:#66d9ef>double</span> c) {
</span></span><span style=display:flex><span>        kelvin_ <span style=color:#f92672>=</span> c <span style=color:#f92672>+</span> <span style=color:#ae81ff>273.15</span>;
</span></span><span style=display:flex><span>        assert(kelvin_ <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#e6db74>&#34;绝对温度不能为负&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ol start=3><li>移动语义支持(两者均可)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Buffer</span> {
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&gt;</span> data;
</span></span><span style=display:flex><span>    Buffer(Buffer<span style=color:#f92672>&amp;&amp;</span> other) <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> data(std<span style=color:#f92672>::</span>move(other.data)) {}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FileHandle</span> {
</span></span><span style=display:flex><span>    FILE<span style=color:#f92672>*</span> handle_;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    FileHandle(FileHandle<span style=color:#f92672>&amp;&amp;</span> other) <span style=color:#f92672>:</span> handle_(other.handle_) {
</span></span><span style=display:flex><span>        other.handle_ <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=九完整特性对比表格>九、完整特性对比表格<a hidden class=anchor aria-hidden=true href=#九完整特性对比表格>#</a></h2><table><thead><tr><th>对比维度</th><th>struct</th><th>class</th></tr></thead><tbody><tr><td><strong>基本性质</strong></td><td></td><td></td></tr><tr><td>关键字</td><td>struct</td><td>class</td></tr><tr><td>默认访问权限</td><td>public</td><td>private</td></tr><tr><td>默认继承方式</td><td>public</td><td>private</td></tr><tr><td><strong>设计用途</strong></td><td></td><td></td></tr><tr><td>数据聚合</td><td>首选</td><td>可用但不惯用</td></tr><tr><td>对象封装</td><td>可用但不惯用</td><td>首选</td></tr><tr><td>接口定义</td><td>适合POD接口</td><td>适合抽象接口</td></tr><tr><td><strong>语法特性</strong></td><td></td><td></td></tr><tr><td>成员函数</td><td>支持</td><td>支持</td></tr><tr><td>虚函数</td><td>支持</td><td>支持</td></tr><tr><td>友元声明</td><td>支持</td><td>支持</td></tr><tr><td><strong>其他特性</strong></td><td></td><td></td></tr><tr><td>模板元编程</td><td>更常用</td><td>较少使用</td></tr><tr><td>C兼容性</td><td>部分兼容</td><td>不兼容</td></tr><tr><td>内存布局</td><td>与class相同</td><td>与struct相同</td></tr><tr><td>结构化绑定</td><td>天然适合</td><td>需要显式tuple接口</td></tr></tbody></table><h2 id=十经典面试题解析>十、经典面试题解析<a hidden class=anchor aria-hidden=true href=#十经典面试题解析>#</a></h2><h3 id=q1以下代码有何问题>Q1：以下代码有何问题？<a hidden class=anchor aria-hidden=true href=#q1以下代码有何问题>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Circle</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> radius;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> area() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>3.14</span> <span style=color:#f92672>*</span> radius <span style=color:#f92672>*</span> radius; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Square</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> side;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>area</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> side <span style=color:#f92672>*</span> side; }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>答案：</strong></p><ul><li>从技术上讲没有问题</li><li>但从设计角度看：<ul><li>Circle将数据隐藏是合理的</li><li>Square作为简单的几何图形，使用struct更合适</li></ul></li></ul><h3 id=q2为什么stl中用struct实现迭代器特性>Q2：为什么STL中用struct实现迭代器特性？<a hidden class=anchor aria-hidden=true href=#q2为什么stl中用struct实现迭代器特性>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Iterator</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>iterator_traits</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> value_type <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> Iterator<span style=color:#f92672>::</span>value_type;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p><strong>答案：</strong></p><ol><li>特性类需要所有成员公开</li><li>避免频繁写public关键字</li><li>符合"特性即数据"的元编程哲学</li></ol><h2 id=总结选择策略>总结选择策略<a hidden class=anchor aria-hidden=true href=#总结选择策略>#</a></h2><ol><li><p>默认选择class当：</p><ul><li>需要维护不变量的类型</li><li>需要复杂生命周期的对象</li><li>需要多态继承的体系</li></ul></li><li><p>默认选择struct当：</p><ul><li>纯数据集合</li><li>简单的值类型</li><li>需要与C交互的数据结构</li><li>模板元编程场景</li></ul></li><li><p>永远保持一致：</p><ul><li>同一个项目中保持统一风格</li><li>在混合使用时明确标注原因</li></ul></li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://xuyafei.github.io/personal-site/posts/video_loss_recovery/><span class=title>« Prev</span><br><span>视频传输中的丢包恢复机制：NACK与FEC详解</span>
</a><a class=next href=https://xuyafei.github.io/personal-site/posts/katex-test/><span class=title>Next »</span><br><span>KaTeX 测试</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 全面解析C++中类(class)与结构体(struct)的区别 on x" href="https://x.com/intent/tweet/?text=%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90C%2b%2b%e4%b8%ad%e7%b1%bb%28class%29%e4%b8%8e%e7%bb%93%e6%9e%84%e4%bd%93%28struct%29%e7%9a%84%e5%8c%ba%e5%88%ab&amp;url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp-class-vs-struct%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 全面解析C++中类(class)与结构体(struct)的区别 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp-class-vs-struct%2f&amp;title=%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90C%2b%2b%e4%b8%ad%e7%b1%bb%28class%29%e4%b8%8e%e7%bb%93%e6%9e%84%e4%bd%93%28struct%29%e7%9a%84%e5%8c%ba%e5%88%ab&amp;summary=%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90C%2b%2b%e4%b8%ad%e7%b1%bb%28class%29%e4%b8%8e%e7%bb%93%e6%9e%84%e4%bd%93%28struct%29%e7%9a%84%e5%8c%ba%e5%88%ab&amp;source=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp-class-vs-struct%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 全面解析C++中类(class)与结构体(struct)的区别 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp-class-vs-struct%2f&title=%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90C%2b%2b%e4%b8%ad%e7%b1%bb%28class%29%e4%b8%8e%e7%bb%93%e6%9e%84%e4%bd%93%28struct%29%e7%9a%84%e5%8c%ba%e5%88%ab"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 全面解析C++中类(class)与结构体(struct)的区别 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp-class-vs-struct%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 全面解析C++中类(class)与结构体(struct)的区别 on whatsapp" href="https://api.whatsapp.com/send?text=%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90C%2b%2b%e4%b8%ad%e7%b1%bb%28class%29%e4%b8%8e%e7%bb%93%e6%9e%84%e4%bd%93%28struct%29%e7%9a%84%e5%8c%ba%e5%88%ab%20-%20https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp-class-vs-struct%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 全面解析C++中类(class)与结构体(struct)的区别 on telegram" href="https://telegram.me/share/url?text=%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90C%2b%2b%e4%b8%ad%e7%b1%bb%28class%29%e4%b8%8e%e7%bb%93%e6%9e%84%e4%bd%93%28struct%29%e7%9a%84%e5%8c%ba%e5%88%ab&amp;url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp-class-vs-struct%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 全面解析C++中类(class)与结构体(struct)的区别 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90C%2b%2b%e4%b8%ad%e7%b1%bb%28class%29%e4%b8%8e%e7%bb%93%e6%9e%84%e4%bd%93%28struct%29%e7%9a%84%e5%8c%ba%e5%88%ab&u=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fcpp-class-vs-struct%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://xuyafei.github.io/personal-site/>我的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>