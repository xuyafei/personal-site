<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>音频丢包恢复机制详解：PLC与FEC技术 | 我的博客</title>
<meta name=keywords content="音频处理,实时通信,网络传输,PLC,FEC,Opus"><meta name=description content="深入解析音频传输中的丢包恢复技术，包括Packet Loss Concealment (PLC)和Forward Error Correction (FEC)的原理、实现和应用"><meta name=author content="徐亚飞"><link rel=canonical href=https://xuyafei.github.io/personal-site/posts/audio_loss_recovery/><link crossorigin=anonymous href=/personal-site/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://xuyafei.github.io/personal-site/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xuyafei.github.io/personal-site/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://xuyafei.github.io/personal-site/favicon-32x32.png><link rel=apple-touch-icon href=https://xuyafei.github.io/personal-site/apple-touch-icon.png><link rel=mask-icon href=https://xuyafei.github.io/personal-site/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://xuyafei.github.io/personal-site/posts/audio_loss_recovery/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAYQHy+K8nqKdr1EzvFzSQC+TAXx6gNQgoRxKtj+P9vvCCQTRWiV crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})})</script><script>MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta property="og:url" content="https://xuyafei.github.io/personal-site/posts/audio_loss_recovery/"><meta property="og:site_name" content="我的博客"><meta property="og:title" content="音频丢包恢复机制详解：PLC与FEC技术"><meta property="og:description" content="深入解析音频传输中的丢包恢复技术，包括Packet Loss Concealment (PLC)和Forward Error Correction (FEC)的原理、实现和应用"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-22T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-22T00:00:00+00:00"><meta property="article:tag" content="音频处理"><meta property="article:tag" content="实时通信"><meta property="article:tag" content="网络传输"><meta property="article:tag" content="PLC"><meta property="article:tag" content="FEC"><meta property="article:tag" content="Opus"><meta name=twitter:card content="summary"><meta name=twitter:title content="音频丢包恢复机制详解：PLC与FEC技术"><meta name=twitter:description content="深入解析音频传输中的丢包恢复技术，包括Packet Loss Concealment (PLC)和Forward Error Correction (FEC)的原理、实现和应用"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://xuyafei.github.io/personal-site/posts/"},{"@type":"ListItem","position":2,"name":"音频丢包恢复机制详解：PLC与FEC技术","item":"https://xuyafei.github.io/personal-site/posts/audio_loss_recovery/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"音频丢包恢复机制详解：PLC与FEC技术","name":"音频丢包恢复机制详解：PLC与FEC技术","description":"深入解析音频传输中的丢包恢复技术，包括Packet Loss Concealment (PLC)和Forward Error Correction (FEC)的原理、实现和应用","keywords":["音频处理","实时通信","网络传输","PLC","FEC","Opus"],"articleBody":"音频丢包恢复机制详解：PLC与FEC技术 一、概述 在实时音频传输中，网络丢包是常见问题。为了提供流畅的音频体验，业界开发了多种丢包恢复机制，其中PLC（Packet Loss Concealment）和FEC（Forward Error Correction）是最重要的两种技术。本文将深入解析这两种技术的原理、实现和应用。\n二、Packet Loss Concealment (PLC) 1. 核心目的 当某一帧音频数据丢失时，无需重传或额外带宽，用已有信息在接收端\"伪造\"出一帧音频，尽量减少听觉冲击，保持声音的连续性和自然感。\n2. 实现原理 2.1 时间域复制（简单策略） 方法：将上一帧音频直接拷贝作为当前帧输出 优点：实现简单、快速 缺点：只适合语音持续不变的段落，不适用于突变声音（如爆破、音乐） 2.2 线性预测 + 谱包络合成（复杂策略） 使用历史帧的语音参数（LPC、pitch周期）估计当前音频特性 预测当前帧的激励信号（residual） 用线性预测编码器（LPC）合成语音波形 适用于Opus、G.729等编码器 效果好很多，尤其对语音频率变化有较好适应能力 3. Opus中的PLC实现 3.1 工作流程 每帧编码时保存编码前的状态（LPC、谱参数等） 丢包后： 单帧丢失：自动触发PLC 使用预测+周期分析合成语音 输出一帧近似真实的音频 3.2 局限性 情况 PLC效果 单帧丢失（20ms以内） 几乎无感知 连续两帧丢失（40ms） 能容忍，但会模糊变形 连续三帧以上（\u003e60ms） 明显失真、机械音 语速突变/背景变化剧烈 无法预测，噪声增加 4. 应用场景 WebRTC语音通信（内建支持） VoIP电话系统（如SIP） 音视频会议（搭配FEC一起用） 实时对讲、语音助手 三、Forward Error Correction (FEC) 1. 核心目的 在发送端加入多余冗余信息，即使一部分原始数据丢失，也能从剩下的数据中还原完整帧，从而无需重传即可实现丢包恢复。\n2. 实现原理 2.1 基本机制 以异或校验为例：\n发送三帧音频数据：A、B、C 添加校验帧：D = A ⊕ B ⊕ C 如果B丢失，可通过D ⊕ A ⊕ C = B恢复 2.2 常用编码技术 Reed-Solomon（RS）编码 Convolutional Coding XOR-based ULPFEC（RTP层） Opus In-band FEC（音频层） 3. Opus In-band FEC 3.1 工作原理 第N帧中附带了第N-1帧的冗余 如果第N-1帧丢失，但第N帧到达，可用其恢复上一帧 延迟增加10ms，但完全不需要重传 3.2 使用条件 码率必须高于阈值（\u003e16kbps）\n原因：需要额外空间存储冗余数据 建议：设置≥20kbps较安全 网络抖动缓冲区（jitter buffer）≥30ms\n原因：需要等待下一帧到达 计算：RTP延迟(5-20ms) + FEC等待(20ms) ≥ 30ms 3.3 局限性 项目 FEC特点 延迟 增加延迟（最少10~20ms） 带宽 增加码流（10~25%） 连续丢包 不能恢复多个连续丢失 编解码器支持 仅支持SILK模式 4. 应用场景 场景 说明 WebRTC音频通话 默认启用Opus FEC，保护常见的单帧丢包 嵌入式对讲系统 为避免重传带来的延迟，用FEC提高鲁棒性 音频直播推流 延迟不能容忍，必须一次传输成功 四、PLC与FEC对比 特性 PLC FEC 是否增加带宽 ❌ 否 ✅ 是（10~30%） 是否增加延迟 ❌ 否 ✅ 是（10~20ms） 连续丢包处理能力 ❌ 差 ❌ 差（只能恢复1帧） 实现复杂度 ✅ 低 ⚠️ 中（需编码器支持） 实际表现 ✅ 平滑过渡，避免爆音 ✅ 恢复原始数据，音质更高 组合使用推荐 ✔️ 常与FEC一起用 ✔️ 与PLC/DTX结合更有效 五、自适应策略 1. 基于丢包率的策略选择 丢包率 推荐策略 \u003c 5% 正常Opus + PLC 5%-20% Opus + FEC（单帧恢复） 20%-30% 增加jitter buffer + FEC \u003e30% 启用自定义冗余包策略 2. 自定义冗余包策略 多帧冗余封装（Super Frame） 跨帧交叉冗余 主动请求重传（低延迟局域网） 3. 实现建议 冗余数据比例控制 自适应控制：根据丢包率动态调整 增量编码或压缩简化版本 客户端模式自动切换 六、Opus FEC实现细节 1. 编码器配置 #include int sample_rate = 48000; int channels = 1; int application = OPUS_APPLICATION_VOIP; int error; OpusEncoder *encoder = opus_encoder_create(sample_rate, channels, application, \u0026error); if (error != OPUS_OK) { fprintf(stderr, \"Failed to create encoder: %s\\n\", opus_strerror(error)); } // 启用 in-band FEC opus_encoder_ctl(encoder, OPUS_SET_INBAND_FEC(1)); // 设置 packet 最小持续时间（推荐至少10ms以支持FEC） opus_encoder_ctl(encoder, OPUS_SET_PACKET_LOSS_PERC(10)); // 预期丢包率 % 2. 动态FEC控制 // 伪代码：接收到 RTCP feedback 后统计丢包率 int fraction_lost = get_fraction_lost_from_rtcp(); // 例如：值为26表示大约10% if (fraction_lost \u003e= 13) { // 超过 ~5% 丢包率 opus_encoder_ctl(encoder, OPUS_SET_INBAND_FEC(1)); opus_encoder_ctl(encoder, OPUS_SET_PACKET_LOSS_PERC(fraction_lost * 100 / 256)); printf(\"FEC enabled: loss rate %d%%\\n\", fraction_lost * 100 / 256); } else { opus_encoder_ctl(encoder, OPUS_SET_INBAND_FEC(0)); opus_encoder_ctl(encoder, OPUS_SET_PACKET_LOSS_PERC(0)); printf(\"FEC disabled: loss rate low\\n\"); } 3. 解码器处理流程 for each received RTP packet: if packet contains FEC data: store FEC for use if needed if previous packet was lost: if current packet has FEC of previous: recover previous frame using FEC else: use PLC (packet loss concealment) decode current packet normally 七、高级优化策略 1. 自适应冗余包策略 float loss_rate = 0.0; int loss_thresholds[] = {5, 15, 30}; // percent int redundancy_level = 0; void update_loss_rate(int lost, int total) { loss_rate = (float)lost / total * 100.0; if (loss_rate \u003c loss_thresholds[0]) { redundancy_level = 0; } else if (loss_rate \u003c loss_thresholds[1]) { redundancy_level = 1; } else if (loss_rate \u003c loss_thresholds[2]) { redundancy_level = 2; } else { redundancy_level = 3; } } 2. 冗余编码实现 struct Packet { uint8_t frame_data[MAX_LEN]; uint8_t redundancy_data[MAX_LEN]; // optional }; Packet encode_packet(Frame current, Frame prev1, Frame prev2, int level) { Packet pkt; encode_opus(current, pkt.frame_data); switch (level) { case 1: encode_opus(prev1, pkt.redundancy_data); break; case 2: merge_frames(prev1, prev2, pkt.redundancy_data); // e.g., concat break; case 3: xor_frames(current, prev1, prev2, pkt.redundancy_data); break; default: pkt.redundancy_data[0] = '\\0'; break; } return pkt; } 八、总结 PLC和FEC是音频丢包恢复的两种核心技术，各有特点：\nPLC适合处理单帧丢失，实现简单，不增加带宽 FEC能恢复原始数据，但需要额外带宽和延迟 实际应用中常组合使用，并根据网络状况动态调整 关键建议 低丢包率（\u003c5%）场景：\n使用PLC即可 无需开启FEC，避免额外开销 中等丢包率（5-20%）场景：\n启用Opus FEC 配合适当的jitter buffer 高丢包率（\u003e20%）场景：\n考虑自定义冗余策略 可能需要牺牲部分音质换取连续性 实现注意事项：\n合理设置码率（≥20kbps） 确保jitter buffer足够（≥30ms） 动态调整冗余级别 监控网络状况及时响应 九、Opus FEC的局限性 1. 模式限制 仅适用于SILK模式（通常用于\u003c8kHz或\u003c12kHz语音通话） CELT模式（用于高采样率、音乐）不支持FEC 在高采样率（如48kHz）时，Opus会自动切换到CELT模式，此时FEC无效 2. 恢复能力限制 每个数据包最多只能携带\"上一个帧\"的简化版本 只能修复最多一帧的丢包 丢两帧或以上就无法修复 示例：[Pkt1: 帧1] -\u003e [Pkt2: 帧2 + 帧1简版] -\u003e [Pkt3: 帧3 + 帧2简版] 如果丢掉Pkt2，可以从Pkt3里恢复帧2 但如果连续丢掉Pkt2和Pkt3，帧2和帧3都丢了，彻底无法恢复 3. 延迟要求 需要jitter buffer多等一帧 增加延迟（大约20ms） 实时性要求高的场景（如对讲、低延迟直播）可能无法承受 4. 高丢包场景效果 恢复的是\"简化版本\"，语音质量可能变差 在丢包率\u003e20%-30%时： FEC只能挽救少量帧 主要依赖PLC猜测波形，失真严重 需要更强的策略支持 十、自定义冗余包策略 1. 多帧冗余封装（Super Frame） 每个数据包中不仅携带当前帧，还嵌入前几帧的冗余版本 类似UDP+冗余编码机制 可以抵御连续丢包 2. 跨帧交叉冗余 每3个包构成一个冗余组 第3个包中混合前两个包的信息（Reed-Solomon、XOR等） 丢其中一个仍可恢复 3. 主动请求重传 适用于低延迟局域网 丢包探测后请求补包 公网场景较少使用（除非延迟极小） 4. 自适应策略实现 // 冗余包示意图（帧内冗余）： // Pkt1: [Frame1] // Pkt2: [Frame2] + [Redundancy(Frame1)] // Pkt3: [Frame3] + [Redundancy(Frame2)] // Pkt4: [Frame4] + [Redundancy(Frame2 + Frame3)] struct Packet { uint8_t frame_data[MAX_LEN]; uint8_t redundancy_data[MAX_LEN]; // optional }; Packet encode_packet(Frame current, Frame prev1, Frame prev2, int level) { Packet pkt; encode_opus(current, pkt.frame_data); switch (level) { case 1: encode_opus(prev1, pkt.redundancy_data); break; case 2: merge_frames(prev1, prev2, pkt.redundancy_data); break; case 3: xor_frames(current, prev1, prev2, pkt.redundancy_data); break; default: pkt.redundancy_data[0] = '\\0'; break; } return pkt; } 5. 优化建议 冗余帧压缩（使用更低码率，如6kbps） 带宽自适应（低带宽时牺牲冗余率） 延迟控制（不增加jitter buffer的基础上保守发冗余） 多路FEC组合：Opus FEC + 自定义冗余组合使用 十一、策略选择指南 1. 基于丢包率的策略选择 丢包率 推荐策略 说明 \u003c 5% 正常Opus + PLC PLC能很好填补短帧丢失，jitter buffer稳定 5%-20% Opus + FEC FEC成本低，单帧修复即可，语音体验维持 20%-30% 增大jitter buffer + FEC 开始出现连续丢包，需要放宽接收窗口 \u003e30% 自定义冗余包策略 连续帧丢失概率高，需要跨帧、多帧冗余 2. 注意事项 冗余数据比例控制（避免占用过多带宽） 自适应控制（根据丢包率动态调整冗余级别） 增量编码或压缩简化版本（减轻网络负担） 客户端模式自动切换（低延迟模式/抗丢包模式） 3. 策略对比 特性 Opus FEC 自定义冗余策略 恢复单帧 ✅ ✅ 恢复多帧连续丢包 ❌ ✅ 是否依赖下一帧 ✅ 看策略 支持所有模式 ❌ 仅SILK ✅ 可跨模式 是否增加延迟 ✅ 视设计而定 高丢包场景有效 ❌ ✅ 参考文献：\n“Opus Interactive Audio Codec” by Xiph.Org Foundation “Real-Time Communication with WebRTC” by Salvatore Loreto “Audio Signal Processing and Coding” by Andreas Spanias “Digital Speech Processing” by Sadaoki Furui “Speech Coding Algorithms” by Wai C. Chu “The WebRTC Book” by Alan B. Johnston “Network Performance Analysis” by Thomas Bonald “Multimedia Communications” by Fred Halsall “Streaming Media” by Geoff Huston “Internetworking with TCP/IP” by Douglas E. Comer ","wordCount":"778","inLanguage":"en","datePublished":"2024-04-22T00:00:00Z","dateModified":"2024-04-22T00:00:00Z","author":{"@type":"Person","name":"徐亚飞"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xuyafei.github.io/personal-site/posts/audio_loss_recovery/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://xuyafei.github.io/personal-site/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xuyafei.github.io/personal-site/ accesskey=h title="我的博客 (Alt + H)">我的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xuyafei.github.io/personal-site/categories/ title=分类><span>分类</span></a></li><li><a href=https://xuyafei.github.io/personal-site/tags/ title=标签><span>标签</span></a></li><li><a href=https://xuyafei.github.io/personal-site/archives/ title=归档><span>归档</span></a></li><li><a href=https://xuyafei.github.io/personal-site/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xuyafei.github.io/personal-site/>Home</a>&nbsp;»&nbsp;<a href=https://xuyafei.github.io/personal-site/posts/>文章</a></div><h1 class="post-title entry-hint-parent">音频丢包恢复机制详解：PLC与FEC技术</h1><div class=post-description>深入解析音频传输中的丢包恢复技术，包括Packet Loss Concealment (PLC)和Forward Error Correction (FEC)的原理、实现和应用</div><div class=post-meta><span title='2024-04-22 00:00:00 +0000 UTC'>April 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;徐亚飞</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e9%9f%b3%e9%a2%91%e4%b8%a2%e5%8c%85%e6%81%a2%e5%a4%8d%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3plc%e4%b8%8efec%e6%8a%80%e6%9c%af aria-label=音频丢包恢复机制详解：PLC与FEC技术>音频丢包恢复机制详解：PLC与FEC技术</a><ul><li><a href=#%e4%b8%80%e6%a6%82%e8%bf%b0 aria-label=一、概述>一、概述</a></li><li><a href=#%e4%ba%8cpacket-loss-concealment-plc aria-label="二、Packet Loss Concealment (PLC)">二、Packet Loss Concealment (PLC)</a><ul><li><a href=#1-%e6%a0%b8%e5%bf%83%e7%9b%ae%e7%9a%84 aria-label="1. 核心目的">1. 核心目的</a></li><li><a href=#2-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86 aria-label="2. 实现原理">2. 实现原理</a><ul><li><a href=#21-%e6%97%b6%e9%97%b4%e5%9f%9f%e5%a4%8d%e5%88%b6%e7%ae%80%e5%8d%95%e7%ad%96%e7%95%a5 aria-label="2.1 时间域复制（简单策略）">2.1 时间域复制（简单策略）</a></li><li><a href=#22-%e7%ba%bf%e6%80%a7%e9%a2%84%e6%b5%8b--%e8%b0%b1%e5%8c%85%e7%bb%9c%e5%90%88%e6%88%90%e5%a4%8d%e6%9d%82%e7%ad%96%e7%95%a5 aria-label="2.2 线性预测 + 谱包络合成（复杂策略）">2.2 线性预测 + 谱包络合成（复杂策略）</a></li></ul></li><li><a href=#3-opus%e4%b8%ad%e7%9a%84plc%e5%ae%9e%e7%8e%b0 aria-label="3. Opus中的PLC实现">3. Opus中的PLC实现</a><ul><li><a href=#31-%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b aria-label="3.1 工作流程">3.1 工作流程</a></li><li><a href=#32-%e5%b1%80%e9%99%90%e6%80%a7 aria-label="3.2 局限性">3.2 局限性</a></li></ul></li><li><a href=#4-%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af aria-label="4. 应用场景">4. 应用场景</a></li></ul></li><li><a href=#%e4%b8%89forward-error-correction-fec aria-label="三、Forward Error Correction (FEC)">三、Forward Error Correction (FEC)</a><ul><li><a href=#1-%e6%a0%b8%e5%bf%83%e7%9b%ae%e7%9a%84-1 aria-label="1. 核心目的">1. 核心目的</a></li><li><a href=#2-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86-1 aria-label="2. 实现原理">2. 实现原理</a><ul><li><a href=#21-%e5%9f%ba%e6%9c%ac%e6%9c%ba%e5%88%b6 aria-label="2.1 基本机制">2.1 基本机制</a></li><li><a href=#22-%e5%b8%b8%e7%94%a8%e7%bc%96%e7%a0%81%e6%8a%80%e6%9c%af aria-label="2.2 常用编码技术">2.2 常用编码技术</a></li></ul></li><li><a href=#3-opus-in-band-fec aria-label="3. Opus In-band FEC">3. Opus In-band FEC</a><ul><li><a href=#31-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86 aria-label="3.1 工作原理">3.1 工作原理</a></li><li><a href=#32-%e4%bd%bf%e7%94%a8%e6%9d%a1%e4%bb%b6 aria-label="3.2 使用条件">3.2 使用条件</a></li><li><a href=#33-%e5%b1%80%e9%99%90%e6%80%a7 aria-label="3.3 局限性">3.3 局限性</a></li></ul></li><li><a href=#4-%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-1 aria-label="4. 应用场景">4. 应用场景</a></li></ul></li><li><a href=#%e5%9b%9bplc%e4%b8%8efec%e5%af%b9%e6%af%94 aria-label=四、PLC与FEC对比>四、PLC与FEC对比</a></li><li><a href=#%e4%ba%94%e8%87%aa%e9%80%82%e5%ba%94%e7%ad%96%e7%95%a5 aria-label=五、自适应策略>五、自适应策略</a><ul><li><a href=#1-%e5%9f%ba%e4%ba%8e%e4%b8%a2%e5%8c%85%e7%8e%87%e7%9a%84%e7%ad%96%e7%95%a5%e9%80%89%e6%8b%a9 aria-label="1. 基于丢包率的策略选择">1. 基于丢包率的策略选择</a></li><li><a href=#2-%e8%87%aa%e5%ae%9a%e4%b9%89%e5%86%97%e4%bd%99%e5%8c%85%e7%ad%96%e7%95%a5 aria-label="2. 自定义冗余包策略">2. 自定义冗余包策略</a></li><li><a href=#3-%e5%ae%9e%e7%8e%b0%e5%bb%ba%e8%ae%ae aria-label="3. 实现建议">3. 实现建议</a></li></ul></li><li><a href=#%e5%85%adopus-fec%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82 aria-label="六、Opus FEC实现细节">六、Opus FEC实现细节</a><ul><li><a href=#1-%e7%bc%96%e7%a0%81%e5%99%a8%e9%85%8d%e7%bd%ae aria-label="1. 编码器配置">1. 编码器配置</a></li><li><a href=#2-%e5%8a%a8%e6%80%81fec%e6%8e%a7%e5%88%b6 aria-label="2. 动态FEC控制">2. 动态FEC控制</a></li><li><a href=#3-%e8%a7%a3%e7%a0%81%e5%99%a8%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b aria-label="3. 解码器处理流程">3. 解码器处理流程</a></li></ul></li><li><a href=#%e4%b8%83%e9%ab%98%e7%ba%a7%e4%bc%98%e5%8c%96%e7%ad%96%e7%95%a5 aria-label=七、高级优化策略>七、高级优化策略</a><ul><li><a href=#1-%e8%87%aa%e9%80%82%e5%ba%94%e5%86%97%e4%bd%99%e5%8c%85%e7%ad%96%e7%95%a5 aria-label="1. 自适应冗余包策略">1. 自适应冗余包策略</a></li><li><a href=#2-%e5%86%97%e4%bd%99%e7%bc%96%e7%a0%81%e5%ae%9e%e7%8e%b0 aria-label="2. 冗余编码实现">2. 冗余编码实现</a></li></ul></li><li><a href=#%e5%85%ab%e6%80%bb%e7%bb%93 aria-label=八、总结>八、总结</a><ul><li><a href=#%e5%85%b3%e9%94%ae%e5%bb%ba%e8%ae%ae aria-label=关键建议>关键建议</a></li></ul></li><li><a href=#%e4%b9%9dopus-fec%e7%9a%84%e5%b1%80%e9%99%90%e6%80%a7 aria-label="九、Opus FEC的局限性">九、Opus FEC的局限性</a><ul><li><a href=#1-%e6%a8%a1%e5%bc%8f%e9%99%90%e5%88%b6 aria-label="1. 模式限制">1. 模式限制</a></li><li><a href=#2-%e6%81%a2%e5%a4%8d%e8%83%bd%e5%8a%9b%e9%99%90%e5%88%b6 aria-label="2. 恢复能力限制">2. 恢复能力限制</a></li><li><a href=#3-%e5%bb%b6%e8%bf%9f%e8%a6%81%e6%b1%82 aria-label="3. 延迟要求">3. 延迟要求</a></li><li><a href=#4-%e9%ab%98%e4%b8%a2%e5%8c%85%e5%9c%ba%e6%99%af%e6%95%88%e6%9e%9c aria-label="4. 高丢包场景效果">4. 高丢包场景效果</a></li></ul></li><li><a href=#%e5%8d%81%e8%87%aa%e5%ae%9a%e4%b9%89%e5%86%97%e4%bd%99%e5%8c%85%e7%ad%96%e7%95%a5 aria-label=十、自定义冗余包策略>十、自定义冗余包策略</a><ul><li><a href=#1-%e5%a4%9a%e5%b8%a7%e5%86%97%e4%bd%99%e5%b0%81%e8%a3%85super-frame aria-label="1. 多帧冗余封装（Super Frame）">1. 多帧冗余封装（Super Frame）</a></li><li><a href=#2-%e8%b7%a8%e5%b8%a7%e4%ba%a4%e5%8f%89%e5%86%97%e4%bd%99 aria-label="2. 跨帧交叉冗余">2. 跨帧交叉冗余</a></li><li><a href=#3-%e4%b8%bb%e5%8a%a8%e8%af%b7%e6%b1%82%e9%87%8d%e4%bc%a0 aria-label="3. 主动请求重传">3. 主动请求重传</a></li><li><a href=#4-%e8%87%aa%e9%80%82%e5%ba%94%e7%ad%96%e7%95%a5%e5%ae%9e%e7%8e%b0 aria-label="4. 自适应策略实现">4. 自适应策略实现</a></li><li><a href=#5-%e4%bc%98%e5%8c%96%e5%bb%ba%e8%ae%ae aria-label="5. 优化建议">5. 优化建议</a></li></ul></li><li><a href=#%e5%8d%81%e4%b8%80%e7%ad%96%e7%95%a5%e9%80%89%e6%8b%a9%e6%8c%87%e5%8d%97 aria-label=十一、策略选择指南>十一、策略选择指南</a><ul><li><a href=#1-%e5%9f%ba%e4%ba%8e%e4%b8%a2%e5%8c%85%e7%8e%87%e7%9a%84%e7%ad%96%e7%95%a5%e9%80%89%e6%8b%a9-1 aria-label="1. 基于丢包率的策略选择">1. 基于丢包率的策略选择</a></li><li><a href=#2-%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9 aria-label="2. 注意事项">2. 注意事项</a></li><li><a href=#3-%e7%ad%96%e7%95%a5%e5%af%b9%e6%af%94 aria-label="3. 策略对比">3. 策略对比</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=音频丢包恢复机制详解plc与fec技术>音频丢包恢复机制详解：PLC与FEC技术<a hidden class=anchor aria-hidden=true href=#音频丢包恢复机制详解plc与fec技术>#</a></h1><h2 id=一概述>一、概述<a hidden class=anchor aria-hidden=true href=#一概述>#</a></h2><p>在实时音频传输中，网络丢包是常见问题。为了提供流畅的音频体验，业界开发了多种丢包恢复机制，其中PLC（Packet Loss Concealment）和FEC（Forward Error Correction）是最重要的两种技术。本文将深入解析这两种技术的原理、实现和应用。</p><h2 id=二packet-loss-concealment-plc>二、Packet Loss Concealment (PLC)<a hidden class=anchor aria-hidden=true href=#二packet-loss-concealment-plc>#</a></h2><h3 id=1-核心目的>1. 核心目的<a hidden class=anchor aria-hidden=true href=#1-核心目的>#</a></h3><p>当某一帧音频数据丢失时，无需重传或额外带宽，用已有信息在接收端"伪造"出一帧音频，尽量减少听觉冲击，保持声音的连续性和自然感。</p><h3 id=2-实现原理>2. 实现原理<a hidden class=anchor aria-hidden=true href=#2-实现原理>#</a></h3><h4 id=21-时间域复制简单策略>2.1 时间域复制（简单策略）<a hidden class=anchor aria-hidden=true href=#21-时间域复制简单策略>#</a></h4><ul><li>方法：将上一帧音频直接拷贝作为当前帧输出</li><li>优点：实现简单、快速</li><li>缺点：只适合语音持续不变的段落，不适用于突变声音（如爆破、音乐）</li></ul><h4 id=22-线性预测--谱包络合成复杂策略>2.2 线性预测 + 谱包络合成（复杂策略）<a hidden class=anchor aria-hidden=true href=#22-线性预测--谱包络合成复杂策略>#</a></h4><ul><li>使用历史帧的语音参数（LPC、pitch周期）估计当前音频特性</li><li>预测当前帧的激励信号（residual）</li><li>用线性预测编码器（LPC）合成语音波形</li><li>适用于Opus、G.729等编码器</li><li>效果好很多，尤其对语音频率变化有较好适应能力</li></ul><h3 id=3-opus中的plc实现>3. Opus中的PLC实现<a hidden class=anchor aria-hidden=true href=#3-opus中的plc实现>#</a></h3><h4 id=31-工作流程>3.1 工作流程<a hidden class=anchor aria-hidden=true href=#31-工作流程>#</a></h4><ol><li>每帧编码时保存编码前的状态（LPC、谱参数等）</li><li>丢包后：<ul><li>单帧丢失：自动触发PLC</li><li>使用预测+周期分析合成语音</li></ul></li><li>输出一帧近似真实的音频</li></ol><h4 id=32-局限性>3.2 局限性<a hidden class=anchor aria-hidden=true href=#32-局限性>#</a></h4><table><thead><tr><th>情况</th><th>PLC效果</th></tr></thead><tbody><tr><td>单帧丢失（20ms以内）</td><td>几乎无感知</td></tr><tr><td>连续两帧丢失（40ms）</td><td>能容忍，但会模糊变形</td></tr><tr><td>连续三帧以上（>60ms）</td><td>明显失真、机械音</td></tr><tr><td>语速突变/背景变化剧烈</td><td>无法预测，噪声增加</td></tr></tbody></table><h3 id=4-应用场景>4. 应用场景<a hidden class=anchor aria-hidden=true href=#4-应用场景>#</a></h3><ul><li>WebRTC语音通信（内建支持）</li><li>VoIP电话系统（如SIP）</li><li>音视频会议（搭配FEC一起用）</li><li>实时对讲、语音助手</li></ul><h2 id=三forward-error-correction-fec>三、Forward Error Correction (FEC)<a hidden class=anchor aria-hidden=true href=#三forward-error-correction-fec>#</a></h2><h3 id=1-核心目的-1>1. 核心目的<a hidden class=anchor aria-hidden=true href=#1-核心目的-1>#</a></h3><p>在发送端加入多余冗余信息，即使一部分原始数据丢失，也能从剩下的数据中还原完整帧，从而无需重传即可实现丢包恢复。</p><h3 id=2-实现原理-1>2. 实现原理<a hidden class=anchor aria-hidden=true href=#2-实现原理-1>#</a></h3><h4 id=21-基本机制>2.1 基本机制<a hidden class=anchor aria-hidden=true href=#21-基本机制>#</a></h4><p>以异或校验为例：</p><ul><li>发送三帧音频数据：A、B、C</li><li>添加校验帧：D = A ⊕ B ⊕ C</li><li>如果B丢失，可通过D ⊕ A ⊕ C = B恢复</li></ul><h4 id=22-常用编码技术>2.2 常用编码技术<a hidden class=anchor aria-hidden=true href=#22-常用编码技术>#</a></h4><ul><li>Reed-Solomon（RS）编码</li><li>Convolutional Coding</li><li>XOR-based ULPFEC（RTP层）</li><li>Opus In-band FEC（音频层）</li></ul><h3 id=3-opus-in-band-fec>3. Opus In-band FEC<a hidden class=anchor aria-hidden=true href=#3-opus-in-band-fec>#</a></h3><h4 id=31-工作原理>3.1 工作原理<a hidden class=anchor aria-hidden=true href=#31-工作原理>#</a></h4><ul><li>第N帧中附带了第N-1帧的冗余</li><li>如果第N-1帧丢失，但第N帧到达，可用其恢复上一帧</li><li>延迟增加10ms，但完全不需要重传</li></ul><h4 id=32-使用条件>3.2 使用条件<a hidden class=anchor aria-hidden=true href=#32-使用条件>#</a></h4><ol><li><p>码率必须高于阈值（>16kbps）</p><ul><li>原因：需要额外空间存储冗余数据</li><li>建议：设置≥20kbps较安全</li></ul></li><li><p>网络抖动缓冲区（jitter buffer）≥30ms</p><ul><li>原因：需要等待下一帧到达</li><li>计算：RTP延迟(5-20ms) + FEC等待(20ms) ≥ 30ms</li></ul></li></ol><h4 id=33-局限性>3.3 局限性<a hidden class=anchor aria-hidden=true href=#33-局限性>#</a></h4><table><thead><tr><th>项目</th><th>FEC特点</th></tr></thead><tbody><tr><td>延迟</td><td>增加延迟（最少10~20ms）</td></tr><tr><td>带宽</td><td>增加码流（10~25%）</td></tr><tr><td>连续丢包</td><td>不能恢复多个连续丢失</td></tr><tr><td>编解码器支持</td><td>仅支持SILK模式</td></tr></tbody></table><h3 id=4-应用场景-1>4. 应用场景<a hidden class=anchor aria-hidden=true href=#4-应用场景-1>#</a></h3><table><thead><tr><th>场景</th><th>说明</th></tr></thead><tbody><tr><td>WebRTC音频通话</td><td>默认启用Opus FEC，保护常见的单帧丢包</td></tr><tr><td>嵌入式对讲系统</td><td>为避免重传带来的延迟，用FEC提高鲁棒性</td></tr><tr><td>音频直播推流</td><td>延迟不能容忍，必须一次传输成功</td></tr></tbody></table><h2 id=四plc与fec对比>四、PLC与FEC对比<a hidden class=anchor aria-hidden=true href=#四plc与fec对比>#</a></h2><table><thead><tr><th>特性</th><th>PLC</th><th>FEC</th></tr></thead><tbody><tr><td>是否增加带宽</td><td>❌ 否</td><td>✅ 是（10~30%）</td></tr><tr><td>是否增加延迟</td><td>❌ 否</td><td>✅ 是（10~20ms）</td></tr><tr><td>连续丢包处理能力</td><td>❌ 差</td><td>❌ 差（只能恢复1帧）</td></tr><tr><td>实现复杂度</td><td>✅ 低</td><td>⚠️ 中（需编码器支持）</td></tr><tr><td>实际表现</td><td>✅ 平滑过渡，避免爆音</td><td>✅ 恢复原始数据，音质更高</td></tr><tr><td>组合使用推荐</td><td>✔️ 常与FEC一起用</td><td>✔️ 与PLC/DTX结合更有效</td></tr></tbody></table><h2 id=五自适应策略>五、自适应策略<a hidden class=anchor aria-hidden=true href=#五自适应策略>#</a></h2><h3 id=1-基于丢包率的策略选择>1. 基于丢包率的策略选择<a hidden class=anchor aria-hidden=true href=#1-基于丢包率的策略选择>#</a></h3><table><thead><tr><th>丢包率</th><th>推荐策略</th></tr></thead><tbody><tr><td>&lt; 5%</td><td>正常Opus + PLC</td></tr><tr><td>5%-20%</td><td>Opus + FEC（单帧恢复）</td></tr><tr><td>20%-30%</td><td>增加jitter buffer + FEC</td></tr><tr><td>>30%</td><td>启用自定义冗余包策略</td></tr></tbody></table><h3 id=2-自定义冗余包策略>2. 自定义冗余包策略<a hidden class=anchor aria-hidden=true href=#2-自定义冗余包策略>#</a></h3><ul><li>多帧冗余封装（Super Frame）</li><li>跨帧交叉冗余</li><li>主动请求重传（低延迟局域网）</li></ul><h3 id=3-实现建议>3. 实现建议<a hidden class=anchor aria-hidden=true href=#3-实现建议>#</a></h3><ul><li>冗余数据比例控制</li><li>自适应控制：根据丢包率动态调整</li><li>增量编码或压缩简化版本</li><li>客户端模式自动切换</li></ul><h2 id=六opus-fec实现细节>六、Opus FEC实现细节<a hidden class=anchor aria-hidden=true href=#六opus-fec实现细节>#</a></h2><h3 id=1-编码器配置>1. 编码器配置<a hidden class=anchor aria-hidden=true href=#1-编码器配置>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;opus/opus.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> sample_rate <span style=color:#f92672>=</span> <span style=color:#ae81ff>48000</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> channels <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> application <span style=color:#f92672>=</span> OPUS_APPLICATION_VOIP;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> error;
</span></span><span style=display:flex><span>OpusEncoder <span style=color:#f92672>*</span>encoder <span style=color:#f92672>=</span> <span style=color:#a6e22e>opus_encoder_create</span>(sample_rate, channels, application, <span style=color:#f92672>&amp;</span>error);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (error <span style=color:#f92672>!=</span> OPUS_OK) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Failed to create encoder: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>opus_strerror</span>(error));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 启用 in-band FEC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>opus_encoder_ctl</span>(encoder, <span style=color:#a6e22e>OPUS_SET_INBAND_FEC</span>(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 设置 packet 最小持续时间（推荐至少10ms以支持FEC）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>opus_encoder_ctl</span>(encoder, <span style=color:#a6e22e>OPUS_SET_PACKET_LOSS_PERC</span>(<span style=color:#ae81ff>10</span>));  <span style=color:#75715e>// 预期丢包率 %
</span></span></span></code></pre></div><h3 id=2-动态fec控制>2. 动态FEC控制<a hidden class=anchor aria-hidden=true href=#2-动态fec控制>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// 伪代码：接收到 RTCP feedback 后统计丢包率
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> fraction_lost <span style=color:#f92672>=</span> <span style=color:#a6e22e>get_fraction_lost_from_rtcp</span>();  <span style=color:#75715e>// 例如：值为26表示大约10%
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (fraction_lost <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>13</span>) {  <span style=color:#75715e>// 超过 ~5% 丢包率
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>opus_encoder_ctl</span>(encoder, <span style=color:#a6e22e>OPUS_SET_INBAND_FEC</span>(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>opus_encoder_ctl</span>(encoder, <span style=color:#a6e22e>OPUS_SET_PACKET_LOSS_PERC</span>(fraction_lost <span style=color:#f92672>*</span> <span style=color:#ae81ff>100</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>256</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;FEC enabled: loss rate %d%%</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, fraction_lost <span style=color:#f92672>*</span> <span style=color:#ae81ff>100</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>256</span>);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>opus_encoder_ctl</span>(encoder, <span style=color:#a6e22e>OPUS_SET_INBAND_FEC</span>(<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>opus_encoder_ctl</span>(encoder, <span style=color:#a6e22e>OPUS_SET_PACKET_LOSS_PERC</span>(<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;FEC disabled: loss rate low</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-解码器处理流程>3. 解码器处理流程<a hidden class=anchor aria-hidden=true href=#3-解码器处理流程>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>for</span> each received RTP packet:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> packet contains FEC data:
</span></span><span style=display:flex><span>        store FEC <span style=color:#66d9ef>for</span> use <span style=color:#66d9ef>if</span> needed
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> previous packet was lost:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> current packet has FEC of previous:
</span></span><span style=display:flex><span>            recover previous frame using FEC
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            use <span style=color:#a6e22e>PLC</span> (packet loss concealment)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    decode current packet normally
</span></span></code></pre></div><h2 id=七高级优化策略>七、高级优化策略<a hidden class=anchor aria-hidden=true href=#七高级优化策略>#</a></h2><h3 id=1-自适应冗余包策略>1. 自适应冗余包策略<a hidden class=anchor aria-hidden=true href=#1-自适应冗余包策略>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>float</span> loss_rate <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> loss_thresholds[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>15</span>, <span style=color:#ae81ff>30</span>};  <span style=color:#75715e>// percent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> redundancy_level <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update_loss_rate</span>(<span style=color:#66d9ef>int</span> lost, <span style=color:#66d9ef>int</span> total) {
</span></span><span style=display:flex><span>    loss_rate <span style=color:#f92672>=</span> (<span style=color:#66d9ef>float</span>)lost <span style=color:#f92672>/</span> total <span style=color:#f92672>*</span> <span style=color:#ae81ff>100.0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (loss_rate <span style=color:#f92672>&lt;</span> loss_thresholds[<span style=color:#ae81ff>0</span>]) {
</span></span><span style=display:flex><span>        redundancy_level <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (loss_rate <span style=color:#f92672>&lt;</span> loss_thresholds[<span style=color:#ae81ff>1</span>]) {
</span></span><span style=display:flex><span>        redundancy_level <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (loss_rate <span style=color:#f92672>&lt;</span> loss_thresholds[<span style=color:#ae81ff>2</span>]) {
</span></span><span style=display:flex><span>        redundancy_level <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        redundancy_level <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-冗余编码实现>2. 冗余编码实现<a hidden class=anchor aria-hidden=true href=#2-冗余编码实现>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> Packet {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> frame_data[MAX_LEN];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> redundancy_data[MAX_LEN];  <span style=color:#75715e>// optional
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Packet <span style=color:#a6e22e>encode_packet</span>(Frame current, Frame prev1, Frame prev2, <span style=color:#66d9ef>int</span> level) {
</span></span><span style=display:flex><span>    Packet pkt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>encode_opus</span>(current, pkt.frame_data);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (level) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>encode_opus</span>(prev1, pkt.redundancy_data);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>merge_frames</span>(prev1, prev2, pkt.redundancy_data); <span style=color:#75715e>// e.g., concat
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>xor_frames</span>(current, prev1, prev2, pkt.redundancy_data);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            pkt.redundancy_data[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pkt;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=八总结>八、总结<a hidden class=anchor aria-hidden=true href=#八总结>#</a></h2><p>PLC和FEC是音频丢包恢复的两种核心技术，各有特点：</p><ul><li>PLC适合处理单帧丢失，实现简单，不增加带宽</li><li>FEC能恢复原始数据，但需要额外带宽和延迟</li><li>实际应用中常组合使用，并根据网络状况动态调整</li></ul><h3 id=关键建议>关键建议<a hidden class=anchor aria-hidden=true href=#关键建议>#</a></h3><ol><li><p>低丢包率（&lt;5%）场景：</p><ul><li>使用PLC即可</li><li>无需开启FEC，避免额外开销</li></ul></li><li><p>中等丢包率（5-20%）场景：</p><ul><li>启用Opus FEC</li><li>配合适当的jitter buffer</li></ul></li><li><p>高丢包率（>20%）场景：</p><ul><li>考虑自定义冗余策略</li><li>可能需要牺牲部分音质换取连续性</li></ul></li><li><p>实现注意事项：</p><ul><li>合理设置码率（≥20kbps）</li><li>确保jitter buffer足够（≥30ms）</li><li>动态调整冗余级别</li><li>监控网络状况及时响应</li></ul></li></ol><h2 id=九opus-fec的局限性>九、Opus FEC的局限性<a hidden class=anchor aria-hidden=true href=#九opus-fec的局限性>#</a></h2><h3 id=1-模式限制>1. 模式限制<a hidden class=anchor aria-hidden=true href=#1-模式限制>#</a></h3><ul><li>仅适用于SILK模式（通常用于&lt;8kHz或&lt;12kHz语音通话）</li><li>CELT模式（用于高采样率、音乐）不支持FEC</li><li>在高采样率（如48kHz）时，Opus会自动切换到CELT模式，此时FEC无效</li></ul><h3 id=2-恢复能力限制>2. 恢复能力限制<a hidden class=anchor aria-hidden=true href=#2-恢复能力限制>#</a></h3><ul><li>每个数据包最多只能携带"上一个帧"的简化版本</li><li>只能修复最多一帧的丢包</li><li>丢两帧或以上就无法修复</li><li>示例：[Pkt1: 帧1] -> [Pkt2: 帧2 + 帧1简版] -> [Pkt3: 帧3 + 帧2简版]<ul><li>如果丢掉Pkt2，可以从Pkt3里恢复帧2</li><li>但如果连续丢掉Pkt2和Pkt3，帧2和帧3都丢了，彻底无法恢复</li></ul></li></ul><h3 id=3-延迟要求>3. 延迟要求<a hidden class=anchor aria-hidden=true href=#3-延迟要求>#</a></h3><ul><li>需要jitter buffer多等一帧</li><li>增加延迟（大约20ms）</li><li>实时性要求高的场景（如对讲、低延迟直播）可能无法承受</li></ul><h3 id=4-高丢包场景效果>4. 高丢包场景效果<a hidden class=anchor aria-hidden=true href=#4-高丢包场景效果>#</a></h3><ul><li>恢复的是"简化版本"，语音质量可能变差</li><li>在丢包率>20%-30%时：<ul><li>FEC只能挽救少量帧</li><li>主要依赖PLC猜测波形，失真严重</li><li>需要更强的策略支持</li></ul></li></ul><h2 id=十自定义冗余包策略>十、自定义冗余包策略<a hidden class=anchor aria-hidden=true href=#十自定义冗余包策略>#</a></h2><h3 id=1-多帧冗余封装super-frame>1. 多帧冗余封装（Super Frame）<a hidden class=anchor aria-hidden=true href=#1-多帧冗余封装super-frame>#</a></h3><ul><li>每个数据包中不仅携带当前帧，还嵌入前几帧的冗余版本</li><li>类似UDP+冗余编码机制</li><li>可以抵御连续丢包</li></ul><h3 id=2-跨帧交叉冗余>2. 跨帧交叉冗余<a hidden class=anchor aria-hidden=true href=#2-跨帧交叉冗余>#</a></h3><ul><li>每3个包构成一个冗余组</li><li>第3个包中混合前两个包的信息（Reed-Solomon、XOR等）</li><li>丢其中一个仍可恢复</li></ul><h3 id=3-主动请求重传>3. 主动请求重传<a hidden class=anchor aria-hidden=true href=#3-主动请求重传>#</a></h3><ul><li>适用于低延迟局域网</li><li>丢包探测后请求补包</li><li>公网场景较少使用（除非延迟极小）</li></ul><h3 id=4-自适应策略实现>4. 自适应策略实现<a hidden class=anchor aria-hidden=true href=#4-自适应策略实现>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// 冗余包示意图（帧内冗余）：
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Pkt1: [Frame1]
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Pkt2: [Frame2] + [Redundancy(Frame1)]
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Pkt3: [Frame3] + [Redundancy(Frame2)]
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Pkt4: [Frame4] + [Redundancy(Frame2 + Frame3)]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> Packet {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> frame_data[MAX_LEN];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> redundancy_data[MAX_LEN];  <span style=color:#75715e>// optional
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Packet <span style=color:#a6e22e>encode_packet</span>(Frame current, Frame prev1, Frame prev2, <span style=color:#66d9ef>int</span> level) {
</span></span><span style=display:flex><span>    Packet pkt;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>encode_opus</span>(current, pkt.frame_data);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (level) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>encode_opus</span>(prev1, pkt.redundancy_data);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>merge_frames</span>(prev1, prev2, pkt.redundancy_data);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>xor_frames</span>(current, prev1, prev2, pkt.redundancy_data);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            pkt.redundancy_data[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pkt;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=5-优化建议>5. 优化建议<a hidden class=anchor aria-hidden=true href=#5-优化建议>#</a></h3><ul><li>冗余帧压缩（使用更低码率，如6kbps）</li><li>带宽自适应（低带宽时牺牲冗余率）</li><li>延迟控制（不增加jitter buffer的基础上保守发冗余）</li><li>多路FEC组合：Opus FEC + 自定义冗余组合使用</li></ul><h2 id=十一策略选择指南>十一、策略选择指南<a hidden class=anchor aria-hidden=true href=#十一策略选择指南>#</a></h2><h3 id=1-基于丢包率的策略选择-1>1. 基于丢包率的策略选择<a hidden class=anchor aria-hidden=true href=#1-基于丢包率的策略选择-1>#</a></h3><table><thead><tr><th>丢包率</th><th>推荐策略</th><th>说明</th></tr></thead><tbody><tr><td>&lt; 5%</td><td>正常Opus + PLC</td><td>PLC能很好填补短帧丢失，jitter buffer稳定</td></tr><tr><td>5%-20%</td><td>Opus + FEC</td><td>FEC成本低，单帧修复即可，语音体验维持</td></tr><tr><td>20%-30%</td><td>增大jitter buffer + FEC</td><td>开始出现连续丢包，需要放宽接收窗口</td></tr><tr><td>>30%</td><td>自定义冗余包策略</td><td>连续帧丢失概率高，需要跨帧、多帧冗余</td></tr></tbody></table><h3 id=2-注意事项>2. 注意事项<a hidden class=anchor aria-hidden=true href=#2-注意事项>#</a></h3><ul><li>冗余数据比例控制（避免占用过多带宽）</li><li>自适应控制（根据丢包率动态调整冗余级别）</li><li>增量编码或压缩简化版本（减轻网络负担）</li><li>客户端模式自动切换（低延迟模式/抗丢包模式）</li></ul><h3 id=3-策略对比>3. 策略对比<a hidden class=anchor aria-hidden=true href=#3-策略对比>#</a></h3><table><thead><tr><th>特性</th><th>Opus FEC</th><th>自定义冗余策略</th></tr></thead><tbody><tr><td>恢复单帧</td><td>✅</td><td>✅</td></tr><tr><td>恢复多帧连续丢包</td><td>❌</td><td>✅</td></tr><tr><td>是否依赖下一帧</td><td>✅</td><td>看策略</td></tr><tr><td>支持所有模式</td><td>❌ 仅SILK</td><td>✅ 可跨模式</td></tr><tr><td>是否增加延迟</td><td>✅</td><td>视设计而定</td></tr><tr><td>高丢包场景有效</td><td>❌</td><td>✅</td></tr></tbody></table><hr><p><em>参考文献：</em></p><ol><li>&ldquo;Opus Interactive Audio Codec&rdquo; by Xiph.Org Foundation</li><li>&ldquo;Real-Time Communication with WebRTC&rdquo; by Salvatore Loreto</li><li>&ldquo;Audio Signal Processing and Coding&rdquo; by Andreas Spanias</li><li>&ldquo;Digital Speech Processing&rdquo; by Sadaoki Furui</li><li>&ldquo;Speech Coding Algorithms&rdquo; by Wai C. Chu</li><li>&ldquo;The WebRTC Book&rdquo; by Alan B. Johnston</li><li>&ldquo;Network Performance Analysis&rdquo; by Thomas Bonald</li><li>&ldquo;Multimedia Communications&rdquo; by Fred Halsall</li><li>&ldquo;Streaming Media&rdquo; by Geoff Huston</li><li>&ldquo;Internetworking with TCP/IP&rdquo; by Douglas E. Comer</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://xuyafei.github.io/personal-site/tags/%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86/>音频处理</a></li><li><a href=https://xuyafei.github.io/personal-site/tags/%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1/>实时通信</a></li><li><a href=https://xuyafei.github.io/personal-site/tags/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/>网络传输</a></li><li><a href=https://xuyafei.github.io/personal-site/tags/plc/>PLC</a></li><li><a href=https://xuyafei.github.io/personal-site/tags/fec/>FEC</a></li><li><a href=https://xuyafei.github.io/personal-site/tags/opus/>Opus</a></li></ul><nav class=paginav><a class=prev href=https://xuyafei.github.io/personal-site/posts/network_adaptation/><span class=title>« Prev</span><br><span>视频会议系统的网络自适应机制详解</span>
</a><a class=next href=https://xuyafei.github.io/personal-site/posts/video_loss_recovery/><span class=title>Next »</span><br><span>视频传输中的丢包恢复机制：NACK与FEC详解</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 音频丢包恢复机制详解：PLC与FEC技术 on x" href="https://x.com/intent/tweet/?text=%e9%9f%b3%e9%a2%91%e4%b8%a2%e5%8c%85%e6%81%a2%e5%a4%8d%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%ef%bc%9aPLC%e4%b8%8eFEC%e6%8a%80%e6%9c%af&amp;url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2faudio_loss_recovery%2f&amp;hashtags=%e9%9f%b3%e9%a2%91%e5%a4%84%e7%90%86%2c%e5%ae%9e%e6%97%b6%e9%80%9a%e4%bf%a1%2c%e7%bd%91%e7%bb%9c%e4%bc%a0%e8%be%93%2cPLC%2cFEC%2cOpus"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 音频丢包恢复机制详解：PLC与FEC技术 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2faudio_loss_recovery%2f&amp;title=%e9%9f%b3%e9%a2%91%e4%b8%a2%e5%8c%85%e6%81%a2%e5%a4%8d%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%ef%bc%9aPLC%e4%b8%8eFEC%e6%8a%80%e6%9c%af&amp;summary=%e9%9f%b3%e9%a2%91%e4%b8%a2%e5%8c%85%e6%81%a2%e5%a4%8d%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%ef%bc%9aPLC%e4%b8%8eFEC%e6%8a%80%e6%9c%af&amp;source=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2faudio_loss_recovery%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 音频丢包恢复机制详解：PLC与FEC技术 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2faudio_loss_recovery%2f&title=%e9%9f%b3%e9%a2%91%e4%b8%a2%e5%8c%85%e6%81%a2%e5%a4%8d%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%ef%bc%9aPLC%e4%b8%8eFEC%e6%8a%80%e6%9c%af"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 音频丢包恢复机制详解：PLC与FEC技术 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2faudio_loss_recovery%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 音频丢包恢复机制详解：PLC与FEC技术 on whatsapp" href="https://api.whatsapp.com/send?text=%e9%9f%b3%e9%a2%91%e4%b8%a2%e5%8c%85%e6%81%a2%e5%a4%8d%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%ef%bc%9aPLC%e4%b8%8eFEC%e6%8a%80%e6%9c%af%20-%20https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2faudio_loss_recovery%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 音频丢包恢复机制详解：PLC与FEC技术 on telegram" href="https://telegram.me/share/url?text=%e9%9f%b3%e9%a2%91%e4%b8%a2%e5%8c%85%e6%81%a2%e5%a4%8d%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%ef%bc%9aPLC%e4%b8%8eFEC%e6%8a%80%e6%9c%af&amp;url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2faudio_loss_recovery%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 音频丢包恢复机制详解：PLC与FEC技术 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e9%9f%b3%e9%a2%91%e4%b8%a2%e5%8c%85%e6%81%a2%e5%a4%8d%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3%ef%bc%9aPLC%e4%b8%8eFEC%e6%8a%80%e6%9c%af&u=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2faudio_loss_recovery%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://xuyafei.github.io/personal-site/>我的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>