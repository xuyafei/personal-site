<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>自适应滤波器与回声消除（AEC）原理详解 | 我的博客</title>
<meta name=keywords content="视频会议,语音处理,滤波器,Python"><meta name=description content="自适应滤波器与回声消除。"><meta name=author content="徐亚飞"><link rel=canonical href=https://xuyafei.github.io/personal-site/posts/adaptive_filter_aec/><link crossorigin=anonymous href=/personal-site/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://xuyafei.github.io/personal-site/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xuyafei.github.io/personal-site/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://xuyafei.github.io/personal-site/favicon-32x32.png><link rel=apple-touch-icon href=https://xuyafei.github.io/personal-site/apple-touch-icon.png><link rel=mask-icon href=https://xuyafei.github.io/personal-site/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://xuyafei.github.io/personal-site/posts/adaptive_filter_aec/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAYQHy+K8nqKdr1EzvFzSQC+TAXx6gNQgoRxKtj+P9vvCCQTRWiV crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})})</script><script>MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta property="og:url" content="https://xuyafei.github.io/personal-site/posts/adaptive_filter_aec/"><meta property="og:site_name" content="我的博客"><meta property="og:title" content="自适应滤波器与回声消除（AEC）原理详解"><meta property="og:description" content="自适应滤波器与回声消除。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-22T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-22T00:00:00+00:00"><meta property="article:tag" content="视频会议"><meta property="article:tag" content="语音处理"><meta property="article:tag" content="滤波器"><meta property="article:tag" content="Python"><meta name=twitter:card content="summary"><meta name=twitter:title content="自适应滤波器与回声消除（AEC）原理详解"><meta name=twitter:description content="自适应滤波器与回声消除。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://xuyafei.github.io/personal-site/posts/"},{"@type":"ListItem","position":2,"name":"自适应滤波器与回声消除（AEC）原理详解","item":"https://xuyafei.github.io/personal-site/posts/adaptive_filter_aec/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"自适应滤波器与回声消除（AEC）原理详解","name":"自适应滤波器与回声消除（AEC）原理详解","description":"自适应滤波器与回声消除。","keywords":["视频会议","语音处理","滤波器","Python"],"articleBody":"自适应滤波器与回声消除（AEC）原理详解 核心原理 自适应滤波器之所以能够用于回声消除（AEC），核心原因在于它可以动态估计并还原\"回声路径\"，然后将这一估计出的回声信号从麦克风输入中减去，从而实现回声的抑制甚至消除。\n原理简述 🧠 在回声消除系统中，自适应滤波器会根据扬声器输出（远端信号）来预测它在麦克风中会出现的形式（回声），然后从实际的麦克风输入中减去这个预测的信号。\n基本信号模型 📦 设：\nx(n)：远端信号（扬声器播放） d(n)：麦克风信号（含近端语音 + 回声） y(n)：自适应滤波器输出（回声的估计） e(n)：误差信号（d(n) - y(n)，理论上就是近端语音） 自适应滤波器目标是： $$ y(n) ≈ 回声分量 = x(n) * h(n) $$ 其中 h(n) 是回声路径（扬声器到麦克风的模拟传输特性，可能包含混响、设备响应等）。\n最终： $$ e(n) = d(n) - y(n) ≈ 近端语音 $$\n自适应滤波器工作机制 ⚙️ 使用如 LMS（Least Mean Square）或 NLMS 算法，通过最小化 e(n) 的能量来不断更新滤波器系数 当估计越来越准时，y(n) 趋近于回声，e(n) 就接近纯近端语音 为什么它能成功 🔍 因果建模：回声路径是因果的，即某时刻的扬声器输出 x(n) 会在未来若干毫秒后以回声的形式出现在麦克风中 线性建模有效：大多数设备在一定条件下，其声学路径可以较好地用线性模型（FIR 滤波器）表示 反馈优化：误差信号 e(n) 反馈用于更新滤波器参数，不断逼近真实的回声路径响应 挑战情况 🚫 双讲问题：远近端同时说话时，远端信号和近端语音混合后，误差信号不再纯粹代表回声误差，滤波器容易被误导 非线性失真：如设备中存在非线性放大、限幅等，使得简单线性滤波器难以完全建模 LMS 算法详解 LMS（Least Mean Squares，最小均方）算法是一种自适应滤波算法，它通过不断调整滤波器的系数，使得输出信号尽可能逼近目标信号（期望信号）。\nLMS 的核心思想 🧠 在每一帧音频数据处理时，LMS 算法执行以下步骤：\n获取参考信号 x(n)\n这是扬声器播放出去的音频（远端信号），作为\"回声来源\" 通过自适应滤波器预测回声 ŷ(n) $$ ŷ(n) = w(n)^T · x(n) $$\nw(n)：当前时刻的滤波器权重（即回声通道估计） x(n)：过去若干个远端信号组成的向量 计算误差信号 e(n) $$ e(n) = d(n) - ŷ(n) $$\nd(n)：麦克风采集到的信号（包含人声 + 回声） e(n)：我们希望最终听到的纯净人声信号 更新滤波器权重 $$ w(n+1) = w(n) + μ · e(n) · x(n) $$\nμ 是学习率（控制更新幅度，太大不稳定，太小收敛慢） 符号说明 📌 符号 含义 x(n) 当前及过去远端样本向量 w(n) 滤波器系数，模拟声道 ŷ(n) 估计回声 d(n) 麦克风采集的混合信号 e(n) 误差，即人声估计值 μ 步长（学习率） 收敛过程详解 🌀 回声消除不可能一开始就\"完美\"，必须依靠一个\"收敛\"的学习过程。这个过程本质上是一个迭代优化过程，自适应滤波器逐步\"学会\"回声通道的特性。\n1. 初始状态：一无所知 ✅ 刚开始时，滤波器权重 w(n) 是全 0 或随机初始化 滤波器无法估计出真实的回声，只能输出很差的 ŷ(n) 结果就是：减去的回声信号不准确，误差 e(n) 很大 2. 梯度反馈：误差驱动更新 ✅ LMS 核心公式： $$ w(n+1) = w(n) + μ · e(n) · x(n) $$ 根据当前的误差 e(n) 和远端信号 x(n)，来更新滤波器参数 w(n) 目标是：让下一次输出的回声预测 ŷ(n+1) 更接近真实回声 3. 持续训练：不断迭代靠近目标 ✅ 收敛条件要求：\n学习率 μ 不过大（否则震荡） 有足够\"丰富\"的远端语音输入 x(n) 没有强干扰 当这些条件满足时，误差 e(n) 会越来越小，权重 w(n) 趋于稳定。\n4. 收敛后的效果 ✅ 滤波器已经基本\"拟合\"出房间的回声通道 对于新到的远端音频信号，滤波器能准确预测出其回声 将其从麦克风信号中减掉后，剩下的主要就是人声 收敛依赖条件 🔁 条件 影响 举例 学习率 μ 控制收敛速度和稳定性 太大会震荡，太小会慢 远端信号丰富性 提供\"训练数据\" 远端语音内容越多越稳定越好 麦克风信号质量 保证误差信号有意义 加噪严重会影响误差计算 回声路径稳定 环境变化越小越容易收敛 移动手机、音量突变等会打断学习 数学推导与实例 🔢 💬 为什么这很奇妙？\n因为 AEC 像是\"机器在学习听觉模式\"： 它从完全不了解这个房间的回声结构，在无监督的情况下，通过每一帧误差，自己慢慢\"摸索\"出房间、麦克风、扬声器之间的关系，构建出一套自己的\"回声模型\" —— 这是一个高度自适应的行为，跟人类在听觉学习中很像。\n一步一步地从数学角度推导出 LMS 在回声消除中是如何工作的，包括：\n自适应滤波器结构 回声估计与误差计算 权重更新（带学习率） 简单数值示例演示\"收敛\"过程 🧠 一、基本模型结构\n假设我们使用一个长度为 N 的 FIR 滤波器来估计回声：\nx(n)：当前帧远端信号 x(n-1), x(n-2), …, x(n-N+1)：历史帧构成一个信号窗口 w(n)：滤波器权重（系数） 回声估计：\n$$ \\hat{y}(n) = \\sum_{i=0}^{N-1} w_i(n) \\cdot x(n-i) $$\n误差信号：\n$$ e(n) = d(n) - \\hat{y}(n) $$\n其中 d(n) 是近端麦克风采集的信号（人声 + 回声），e(n) 应该是近端人声。\n📘 二、LMS 更新公式\n为了让估计的回声更接近实际的回声，我们用误差信号 e(n) 来更新 w(n)：\n$$ w_i(n+1) = w_i(n) + μ \\cdot e(n) \\cdot x(n-i) $$\n其中：\nμ 是学习率，控制更新的速度（通常是 0.001 ~ 0.01 之间的小数） x(n-i) 是过去的远端信号样本 e(n) 是当前误差信号 🔢 三、简单数值演示\n假设我们用一个长度为 3 的滤波器（N=3）来估计回声。\n条件设定：\n初始权重 w = [0, 0, 0] 学习率 μ = 0.1 某一时刻远端信号 x(n), x(n-1), x(n-2) = [1.0, 0.5, -0.3] 近端麦克风采集到的信号（含回声）d(n) = 0.8 第一步：估计回声 ŷ(n)\n$$ \\hat{y}(n) = 0 \\cdot 1.0 + 0 \\cdot 0.5 + 0 \\cdot (-0.3) = 0 $$\n第二步：计算误差\n$$ e(n) = d(n) - \\hat{y}(n) = 0.8 - 0 = 0.8 $$\n第三步：更新权重\n$$ w_0(n+1) = 0 + 0.1 \\cdot 0.8 \\cdot 1.0 = 0.08 $$\n$$ w_1(n+1) = 0 + 0.1 \\cdot 0.8 \\cdot 0.5 = 0.04 $$\n$$ w_2(n+1) = 0 + 0.1 \\cdot 0.8 \\cdot (-0.3) = -0.024 $$\n所以新的权重是： $$ w(n+1) = [0.08, 0.04, -0.024] $$\n第二帧到来时\n只要继续新的远端样本、对应的近端采样信号，重复上面过程，就会不断更新权重。随着时间推移，权重会逐步逼近真实的房间回声路径系数。\n📈 收敛的数学视角\nLMS 是在最小化误差平方：E[e(n)^2] 它其实是在做随机梯度下降（SGD），寻找最优 w 使误差最小 收敛条件取决于： μ \u003c 1 / (3 × 输入信号功率) 输入信号需满足\"持久激励\"（丰富） 💡 关键数学过程解释：\n输入信号 x[n]： 这是远端播放的信号，即扬声器发出的声音。\n回声信号 d[n]： 由真实的回声路径 true_filter 卷积生成，并加入噪声。也就是说，d[n] 是麦克风采集的信号（不含近端人声），形如：\n$$ d[n] = \\sum_{i=0}^{L-1} h[i] \\cdot x[n-i] $$\n滤波器估计输出 ŷ[n]： $$ \\hat{y}[n] = \\sum_{i=0}^{L-1} w[i] \\cdot x[n-i] $$\n误差信号 e[n]： $$ e[n] = d[n] - \\hat{y}[n] $$\n这是我们要最小化的量。\nLMS 权重更新公式： $$ w_{i}[n+1] = w_{i}[n] + \\mu \\cdot e[n] \\cdot x[n-i] $$\nμ 是学习率，控制收敛速度与稳定性 x[n-i] 是当前输入信号的延迟版本 🧠 收敛的关键机制：\n起初权重是错误的，预测的 ŷ[n] 跟 d[n] 差距很大，误差 e[n] 很大； LMS 会根据误差的方向和大小，调整每个权重，使得输出更接近目标； 随着时间推移，误差逐步减小，权重趋近于真实回声路径，达到收敛； 如果 μ 太大可能不稳定，太小会收敛慢。 上图展示了 LMS 自适应滤波器的系数（蓝色曲线）如何逐步逼近真实的回声路径（黑色虚线），也就是滤波器\"收敛\"到一个能产生回声估计的理想状态。\n一、LMS 原理再总结一下：\nLMS（Least Mean Squares）通过以下方式更新滤波器系数 w：\n$$ w[n+1] = w[n] + \\mu \\cdot e[n] \\cdot x[n] $$\n其中：\nx[n]：输入信号（远端信号段） e[n] = d[n] - y[n]：误差信号，d[n] 为近端麦克风采集（含回声），y[n] 是滤波器对回声的估计 μ：学习率（越大收敛越快但易震荡，越小越稳定但慢） w[n]：滤波器系数，用于模拟真实的回声通道 这个过程就是不断微调滤波器参数，使得预测的回声 y[n] 更贴近真实回声，逐渐实现抵消。\n二、自适应滤波器结构图（经典结构）如下：\n+------------------+ +-------------+ Far-end | x[n] (扬声器信号) |-----\u003e| Adaptive | signal +------------------+ | Filter (w) |----+ +-------------+ | v Near-end +------------------+ +---------+ signal d[n] = 人声+回声 ----\u003e| 差分器 |--\u003e| e[n] | (误差) | d[n] - y[n] | +---------+ +------------------+ ✅ 一、自适应滤波器的基本结构（以 LMS 为例）\n自适应滤波器的结构包括以下几个部分：\n输入信号 x[n]（远端音频） 滤波器权重（系数）向量 w[n]（动态更新） 滤波输出 y[n] = wᵗ[n] · x[n]（估计的回声） 误差信号 e[n] = d[n] - y[n]（d[n] 是麦克风输入） 更新公式：w[n+1] = w[n] + μ · e[n] · x[n] μ 是学习率 ✅ 二、结构图（逻辑流程）\nx[n] (远端信号) │ ▼ +----------------------------+ | FIR 滤波器： | | y[n] = Σ w_i[n] · x[n-i] | +----------------------------+ │ ▼ y[n] = 估计回声 │ ├─────────────┐ ▼ ▼ d[n] = 近端麦克风输入（含人声+回声） │ e[n] = d[n] - y[n] ◄──────┐ │ │ ▼ │ 更新权重：w[n+1] = w[n] + μ·e[n]·x[n] │ └───（反馈更新滤波器） ✅ 三、结构展开（FIR部分）\n一个长度为 N=4 的自适应 FIR 滤波器可以表示为：\n$$ y[n] = w₀·x[n] + w₁·x[n-1] + w₂·x[n-2] + w₃·x[n-3] $$\n它有 4 个权重（w₀ ~ w₃），这些权重是动态更新的，每次都有误差反馈来调整，逐渐逼近回声路径。\n✅ 四、关键点总结\n元件 含义 x[n] 扬声器的音频信号（远端） d[n] 麦克风采集音频（近端+回声） y[n] 滤波器输出（回声估计） e[n] 误差信号（理想是只有人声） w[n] 滤波器权值，动态学习通道特性 μ 学习率，控制收敛速度和稳定性 下面是一个简化的 LMS（Least Mean Squares）算法的 Python 实现，用于音频信号的自适应滤波，适合演示 AEC 的基本过程。 import numpy as np import matplotlib.pyplot as plt # 模拟信号 np.random.seed(0) N = 500 far_end = np.random.randn(N) * 0.5 # 远端信号（扬声器信号） echo_path = np.array([0.6, 0.3, 0.1]) # 假设的回声路径（FIR滤波器系数） echo = np.convolve(far_end, echo_path, mode='full')[:N] near_end_voice = np.random.randn(N) * 0.1 # 近端人声（麦克风真正需要的信号） mic_signal = echo + near_end_voice # 麦克风采到的是 回声 + 近端语音 # LMS参数 M = 3 # 滤波器长度（与echo_path一致） mu = 0.01 # 步长因子 / 学习率 w = np.zeros(M) # 初始滤波器系数 output = np.zeros(N) # 输出信号 error = np.zeros(N) # 误差信号 # LMS 主循环 for n in range(M, N): x = far_end[n-M:n][::-1] # 远端信号窗口（倒序） y = np.dot(w, x) # 滤波器输出（回声估计） d = mic_signal[n] # 麦克风信号 = 回声 + 人声 e = d - y # 误差 = 麦克风信号 - 回声估计 w = w + 2 * mu * e * x # LMS 更新公式 output[n] = y error[n] = e # 可视化：滤波器估计的回声、误差信号 plt.figure(figsize=(12, 6)) plt.plot(mic_signal, label=\"Mic signal (Echo + Voice)\") plt.plot(output, label=\"Estimated Echo (Filter Output)\") plt.plot(error, label=\"Error (Voice only)\") plt.legend() plt.title(\"LMS Adaptive Filter for Echo Cancellation\") plt.xlabel(\"Sample\") plt.grid(True) plt.tight_layout() plt.show() x = far_end[n-M:n][::-1]：输入窗口，倒序（模拟 FIR 滤波器结构）。 y = np.dot(w, x)：滤波器输出，即当前估计的回声。 e = d - y：真实输入信号 - 估计回声 = 误差（期望只剩人声）。 正确划分：红点在直线一侧，蓝点在另一侧 ⇒ 线性可分 w = w + 2 * mu * e * x：LMS核心公式，根据误差和输入更新滤波器。 以下是一个详细注释的 C 语言实现版本，用于演示 LMS（最小均方）算法在回声消除中的应用。这个示例简化了音频采集和播放部分，重点在于展示 LMS 核心逻辑，便于你在嵌入式或实时音频系统中改写和集成。 #include #include #include #include #define N 500 // 总样本数 #define M 3 // 滤波器长度 #define MU 0.01f // 学习率 // 模拟数据初始化函数 void generate_signals(float* far_end, float* mic_signal, float* near_end_voice, float* echo_path, int len) { for (int i = 0; i \u003c len; i++) { // 模拟远端信号（扬声器输出） far_end[i] = ((float)rand() / RAND_MAX - 0.5f) * 1.0f; // 模拟近端人声（小幅噪声） near_end_voice[i] = ((float)rand() / RAND_MAX - 0.5f) * 0.2f; } // 通过 FIR 卷积方式模拟回声路径 for (int i = 0; i \u003c len; i++) { mic_signal[i] = near_end_voice[i]; // 初始化为近端人声 for (int j = 0; j \u003c M; j++) { if (i - j \u003e= 0) { mic_signal[i] += echo_path[j] * far_end[i - j]; // 添加模拟回声 } } } } int main() { float far_end[N]; // 扬声器信号 float near_end_voice[N]; // 人声（麦克风中希望保留的成分） float mic_signal[N]; // 麦克风采到的信号（人声 + 回声） float echo_path[M] = {0.6f, 0.3f, 0.1f}; // 模拟的回声通道 float w[M] = {0}; // 滤波器系数（自适应学习） float output[N] = {0}; // 滤波器输出（估计的回声） float error[N] = {0}; // 误差信号（目标是只保留人声） // 生成输入数据 generate_signals(far_end, mic_signal, near_end_voice, echo_path, N); // LMS 核心算法 for (int n = M; n \u003c N; n++) { float x[M]; // 输入窗口 float y = 0; // 滤波器输出 float e; // 当前误差 // 构造输入向量（倒序） for (int i = 0; i \u003c M; i++) { x[i] = far_end[n - i]; } // 滤波器输出 y(n) = w(n)^T * x(n) for (int i = 0; i \u003c M; i++) { y += w[i] * x[i]; } // 误差 e(n) = d(n) - y(n) e = mic_signal[n] - y; // LMS 更新 w(n+1) = w(n) + 2 * mu * e(n) * x(n) for (int i = 0; i \u003c M; i++) { w[i] += 2 * MU * e * x[i]; } // 保存输出和误差 output[n] = y; error[n] = e; } // 打印最后的滤波器系数 printf(\"Final filter coefficients:\\n\"); for (int i = 0; i \u003c M; i++) { printf(\"w[%d] = %f\\n\", i, w[i]); } // 打印前几十个误差信号样本（可视化用） printf(\"\\nFirst 20 error samples (near-end voice only):\\n\"); for (int i = 0; i \u003c 20; i++) { printf(\"%d: %f\\n\", i, error[i]); } return 0; } 📌 实现要点说明\n元素 说明 echo_path[] 用于模拟回声传播通道，真实系统中是未知的，由 w[] 学习逼近。 far_end[] 远端发送来的音频，被扬声器播放，会被麦克风\"听到\"形成回声。 mic_signal[] 麦克风接收的音频，包含远端回声和近端说话声（需要保留）。 w[] 自适应滤波器的系数，迭代更新，目标是使 output[] 接近实际回声，从而让 error[] 剩下近端语音。 MU 步长（学习率），控制收敛速度与稳定性，太大会发散，太小收敛慢。 ✅ 一、自适应滤波器结构在代码中的体现\n在 C 代码中，自适应滤波器是以 FIR（有限脉冲响应）结构 + LMS 更新算法 实现的。我们来分解两部分：\n滤波器结构体现（FIR 结构） 在这段代码里：\nfor (int i = 0; i \u003c M; i++) { x[i] = far_end[n - i]; // 输入窗口：延迟线结构 } for (int i = 0; i \u003c M; i++) { y += w[i] * x[i]; // FIR 滤波器加权输出 } 这就实现了一个 M 阶的 FIR 滤波器：\nx[i] 是远端信号延迟线（delay line） w[i] 是自适应滤波器系数（adaptive taps） 输出 y 是回声估计 滤波器更新（LMS 自适应） e = mic_signal[n] - y; // 误差 = 实际麦克风 - 滤波器估计回声 for (int i = 0; i \u003c M; i++) { w[i] += 2 * MU * e * x[i]; // LMS 核心更新公式 } 这部分是 LMS 学习过程：根据误差信号来调整每一个滤波器权重。\n总结：\nFIR 结构是固定的：x 和 w 做加权和 自适应发生在权重 w 上：它不断调整以最小化误差 ✅ 二、引入 NLMS（Normalized LMS）以增强稳定性\n🧠 问题：LMS 的稳定性受输入信号能量变化影响\n在原始 LMS 中：\nw[i] += 2 * MU * e * x[i]; 如果 x[i] 很大（信号能量高），更新步长可能过大，导致发散。\n🔧 解决：引入 NLMS（Normalized LMS）\nNLMS 核心思想：对每次更新除以输入信号的能量，以实现归一化。\n✅ NLMS 更新公式：\n$$ w(n+1) = w(n) + \\mu \\cdot \\frac{e(n) \\cdot x(n)}{\\delta + |x(n)|^2} $$\n\\mu：步长（一般小于 1） \\delta：微小常数，防止除 0 |x(n)|^2：当前输入信号能量（即 x 的平方和） ✅ C 语言替代 LMS 更新段（加入 NLMS）：\nfloat norm = 0.0001f; // δ，防止除 0 // 计算输入向量的能量（平方和） for (int i = 0; i \u003c M; i++) { norm += x[i] * x[i]; } // NLMS 更新 for (int i = 0; i \u003c M; i++) { w[i] += MU * e * x[i] / norm; } 优点：\n在远端信号强弱变化时依然稳定 更快收敛、更少抖动，常用于语音通话中的 AEC ✅ 三、双讲（Double-Talk）检测与保护机制\n🧠 问题：当双方同时讲话（即近端和远端都有声音），\n麦克风中不再只有回声，误差信号中含有近端人声。\n如果 LMS/NLMS 在此时还继续更新权重，可能会误把人声当作回声学习进去，导致近端语音也被\"消除\"。 🛡️ 解决方法：双讲检测 + 更新冻结\n典型策略：\n检测双讲（Double-Talk Detector） 比较： 回声估计误差 |e(n)| 麦克风能量 |d(n)| 远端信号能量 |x(n)| 如果误差较大，但远端信号不强，说明有近端人声，可能是双讲。 冻结滤波器更新（Skip LMS/NLMS update） ✅ 示例伪代码（简化）：\nfloat mic_power = mic_signal[n] * mic_signal[n]; float far_power = 0.0f; for (int i = 0; i \u003c M; i++) { far_power += x[i] * x[i]; } // 简单阈值检测（也可以用协方差检测等更复杂方法） if (mic_power \u003e THRESHOLD \u0026\u0026 far_power \u003c LOW_ENERGY_THRESH) { freeze_update = 1; // 双讲，暂停自适应 } else { freeze_update = 0; } if (!freeze_update) { // 执行 LMS/NLMS 更新 } 注：这只是最简单的检测方法，实际产品中常用 Geigel 算法、双通道协方差估计 等更鲁棒方法。\n✅ 总结结构图\n+---------------------+ Far-End | x[n] |\u003c----------+ Signal +---------------------+ | | FIR Filter (w[n]) | | +---------------------+ | | y[n] | v | +---------------------+ | | Error: e[n]=d[n]-y[n]| | +---------------------+ | | | v | +--------------------------+ | | Double-Talk Detector |----+ +--------------------------+ | Freeze Update? | v +------------------+ | LMS/NLMS Update | +------------------+ | w[n+1] 下面是一个完整的 C 语言实现，结合了以下三部分：\n✅ FIR 结构 + NLMS（归一化 LMS）更新公式 ✅ 双讲检测（Double-Talk Detection） ✅ 检测期间冻结更新（保护滤波器） ⸻\n✅ 完整 C 语言实现：NLMS + 双讲检测保护\n#include #include #include #define FRAME_LEN 160 // 每帧样本数（10ms @ 16kHz） #define FILTER_LEN 128 // 滤波器阶数（tap数） #define MU 0.8f // 步长参数 #define EPSILON 1e-6f // 防止除以0 #define DTD_THRESH 2.0f // 双讲检测阈值 // 模拟数据接口（实际使用中应连接声卡/录音数据） float get_far_end_sample(int n); float get_mic_sample(int n); // NLMS + DTD 主处理函数 void aec_process(float* mic_signal, float* far_end_signal, float* out_signal, int len) { float w[FILTER_LEN] = {0}; // 滤波器权重初始化为 0 float x[FILTER_LEN] = {0}; // 输入延迟线（远端） float e = 0.0f; // 误差信号 float y = 0.0f; // 滤波器输出（回声估计） for (int n = 0; n \u003c len; n++) { // 滚动延迟线 for (int i = FILTER_LEN - 1; i \u003e 0; i--) { x[i] = x[i - 1]; } x[0] = far_end_signal[n]; // 新样本插入最前端 // 滤波器加权和（回声估计） y = 0.0f; for (int i = 0; i \u003c FILTER_LEN; i++) { y += w[i] * x[i]; } // 计算误差 e(n) = d(n) - y(n) e = mic_signal[n] - y; out_signal[n] = e; // 输出误差信号（即消除回声后的信号） // === 双讲检测 === float mic_power = mic_signal[n] * mic_signal[n]; float far_power = EPSILON; // 防止除0 for (int i = 0; i \u003c FILTER_LEN; i++) { far_power += x[i] * x[i]; } int double_talk = (mic_power / far_power \u003e DTD_THRESH) ? 1 : 0; // === NLMS 更新权重 === if (!double_talk) { for (int i = 0; i \u003c FILTER_LEN; i++) { w[i] += (MU * e * x[i]) / far_power; } } } } ✅ 每个部分解释：\n🎯 滤波器结构\nx[i] 是远端信号延迟线 w[i] 是滤波器系数，表示回声路径响应 y 是估计出的回声信号 🎯 NLMS 更新核心：\n$$ w_i(n+1) = w_i(n) + \\mu \\cdot \\frac{e(n) \\cdot x_i(n)}{\\varepsilon + |x(n)|^2} $$\n🎯 双讲检测逻辑： mic_power / far_power \u003e DTD_THRESH\n当麦克风信号比远端信号强很多时，说明可能是用户在说话（双讲） 此时跳过权重更新 下面是一个完整的可运行 Python 程序，模拟了 NLMS 回声消除系统，包括：\n模拟远端语音（正弦信号） 模拟真实回声路径（FIR 滤波器卷积） 加入本地讲话（近端人声） 使用 NLMS 算法自适应估计回声路径并消除回声 可视化： 原始远端信号 麦克风信号（含回声 + 本地讲话） 回声抵消后输出 滤波器估计过程 import numpy as np import matplotlib.pyplot as plt # 参数配置 fs = 8000 # 采样率 duration = 1.0 # 信号持续时间（秒） N = int(fs * duration) # 采样点数 filter_len = 64 # 回声路径长度 mu = 0.1 # NLMS 步长 eps = 1e-8 # 防止除零 # 1. 模拟远端信号（sin + 噪声） t = np.linspace(0, duration, N) far_end = 0.5 * np.sin(2 * np.pi * 440 * t) + 0.05 * np.random.randn(N) # 2. 模拟真实回声路径 true_echo_path = np.random.randn(filter_len) * np.hanning(filter_len) true_echo_path /= np.linalg.norm(true_echo_path) # 单位化 echo_signal = np.convolve(far_end, true_echo_path, mode='full')[:N] # 3. 模拟近端人声（后半段双讲） near_end = np.zeros(N) near_end[N // 2:] = 0.3 * np.sin(2 * np.pi * 220 * t[N // 2:]) # 4. 麦克风接收信号 = 回声 + 近端人声 mic_signal = echo_signal + near_end # 5. 初始化自适应滤波器参数 w = np.zeros(filter_len) # 自适应滤波器权重 x_buf = np.zeros(filter_len) # 输入缓存 out_signal = np.zeros(N) # 回声抵消后的输出 error_curve = np.zeros(N) # 残差信号（误差） # 6. NLMS + DTD 主循环 for n in range(N): # 更新输入缓存 x_buf[1:] = x_buf[:-1] x_buf[0] = far_end[n] # 滤波器输出估计的回声 y_hat = np.dot(w, x_buf) # 实际误差信号（麦克风 - 估计回声） e = mic_signal[n] - y_hat error_curve[n] = e out_signal[n] = e # 去回声后的输出 # 简单双讲检测（energy 比值法） if np.dot(x_buf, x_buf) \u003e 0.001 and np.abs(e) \u003c 1.0: # NLMS 权重更新 norm_factor = np.dot(x_buf, x_buf) + eps w += (mu / norm_factor) * e * x_buf # 7. 绘图显示结果 plt.figure(figsize=(12, 10)) plt.subplot(4, 1, 1) plt.title(\"Far-end Signal (Speaker Output)\") plt.plot(far_end) plt.ylabel(\"Amplitude\") plt.subplot(4, 1, 2) plt.title(\"Mic Signal (Echo + Near-end Speech)\") plt.plot(mic_signal) plt.ylabel(\"Amplitude\") plt.subplot(4, 1, 3) plt.title(\"Output after Echo Cancellation\") plt.plot(out_signal) plt.ylabel(\"Amplitude\") plt.subplot(4, 1, 4) plt.title(\"Estimated Echo Path (Filter Coefficients)\") plt.plot(w, label=\"Estimated\") plt.plot(true_echo_path, '--', label=\"True\", alpha=0.7) plt.legend() plt.xlabel(\"Taps\") plt.tight_layout() plt.show() 总结与实践建议 💡 系统设计考虑\n选择合适的滤波器长度（权衡计算量和效果） 合理设置学习率（权衡收敛速度和稳定性） 考虑双讲检测机制 优化方向\n非线性回声处理 自适应学习率调整 双讲场景优化 实际应用注意事项\n系统延迟补偿 环境变化检测 计算资源优化 参考文献与延伸阅读：\nHaykin, S. “Adaptive Filter Theory” Benesty, J. “Adaptive Signal Processing” ","wordCount":"2220","inLanguage":"en","datePublished":"2024-04-22T00:00:00Z","dateModified":"2024-04-22T00:00:00Z","author":{"@type":"Person","name":"徐亚飞"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xuyafei.github.io/personal-site/posts/adaptive_filter_aec/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://xuyafei.github.io/personal-site/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xuyafei.github.io/personal-site/ accesskey=h title="我的博客 (Alt + H)">我的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xuyafei.github.io/personal-site/categories/ title=分类><span>分类</span></a></li><li><a href=https://xuyafei.github.io/personal-site/tags/ title=标签><span>标签</span></a></li><li><a href=https://xuyafei.github.io/personal-site/archives/ title=归档><span>归档</span></a></li><li><a href=https://xuyafei.github.io/personal-site/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xuyafei.github.io/personal-site/>Home</a>&nbsp;»&nbsp;<a href=https://xuyafei.github.io/personal-site/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">自适应滤波器与回声消除（AEC）原理详解</h1><div class=post-description>自适应滤波器与回声消除。</div><div class=post-meta><span title='2024-04-22 00:00:00 +0000 UTC'>April 22, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;徐亚飞</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%87%aa%e9%80%82%e5%ba%94%e6%bb%a4%e6%b3%a2%e5%99%a8%e4%b8%8e%e5%9b%9e%e5%a3%b0%e6%b6%88%e9%99%a4aec%e5%8e%9f%e7%90%86%e8%af%a6%e8%a7%a3 aria-label=自适应滤波器与回声消除（AEC）原理详解>自适应滤波器与回声消除（AEC）原理详解</a><ul><li><a href=#%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86 aria-label=核心原理>核心原理</a><ul><li><a href=#%e5%8e%9f%e7%90%86%e7%ae%80%e8%bf%b0- aria-label="原理简述 🧠">原理简述 🧠</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e4%bf%a1%e5%8f%b7%e6%a8%a1%e5%9e%8b- aria-label="基本信号模型 📦">基本信号模型 📦</a></li><li><a href=#%e8%87%aa%e9%80%82%e5%ba%94%e6%bb%a4%e6%b3%a2%e5%99%a8%e5%b7%a5%e4%bd%9c%e6%9c%ba%e5%88%b6- aria-label="自适应滤波器工作机制 ⚙️">自适应滤波器工作机制 ⚙️</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%ae%83%e8%83%bd%e6%88%90%e5%8a%9f- aria-label="为什么它能成功 🔍">为什么它能成功 🔍</a></li><li><a href=#%e6%8c%91%e6%88%98%e6%83%85%e5%86%b5- aria-label="挑战情况 🚫">挑战情况 🚫</a></li></ul></li><li><a href=#lms-%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3 aria-label="LMS 算法详解">LMS 算法详解</a><ul><li><a href=#lms-%e7%9a%84%e6%a0%b8%e5%bf%83%e6%80%9d%e6%83%b3- aria-label="LMS 的核心思想 🧠">LMS 的核心思想 🧠</a></li><li><a href=#%e7%ac%a6%e5%8f%b7%e8%af%b4%e6%98%8e- aria-label="符号说明 📌">符号说明 📌</a></li></ul></li><li><a href=#%e6%94%b6%e6%95%9b%e8%bf%87%e7%a8%8b%e8%af%a6%e8%a7%a3- aria-label="收敛过程详解 🌀">收敛过程详解 🌀</a><ul><li><a href=#1-%e5%88%9d%e5%a7%8b%e7%8a%b6%e6%80%81%e4%b8%80%e6%97%a0%e6%89%80%e7%9f%a5- aria-label="1. 初始状态：一无所知 ✅">1. 初始状态：一无所知 ✅</a></li><li><a href=#2-%e6%a2%af%e5%ba%a6%e5%8f%8d%e9%a6%88%e8%af%af%e5%b7%ae%e9%a9%b1%e5%8a%a8%e6%9b%b4%e6%96%b0- aria-label="2. 梯度反馈：误差驱动更新 ✅">2. 梯度反馈：误差驱动更新 ✅</a></li><li><a href=#3-%e6%8c%81%e7%bb%ad%e8%ae%ad%e7%bb%83%e4%b8%8d%e6%96%ad%e8%bf%ad%e4%bb%a3%e9%9d%a0%e8%bf%91%e7%9b%ae%e6%a0%87- aria-label="3. 持续训练：不断迭代靠近目标 ✅">3. 持续训练：不断迭代靠近目标 ✅</a></li><li><a href=#4-%e6%94%b6%e6%95%9b%e5%90%8e%e7%9a%84%e6%95%88%e6%9e%9c- aria-label="4. 收敛后的效果 ✅">4. 收敛后的效果 ✅</a></li><li><a href=#%e6%94%b6%e6%95%9b%e4%be%9d%e8%b5%96%e6%9d%a1%e4%bb%b6- aria-label="收敛依赖条件 🔁">收敛依赖条件 🔁</a></li></ul></li><li><a href=#%e6%95%b0%e5%ad%a6%e6%8e%a8%e5%af%bc%e4%b8%8e%e5%ae%9e%e4%be%8b- aria-label="数学推导与实例 🔢">数学推导与实例 🔢</a></li><li><a href=#%e4%b8%8b%e9%9d%a2%e6%98%af%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8c%96%e7%9a%84-lmsleast-mean-squares%e7%ae%97%e6%b3%95%e7%9a%84-python-%e5%ae%9e%e7%8e%b0%e7%94%a8%e4%ba%8e%e9%9f%b3%e9%a2%91%e4%bf%a1%e5%8f%b7%e7%9a%84%e8%87%aa%e9%80%82%e5%ba%94%e6%bb%a4%e6%b3%a2%e9%80%82%e5%90%88%e6%bc%94%e7%a4%ba-aec-%e7%9a%84%e5%9f%ba%e6%9c%ac%e8%bf%87%e7%a8%8b aria-label="下面是一个简化的 LMS（Least Mean Squares）算法的 Python 实现，用于音频信号的自适应滤波，适合演示 AEC 的基本过程。">下面是一个简化的 LMS（Least Mean Squares）算法的 Python 实现，用于音频信号的自适应滤波，适合演示 AEC 的基本过程。</a><ul><li><a href=#%e4%bb%a5%e4%b8%8b%e6%98%af%e4%b8%80%e4%b8%aa%e8%af%a6%e7%bb%86%e6%b3%a8%e9%87%8a%e7%9a%84-c-%e8%af%ad%e8%a8%80%e5%ae%9e%e7%8e%b0%e7%89%88%e6%9c%ac%e7%94%a8%e4%ba%8e%e6%bc%94%e7%a4%ba-lms%e6%9c%80%e5%b0%8f%e5%9d%87%e6%96%b9%e7%ae%97%e6%b3%95%e5%9c%a8%e5%9b%9e%e5%a3%b0%e6%b6%88%e9%99%a4%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8%e8%bf%99%e4%b8%aa%e7%a4%ba%e4%be%8b%e7%ae%80%e5%8c%96%e4%ba%86%e9%9f%b3%e9%a2%91%e9%87%87%e9%9b%86%e5%92%8c%e6%92%ad%e6%94%be%e9%83%a8%e5%88%86%e9%87%8d%e7%82%b9%e5%9c%a8%e4%ba%8e%e5%b1%95%e7%a4%ba-lms-%e6%a0%b8%e5%bf%83%e9%80%bb%e8%be%91%e4%be%bf%e4%ba%8e%e4%bd%a0%e5%9c%a8%e5%b5%8c%e5%85%a5%e5%bc%8f%e6%88%96%e5%ae%9e%e6%97%b6%e9%9f%b3%e9%a2%91%e7%b3%bb%e7%bb%9f%e4%b8%ad%e6%94%b9%e5%86%99%e5%92%8c%e9%9b%86%e6%88%90 aria-label="以下是一个详细注释的 C 语言实现版本，用于演示 LMS（最小均方）算法在回声消除中的应用。这个示例简化了音频采集和播放部分，重点在于展示 LMS 核心逻辑，便于你在嵌入式或实时音频系统中改写和集成。">以下是一个详细注释的 C 语言实现版本，用于演示 LMS（最小均方）算法在回声消除中的应用。这个示例简化了音频采集和播放部分，重点在于展示 LMS 核心逻辑，便于你在嵌入式或实时音频系统中改写和集成。</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93%e4%b8%8e%e5%ae%9e%e8%b7%b5%e5%bb%ba%e8%ae%ae- aria-label="总结与实践建议 💡">总结与实践建议 💡</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=自适应滤波器与回声消除aec原理详解>自适应滤波器与回声消除（AEC）原理详解<a hidden class=anchor aria-hidden=true href=#自适应滤波器与回声消除aec原理详解>#</a></h1><h2 id=核心原理>核心原理<a hidden class=anchor aria-hidden=true href=#核心原理>#</a></h2><p>自适应滤波器之所以能够用于回声消除（AEC），核心原因在于它可以动态估计并还原"回声路径"，然后将这一估计出的回声信号从麦克风输入中减去，从而实现回声的抑制甚至消除。</p><h3 id=原理简述->原理简述 🧠<a hidden class=anchor aria-hidden=true href=#原理简述->#</a></h3><p>在回声消除系统中，自适应滤波器会根据扬声器输出（远端信号）来预测它在麦克风中会出现的形式（回声），然后从实际的麦克风输入中减去这个预测的信号。</p><h3 id=基本信号模型->基本信号模型 📦<a hidden class=anchor aria-hidden=true href=#基本信号模型->#</a></h3><p>设：</p><ul><li><code>x(n)</code>：远端信号（扬声器播放）</li><li><code>d(n)</code>：麦克风信号（含近端语音 + 回声）</li><li><code>y(n)</code>：自适应滤波器输出（回声的估计）</li><li><code>e(n)</code>：误差信号（d(n) - y(n)，理论上就是近端语音）</li></ul><p>自适应滤波器目标是：
$$
y(n) ≈ 回声分量 = x(n) * h(n)
$$
其中 <code>h(n)</code> 是回声路径（扬声器到麦克风的模拟传输特性，可能包含混响、设备响应等）。</p><p>最终：
$$
e(n) = d(n) - y(n) ≈ 近端语音
$$</p><h3 id=自适应滤波器工作机制->自适应滤波器工作机制 ⚙️<a hidden class=anchor aria-hidden=true href=#自适应滤波器工作机制->#</a></h3><ul><li>使用如 LMS（Least Mean Square）或 NLMS 算法，通过最小化 e(n) 的能量来不断更新滤波器系数</li><li>当估计越来越准时，y(n) 趋近于回声，e(n) 就接近纯近端语音</li></ul><h3 id=为什么它能成功->为什么它能成功 🔍<a hidden class=anchor aria-hidden=true href=#为什么它能成功->#</a></h3><ol><li><strong>因果建模</strong>：回声路径是因果的，即某时刻的扬声器输出 x(n) 会在未来若干毫秒后以回声的形式出现在麦克风中</li><li><strong>线性建模有效</strong>：大多数设备在一定条件下，其声学路径可以较好地用线性模型（FIR 滤波器）表示</li><li><strong>反馈优化</strong>：误差信号 e(n) 反馈用于更新滤波器参数，不断逼近真实的回声路径响应</li></ol><h3 id=挑战情况->挑战情况 🚫<a hidden class=anchor aria-hidden=true href=#挑战情况->#</a></h3><ul><li><strong>双讲问题</strong>：远近端同时说话时，远端信号和近端语音混合后，误差信号不再纯粹代表回声误差，滤波器容易被误导</li><li><strong>非线性失真</strong>：如设备中存在非线性放大、限幅等，使得简单线性滤波器难以完全建模</li></ul><h2 id=lms-算法详解>LMS 算法详解<a hidden class=anchor aria-hidden=true href=#lms-算法详解>#</a></h2><p>LMS（Least Mean Squares，最小均方）算法是一种自适应滤波算法，它通过不断调整滤波器的系数，使得输出信号尽可能逼近目标信号（期望信号）。</p><h3 id=lms-的核心思想->LMS 的核心思想 🧠<a hidden class=anchor aria-hidden=true href=#lms-的核心思想->#</a></h3><p>在每一帧音频数据处理时，LMS 算法执行以下步骤：</p><ol><li><p><strong>获取参考信号 x(n)</strong></p><ul><li>这是扬声器播放出去的音频（远端信号），作为"回声来源"</li></ul></li><li><p><strong>通过自适应滤波器预测回声 ŷ(n)</strong>
$$
ŷ(n) = w(n)^T · x(n)
$$</p><ul><li>w(n)：当前时刻的滤波器权重（即回声通道估计）</li><li>x(n)：过去若干个远端信号组成的向量</li></ul></li><li><p><strong>计算误差信号 e(n)</strong>
$$
e(n) = d(n) - ŷ(n)
$$</p><ul><li>d(n)：麦克风采集到的信号（包含人声 + 回声）</li><li>e(n)：我们希望最终听到的纯净人声信号</li></ul></li><li><p><strong>更新滤波器权重</strong>
$$
w(n+1) = w(n) + μ · e(n) · x(n)
$$</p><ul><li>μ 是学习率（控制更新幅度，太大不稳定，太小收敛慢）</li></ul></li></ol><h3 id=符号说明->符号说明 📌<a hidden class=anchor aria-hidden=true href=#符号说明->#</a></h3><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>x(n)</td><td>当前及过去远端样本向量</td></tr><tr><td>w(n)</td><td>滤波器系数，模拟声道</td></tr><tr><td>ŷ(n)</td><td>估计回声</td></tr><tr><td>d(n)</td><td>麦克风采集的混合信号</td></tr><tr><td>e(n)</td><td>误差，即人声估计值</td></tr><tr><td>μ</td><td>步长（学习率）</td></tr></tbody></table><h2 id=收敛过程详解->收敛过程详解 🌀<a hidden class=anchor aria-hidden=true href=#收敛过程详解->#</a></h2><p>回声消除不可能一开始就"完美"，必须依靠一个"收敛"的学习过程。这个过程本质上是一个迭代优化过程，自适应滤波器逐步"学会"回声通道的特性。</p><h3 id=1-初始状态一无所知->1. 初始状态：一无所知 ✅<a hidden class=anchor aria-hidden=true href=#1-初始状态一无所知->#</a></h3><ul><li>刚开始时，滤波器权重 w(n) 是全 0 或随机初始化</li><li>滤波器无法估计出真实的回声，只能输出很差的 ŷ(n)</li><li>结果就是：减去的回声信号不准确，误差 e(n) 很大</li></ul><h3 id=2-梯度反馈误差驱动更新->2. 梯度反馈：误差驱动更新 ✅<a hidden class=anchor aria-hidden=true href=#2-梯度反馈误差驱动更新->#</a></h3><ul><li>LMS 核心公式：
$$
w(n+1) = w(n) + μ · e(n) · x(n)
$$</li><li>根据当前的误差 e(n) 和远端信号 x(n)，来更新滤波器参数 w(n)</li><li>目标是：让下一次输出的回声预测 ŷ(n+1) 更接近真实回声</li></ul><h3 id=3-持续训练不断迭代靠近目标->3. 持续训练：不断迭代靠近目标 ✅<a hidden class=anchor aria-hidden=true href=#3-持续训练不断迭代靠近目标->#</a></h3><p>收敛条件要求：</p><ul><li>学习率 μ 不过大（否则震荡）</li><li>有足够"丰富"的远端语音输入 x(n)</li><li>没有强干扰</li></ul><p>当这些条件满足时，误差 e(n) 会越来越小，权重 w(n) 趋于稳定。</p><h3 id=4-收敛后的效果->4. 收敛后的效果 ✅<a hidden class=anchor aria-hidden=true href=#4-收敛后的效果->#</a></h3><ul><li>滤波器已经基本"拟合"出房间的回声通道</li><li>对于新到的远端音频信号，滤波器能准确预测出其回声</li><li>将其从麦克风信号中减掉后，剩下的主要就是人声</li></ul><h3 id=收敛依赖条件->收敛依赖条件 🔁<a hidden class=anchor aria-hidden=true href=#收敛依赖条件->#</a></h3><table><thead><tr><th>条件</th><th>影响</th><th>举例</th></tr></thead><tbody><tr><td>学习率 μ</td><td>控制收敛速度和稳定性</td><td>太大会震荡，太小会慢</td></tr><tr><td>远端信号丰富性</td><td>提供"训练数据"</td><td>远端语音内容越多越稳定越好</td></tr><tr><td>麦克风信号质量</td><td>保证误差信号有意义</td><td>加噪严重会影响误差计算</td></tr><tr><td>回声路径稳定</td><td>环境变化越小越容易收敛</td><td>移动手机、音量突变等会打断学习</td></tr></tbody></table><h2 id=数学推导与实例->数学推导与实例 🔢<a hidden class=anchor aria-hidden=true href=#数学推导与实例->#</a></h2><p>💬 为什么这很奇妙？</p><p>因为 AEC 像是"机器在学习听觉模式"：
它从完全不了解这个房间的回声结构，在无监督的情况下，通过每一帧误差，自己慢慢"摸索"出房间、麦克风、扬声器之间的关系，构建出一套自己的"回声模型" —— 这是一个高度自适应的行为，跟人类在听觉学习中很像。</p><p>一步一步地从数学角度推导出 LMS 在回声消除中是如何工作的，包括：</p><ol><li>自适应滤波器结构</li><li>回声估计与误差计算</li><li>权重更新（带学习率）</li><li>简单数值示例演示"收敛"过程</li></ol><p>🧠 一、基本模型结构</p><p>假设我们使用一个长度为 N 的 FIR 滤波器来估计回声：</p><ul><li>x(n)：当前帧远端信号</li><li>x(n-1), x(n-2), &mldr;, x(n-N+1)：历史帧构成一个信号窗口</li><li>w(n)：滤波器权重（系数）</li></ul><p>回声估计：</p><p>$$
\hat{y}(n) = \sum_{i=0}^{N-1} w_i(n) \cdot x(n-i)
$$</p><p>误差信号：</p><p>$$
e(n) = d(n) - \hat{y}(n)
$$</p><p>其中 d(n) 是近端麦克风采集的信号（人声 + 回声），e(n) 应该是近端人声。</p><p>📘 二、LMS 更新公式</p><p>为了让估计的回声更接近实际的回声，我们用误差信号 e(n) 来更新 w(n)：</p><p>$$
w_i(n+1) = w_i(n) + μ \cdot e(n) \cdot x(n-i)
$$</p><p>其中：</p><ul><li>μ 是学习率，控制更新的速度（通常是 0.001 ~ 0.01 之间的小数）</li><li>x(n-i) 是过去的远端信号样本</li><li>e(n) 是当前误差信号</li></ul><p>🔢 三、简单数值演示</p><p>假设我们用一个长度为 3 的滤波器（N=3）来估计回声。</p><p>条件设定：</p><ul><li>初始权重 w = [0, 0, 0]</li><li>学习率 μ = 0.1</li><li>某一时刻远端信号 x(n), x(n-1), x(n-2) = [1.0, 0.5, -0.3]</li><li>近端麦克风采集到的信号（含回声）d(n) = 0.8</li></ul><p>第一步：估计回声 ŷ(n)</p><p>$$
\hat{y}(n) = 0 \cdot 1.0 + 0 \cdot 0.5 + 0 \cdot (-0.3) = 0
$$</p><p>第二步：计算误差</p><p>$$
e(n) = d(n) - \hat{y}(n) = 0.8 - 0 = 0.8
$$</p><p>第三步：更新权重</p><p>$$
w_0(n+1) = 0 + 0.1 \cdot 0.8 \cdot 1.0 = 0.08
$$</p><p>$$
w_1(n+1) = 0 + 0.1 \cdot 0.8 \cdot 0.5 = 0.04
$$</p><p>$$
w_2(n+1) = 0 + 0.1 \cdot 0.8 \cdot (-0.3) = -0.024
$$</p><p>所以新的权重是：
$$
w(n+1) = [0.08, 0.04, -0.024]
$$</p><p>第二帧到来时</p><p>只要继续新的远端样本、对应的近端采样信号，重复上面过程，就会不断更新权重。随着时间推移，权重会逐步逼近真实的房间回声路径系数。</p><p>📈 收敛的数学视角</p><ul><li>LMS 是在最小化误差平方：E[e(n)^2]</li><li>它其实是在做随机梯度下降（SGD），寻找最优 w 使误差最小</li><li>收敛条件取决于：<ul><li>μ &lt; 1 / (3 × 输入信号功率)</li><li>输入信号需满足"持久激励"（丰富）</li></ul></li></ul><p>💡 关键数学过程解释：</p><ol><li>输入信号 x[n]：</li></ol><p>这是远端播放的信号，即扬声器发出的声音。</p><ol start=2><li>回声信号 d[n]：</li></ol><p>由真实的回声路径 true_filter 卷积生成，并加入噪声。也就是说，d[n] 是麦克风采集的信号（不含近端人声），形如：</p><p>$$
d[n] = \sum_{i=0}^{L-1} h[i] \cdot x[n-i]
$$</p><ol start=3><li>滤波器估计输出 ŷ[n]：</li></ol><p>$$
\hat{y}[n] = \sum_{i=0}^{L-1} w[i] \cdot x[n-i]
$$</p><ol start=4><li>误差信号 e[n]：</li></ol><p>$$
e[n] = d[n] - \hat{y}[n]
$$</p><p>这是我们要最小化的量。</p><ol start=5><li>LMS 权重更新公式：</li></ol><p>$$
w_{i}[n+1] = w_{i}[n] + \mu \cdot e[n] \cdot x[n-i]
$$</p><ul><li>μ 是学习率，控制收敛速度与稳定性</li><li>x[n-i] 是当前输入信号的延迟版本</li></ul><p>🧠 收敛的关键机制：</p><ul><li>起初权重是错误的，预测的 ŷ[n] 跟 d[n] 差距很大，误差 e[n] 很大；</li><li>LMS 会根据误差的方向和大小，调整每个权重，使得输出更接近目标；</li><li>随着时间推移，误差逐步减小，权重趋近于真实回声路径，达到收敛；</li><li>如果 μ 太大可能不稳定，太小会收敛慢。</li></ul><p><img alt="LMS 自适应滤波器的系数" loading=lazy src=/personal-site/posts/adaptive_filter_aec/figure1.png>
上图展示了 LMS 自适应滤波器的系数（蓝色曲线）如何逐步逼近真实的回声路径（黑色虚线），也就是滤波器"收敛"到一个能产生回声估计的理想状态。</p><p>一、LMS 原理再总结一下：</p><p>LMS（Least Mean Squares）通过以下方式更新滤波器系数 w：</p><p>$$
w[n+1] = w[n] + \mu \cdot e[n] \cdot x[n]
$$</p><p>其中：</p><ul><li>x[n]：输入信号（远端信号段）</li><li>e[n] = d[n] - y[n]：误差信号，d[n] 为近端麦克风采集（含回声），y[n] 是滤波器对回声的估计</li><li>μ：学习率（越大收敛越快但易震荡，越小越稳定但慢）</li><li>w[n]：滤波器系数，用于模拟真实的回声通道</li></ul><p>这个过程就是不断微调滤波器参数，使得预测的回声 y[n] 更贴近真实回声，逐渐实现抵消。</p><p>二、自适应滤波器结构图（经典结构）如下：</p><pre tabindex=0><code>     +------------------+      +-------------+
Far-end | x[n] (扬声器信号) |-----&gt;| Adaptive     |
signal  +------------------+      | Filter (w)  |----+
                                     +-------------+    |
                                                         v
Near-end                      +------------------+   +---------+
signal   d[n] = 人声+回声 ----&gt;|    差分器        |--&gt;| e[n]    | (误差)
                              | d[n] - y[n]       |   +---------+
                              +------------------+
</code></pre><p>✅ 一、自适应滤波器的基本结构（以 LMS 为例）</p><p>自适应滤波器的结构包括以下几个部分：</p><ol><li>输入信号 x[n]（远端音频）</li><li>滤波器权重（系数）向量 w[n]（动态更新）</li><li>滤波输出 y[n] = wᵗ[n] · x[n]（估计的回声）</li><li>误差信号 e[n] = d[n] - y[n]（d[n] 是麦克风输入）</li><li>更新公式：w[n+1] = w[n] + μ · e[n] · x[n]</li></ol><ul><li>μ 是学习率</li></ul><p>✅ 二、结构图（逻辑流程）</p><pre tabindex=0><code>         x[n] (远端信号)
              │
              ▼
 +----------------------------+
 | FIR 滤波器：               |
 | y[n] = Σ w_i[n] · x[n-i]  |
 +----------------------------+
              │
              ▼
       y[n] = 估计回声
              │
              ├─────────────┐
              ▼             ▼
       d[n] = 近端麦克风输入（含人声+回声）
              │
       e[n] = d[n] - y[n]   ◄──────┐
              │                    │
              ▼                    │
    更新权重：w[n+1] = w[n] + μ·e[n]·x[n]
                                   │
                                   └───（反馈更新滤波器）
</code></pre><p>✅ 三、结构展开（FIR部分）</p><p>一个长度为 N=4 的自适应 FIR 滤波器可以表示为：</p><p>$$
y[n] = w₀·x[n] + w₁·x[n-1] + w₂·x[n-2] + w₃·x[n-3]
$$</p><p>它有 4 个权重（w₀ ~ w₃），这些权重是动态更新的，每次都有误差反馈来调整，逐渐逼近回声路径。</p><p>✅ 四、关键点总结</p><table><thead><tr><th>元件</th><th>含义</th></tr></thead><tbody><tr><td>x[n]</td><td>扬声器的音频信号（远端）</td></tr><tr><td>d[n]</td><td>麦克风采集音频（近端+回声）</td></tr><tr><td>y[n]</td><td>滤波器输出（回声估计）</td></tr><tr><td>e[n]</td><td>误差信号（理想是只有人声）</td></tr><tr><td>w[n]</td><td>滤波器权值，动态学习通道特性</td></tr><tr><td>μ</td><td>学习率，控制收敛速度和稳定性</td></tr></tbody></table><h2 id=下面是一个简化的-lmsleast-mean-squares算法的-python-实现用于音频信号的自适应滤波适合演示-aec-的基本过程>下面是一个简化的 LMS（Least Mean Squares）算法的 Python 实现，用于音频信号的自适应滤波，适合演示 AEC 的基本过程。<a hidden class=anchor aria-hidden=true href=#下面是一个简化的-lmsleast-mean-squares算法的-python-实现用于音频信号的自适应滤波适合演示-aec-的基本过程>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#66d9ef>as</span> plt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 模拟信号</span>
</span></span><span style=display:flex><span>np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>seed(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>N <span style=color:#f92672>=</span> <span style=color:#ae81ff>500</span>
</span></span><span style=display:flex><span>far_end <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>randn(N) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5</span>           <span style=color:#75715e># 远端信号（扬声器信号）</span>
</span></span><span style=display:flex><span>echo_path <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([<span style=color:#ae81ff>0.6</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.1</span>])         <span style=color:#75715e># 假设的回声路径（FIR滤波器系数）</span>
</span></span><span style=display:flex><span>echo <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>convolve(far_end, echo_path, mode<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;full&#39;</span>)[:N]
</span></span><span style=display:flex><span>near_end_voice <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>randn(N) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.1</span>     <span style=color:#75715e># 近端人声（麦克风真正需要的信号）</span>
</span></span><span style=display:flex><span>mic_signal <span style=color:#f92672>=</span> echo <span style=color:#f92672>+</span> near_end_voice            <span style=color:#75715e># 麦克风采到的是 回声 + 近端语音</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># LMS参数</span>
</span></span><span style=display:flex><span>M <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>                     <span style=color:#75715e># 滤波器长度（与echo_path一致）</span>
</span></span><span style=display:flex><span>mu <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.01</span>                 <span style=color:#75715e># 步长因子 / 学习率</span>
</span></span><span style=display:flex><span>w <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(M)           <span style=color:#75715e># 初始滤波器系数</span>
</span></span><span style=display:flex><span>output <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(N)      <span style=color:#75715e># 输出信号</span>
</span></span><span style=display:flex><span>error <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(N)       <span style=color:#75715e># 误差信号</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># LMS 主循环</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> n <span style=color:#f92672>in</span> range(M, N):
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> far_end[n<span style=color:#f92672>-</span>M:n][::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]                  <span style=color:#75715e># 远端信号窗口（倒序）</span>
</span></span><span style=display:flex><span>    y <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>dot(w, x)                          <span style=color:#75715e># 滤波器输出（回声估计）</span>
</span></span><span style=display:flex><span>    d <span style=color:#f92672>=</span> mic_signal[n]                         <span style=color:#75715e># 麦克风信号 = 回声 + 人声</span>
</span></span><span style=display:flex><span>    e <span style=color:#f92672>=</span> d <span style=color:#f92672>-</span> y                                 <span style=color:#75715e># 误差 = 麦克风信号 - 回声估计</span>
</span></span><span style=display:flex><span>    w <span style=color:#f92672>=</span> w <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> mu <span style=color:#f92672>*</span> e <span style=color:#f92672>*</span> x                    <span style=color:#75715e># LMS 更新公式</span>
</span></span><span style=display:flex><span>    output[n] <span style=color:#f92672>=</span> y
</span></span><span style=display:flex><span>    error[n] <span style=color:#f92672>=</span> e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 可视化：滤波器估计的回声、误差信号</span>
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>figure(figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>6</span>))
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>plot(mic_signal, label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Mic signal (Echo + Voice)&#34;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>plot(output, label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Estimated Echo (Filter Output)&#34;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>plot(error, label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Error (Voice only)&#34;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>legend()
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>title(<span style=color:#e6db74>&#34;LMS Adaptive Filter for Echo Cancellation&#34;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>xlabel(<span style=color:#e6db74>&#34;Sample&#34;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>grid(<span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>tight_layout()
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>show()
</span></span></code></pre></div><p><img alt=aec基本过程 loading=lazy src=/personal-site/posts/adaptive_filter_aec/figure.png></p><ul><li>x = far_end[n-M:n][::-1]：输入窗口，倒序（模拟 FIR 滤波器结构）。</li><li>y = np.dot(w, x)：滤波器输出，即当前估计的回声。</li><li>e = d - y：真实输入信号 - 估计回声 = 误差（期望只剩人声）。</li><li>正确划分：红点在直线一侧，蓝点在另一侧 ⇒ 线性可分</li><li>w = w + 2 * mu * e * x：LMS核心公式，根据误差和输入更新滤波器。</li></ul><h3 id=以下是一个详细注释的-c-语言实现版本用于演示-lms最小均方算法在回声消除中的应用这个示例简化了音频采集和播放部分重点在于展示-lms-核心逻辑便于你在嵌入式或实时音频系统中改写和集成>以下是一个详细注释的 C 语言实现版本，用于演示 LMS（最小均方）算法在回声消除中的应用。这个示例简化了音频采集和播放部分，重点在于展示 LMS 核心逻辑，便于你在嵌入式或实时音频系统中改写和集成。<a hidden class=anchor aria-hidden=true href=#以下是一个详细注释的-c-语言实现版本用于演示-lms最小均方算法在回声消除中的应用这个示例简化了音频采集和播放部分重点在于展示-lms-核心逻辑便于你在嵌入式或实时音频系统中改写和集成>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;math.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define N 500       </span><span style=color:#75715e>// 总样本数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define M 3         </span><span style=color:#75715e>// 滤波器长度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define MU 0.01f    </span><span style=color:#75715e>// 学习率
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 模拟数据初始化函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>generate_signals</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> far_end, <span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> mic_signal, <span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> near_end_voice, <span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> echo_path, <span style=color:#66d9ef>int</span> len) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> len; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 模拟远端信号（扬声器输出）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        far_end[i] <span style=color:#f92672>=</span> ((<span style=color:#66d9ef>float</span>)<span style=color:#a6e22e>rand</span>() <span style=color:#f92672>/</span> RAND_MAX <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.5f</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>1.0f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 模拟近端人声（小幅噪声）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        near_end_voice[i] <span style=color:#f92672>=</span> ((<span style=color:#66d9ef>float</span>)<span style=color:#a6e22e>rand</span>() <span style=color:#f92672>/</span> RAND_MAX <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.5f</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.2f</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 通过 FIR 卷积方式模拟回声路径
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> len; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        mic_signal[i] <span style=color:#f92672>=</span> near_end_voice[i]; <span style=color:#75715e>// 初始化为近端人声
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> M; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>-</span> j <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                mic_signal[i] <span style=color:#f92672>+=</span> echo_path[j] <span style=color:#f92672>*</span> far_end[i <span style=color:#f92672>-</span> j]; <span style=color:#75715e>// 添加模拟回声
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> far_end[N];         <span style=color:#75715e>// 扬声器信号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>float</span> near_end_voice[N]; <span style=color:#75715e>// 人声（麦克风中希望保留的成分）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>float</span> mic_signal[N];      <span style=color:#75715e>// 麦克风采到的信号（人声 + 回声）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>float</span> echo_path[M] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0.6f</span>, <span style=color:#ae81ff>0.3f</span>, <span style=color:#ae81ff>0.1f</span>}; <span style=color:#75715e>// 模拟的回声通道
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> w[M] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};         <span style=color:#75715e>// 滤波器系数（自适应学习）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>float</span> output[N] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};    <span style=color:#75715e>// 滤波器输出（估计的回声）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>float</span> error[N] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};     <span style=color:#75715e>// 误差信号（目标是只保留人声）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 生成输入数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>generate_signals</span>(far_end, mic_signal, near_end_voice, echo_path, N);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// LMS 核心算法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> M; n <span style=color:#f92672>&lt;</span> N; n<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> x[M];   <span style=color:#75715e>// 输入窗口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>float</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>// 滤波器输出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>float</span> e;      <span style=color:#75715e>// 当前误差
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 构造输入向量（倒序）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> M; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            x[i] <span style=color:#f92672>=</span> far_end[n <span style=color:#f92672>-</span> i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 滤波器输出 y(n) = w(n)^T * x(n)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> M; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            y <span style=color:#f92672>+=</span> w[i] <span style=color:#f92672>*</span> x[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 误差 e(n) = d(n) - y(n)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        e <span style=color:#f92672>=</span> mic_signal[n] <span style=color:#f92672>-</span> y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// LMS 更新 w(n+1) = w(n) + 2 * mu * e(n) * x(n)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> M; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            w[i] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> MU <span style=color:#f92672>*</span> e <span style=color:#f92672>*</span> x[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 保存输出和误差
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        output[n] <span style=color:#f92672>=</span> y;
</span></span><span style=display:flex><span>        error[n] <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 打印最后的滤波器系数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Final filter coefficients:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> M; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;w[%d] = %f</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i, w[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 打印前几十个误差信号样本（可视化用）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>First 20 error samples (near-end voice only):</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>20</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d: %f</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i, error[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>📌 实现要点说明</p><table><thead><tr><th>元素</th><th>说明</th></tr></thead><tbody><tr><td>echo_path[]</td><td>用于模拟回声传播通道，真实系统中是未知的，由 w[] 学习逼近。</td></tr><tr><td>far_end[]</td><td>远端发送来的音频，被扬声器播放，会被麦克风"听到"形成回声。</td></tr><tr><td>mic_signal[]</td><td>麦克风接收的音频，包含远端回声和近端说话声（需要保留）。</td></tr><tr><td>w[]</td><td>自适应滤波器的系数，迭代更新，目标是使 output[] 接近实际回声，从而让 error[] 剩下近端语音。</td></tr><tr><td>MU</td><td>步长（学习率），控制收敛速度与稳定性，太大会发散，太小收敛慢。</td></tr></tbody></table><p>✅ 一、自适应滤波器结构在代码中的体现</p><p>在 C 代码中，自适应滤波器是以 FIR（有限脉冲响应）结构 + LMS 更新算法 实现的。我们来分解两部分：</p><ol><li>滤波器结构体现（FIR 结构）</li></ol><p>在这段代码里：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> M; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    x[i] <span style=color:#f92672>=</span> far_end[n <span style=color:#f92672>-</span> i];   <span style=color:#75715e>// 输入窗口：延迟线结构
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> M; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    y <span style=color:#f92672>+=</span> w[i] <span style=color:#f92672>*</span> x[i];        <span style=color:#75715e>// FIR 滤波器加权输出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>这就实现了一个 M 阶的 FIR 滤波器：</p><ul><li>x[i] 是远端信号延迟线（delay line）</li><li>w[i] 是自适应滤波器系数（adaptive taps）</li><li>输出 y 是回声估计</li></ul><ol start=2><li>滤波器更新（LMS 自适应）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>e <span style=color:#f92672>=</span> mic_signal[n] <span style=color:#f92672>-</span> y;             <span style=color:#75715e>// 误差 = 实际麦克风 - 滤波器估计回声
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> M; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    w[i] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> MU <span style=color:#f92672>*</span> e <span style=color:#f92672>*</span> x[i];     <span style=color:#75715e>// LMS 核心更新公式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>这部分是 LMS 学习过程：根据误差信号来调整每一个滤波器权重。</p><p>总结：</p><ul><li>FIR 结构是固定的：x 和 w 做加权和</li><li>自适应发生在权重 w 上：它不断调整以最小化误差</li></ul><p>✅ 二、引入 NLMS（Normalized LMS）以增强稳定性</p><p>🧠 问题：LMS 的稳定性受输入信号能量变化影响</p><p>在原始 LMS 中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>w[i] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> MU <span style=color:#f92672>*</span> e <span style=color:#f92672>*</span> x[i];
</span></span></code></pre></div><p>如果 x[i] 很大（信号能量高），更新步长可能过大，导致发散。</p><p>🔧 解决：引入 NLMS（Normalized LMS）</p><p>NLMS 核心思想：对每次更新除以输入信号的能量，以实现归一化。</p><p>✅ NLMS 更新公式：</p><p>$$
w(n+1) = w(n) + \mu \cdot \frac{e(n) \cdot x(n)}{\delta + |x(n)|^2}
$$</p><ul><li>\mu：步长（一般小于 1）</li><li>\delta：微小常数，防止除 0</li><li>|x(n)|^2：当前输入信号能量（即 x 的平方和）</li></ul><p>✅ C 语言替代 LMS 更新段（加入 NLMS）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>float</span> norm <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0001f</span>;  <span style=color:#75715e>// δ，防止除 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 计算输入向量的能量（平方和）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> M; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    norm <span style=color:#f92672>+=</span> x[i] <span style=color:#f92672>*</span> x[i];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// NLMS 更新
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> M; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    w[i] <span style=color:#f92672>+=</span> MU <span style=color:#f92672>*</span> e <span style=color:#f92672>*</span> x[i] <span style=color:#f92672>/</span> norm;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>优点：</p><ul><li>在远端信号强弱变化时依然稳定</li><li>更快收敛、更少抖动，常用于语音通话中的 AEC</li></ul><p>✅ 三、双讲（Double-Talk）检测与保护机制</p><p>🧠 问题：当双方同时讲话（即近端和远端都有声音），</p><p>麦克风中不再只有回声，误差信号中含有近端人声。</p><p>如果 LMS/NLMS 在此时还继续更新权重，可能会误把人声当作回声学习进去，导致近端语音也被"消除"。
🛡️ 解决方法：双讲检测 + 更新冻结</p><p>典型策略：</p><ol><li>检测双讲（Double-Talk Detector）
比较：</li></ol><ul><li>回声估计误差 |e(n)|</li><li>麦克风能量 |d(n)|</li><li>远端信号能量 |x(n)|
如果误差较大，但远端信号不强，说明有近端人声，可能是双讲。</li></ul><ol start=2><li>冻结滤波器更新（Skip LMS/NLMS update）</li></ol><p>✅ 示例伪代码（简化）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>float</span> mic_power <span style=color:#f92672>=</span> mic_signal[n] <span style=color:#f92672>*</span> mic_signal[n];
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> far_power <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> M; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    far_power <span style=color:#f92672>+=</span> x[i] <span style=color:#f92672>*</span> x[i];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 简单阈值检测（也可以用协方差检测等更复杂方法）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (mic_power <span style=color:#f92672>&gt;</span> THRESHOLD <span style=color:#f92672>&amp;&amp;</span> far_power <span style=color:#f92672>&lt;</span> LOW_ENERGY_THRESH) {
</span></span><span style=display:flex><span>    freeze_update <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// 双讲，暂停自适应
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    freeze_update <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>freeze_update) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 执行 LMS/NLMS 更新
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>注：这只是最简单的检测方法，实际产品中常用 Geigel 算法、双通道协方差估计 等更鲁棒方法。</p><p>✅ 总结结构图</p><pre tabindex=0><code>     +---------------------+
 Far-End |      x[n]          |&lt;----------+
 Signal  +---------------------+          |
         | FIR Filter (w[n])   |          |
         +---------------------+          |
                         | y[n]           |
                         v                |
         +---------------------+          |
         | Error: e[n]=d[n]-y[n]|          |
         +---------------------+          |
                         |                |
                         v                |
          +--------------------------+    |
          |  Double-Talk Detector    |----+
          +--------------------------+
                         |
                Freeze Update?
                         |
                         v
              +------------------+
              | LMS/NLMS Update  |
              +------------------+
                         |
                    w[n+1]
</code></pre><p>下面是一个完整的 C 语言实现，结合了以下三部分：</p><ol><li>✅ FIR 结构 + NLMS（归一化 LMS）更新公式</li><li>✅ 双讲检测（Double-Talk Detection）</li><li>✅ 检测期间冻结更新（保护滤波器）</li></ol><p>⸻</p><p>✅ 完整 C 语言实现：NLMS + 双讲检测保护</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;math.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define FRAME_LEN 160       </span><span style=color:#75715e>// 每帧样本数（10ms @ 16kHz）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define FILTER_LEN 128      </span><span style=color:#75715e>// 滤波器阶数（tap数）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define MU         0.8f     </span><span style=color:#75715e>// 步长参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define EPSILON    1e-6f    </span><span style=color:#75715e>// 防止除以0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define DTD_THRESH 2.0f     </span><span style=color:#75715e>// 双讲检测阈值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 模拟数据接口（实际使用中应连接声卡/录音数据）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>get_far_end_sample</span>(<span style=color:#66d9ef>int</span> n);
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>get_mic_sample</span>(<span style=color:#66d9ef>int</span> n);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// NLMS + DTD 主处理函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>aec_process</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> mic_signal, <span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> far_end_signal, <span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> out_signal, <span style=color:#66d9ef>int</span> len) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> w[FILTER_LEN] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};         <span style=color:#75715e>// 滤波器权重初始化为 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>float</span> x[FILTER_LEN] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};         <span style=color:#75715e>// 输入延迟线（远端）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>float</span> e <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;                    <span style=color:#75715e>// 误差信号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>float</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;                    <span style=color:#75715e>// 滤波器输出（回声估计）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; n <span style=color:#f92672>&lt;</span> len; n<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 滚动延迟线
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> FILTER_LEN <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>; i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>            x[i] <span style=color:#f92672>=</span> x[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        x[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> far_end_signal[n];  <span style=color:#75715e>// 新样本插入最前端
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 滤波器加权和（回声估计）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> FILTER_LEN; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            y <span style=color:#f92672>+=</span> w[i] <span style=color:#f92672>*</span> x[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算误差 e(n) = d(n) - y(n)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        e <span style=color:#f92672>=</span> mic_signal[n] <span style=color:#f92672>-</span> y;
</span></span><span style=display:flex><span>        out_signal[n] <span style=color:#f92672>=</span> e;  <span style=color:#75715e>// 输出误差信号（即消除回声后的信号）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// === 双讲检测 ===
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>float</span> mic_power <span style=color:#f92672>=</span> mic_signal[n] <span style=color:#f92672>*</span> mic_signal[n];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> far_power <span style=color:#f92672>=</span> EPSILON;  <span style=color:#75715e>// 防止除0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> FILTER_LEN; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            far_power <span style=color:#f92672>+=</span> x[i] <span style=color:#f92672>*</span> x[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> double_talk <span style=color:#f92672>=</span> (mic_power <span style=color:#f92672>/</span> far_power <span style=color:#f92672>&gt;</span> DTD_THRESH) <span style=color:#f92672>?</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// === NLMS 更新权重 ===
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>double_talk) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> FILTER_LEN; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                w[i] <span style=color:#f92672>+=</span> (MU <span style=color:#f92672>*</span> e <span style=color:#f92672>*</span> x[i]) <span style=color:#f92672>/</span> far_power;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>✅ 每个部分解释：</p><p>🎯 滤波器结构</p><ul><li>x[i] 是远端信号延迟线</li><li>w[i] 是滤波器系数，表示回声路径响应</li><li>y 是估计出的回声信号</li></ul><p>🎯 NLMS 更新核心：</p><p>$$
w_i(n+1) = w_i(n) + \mu \cdot \frac{e(n) \cdot x_i(n)}{\varepsilon + |x(n)|^2}
$$</p><p>🎯 双讲检测逻辑：
mic_power / far_power > DTD_THRESH</p><ul><li>当麦克风信号比远端信号强很多时，说明可能是用户在说话（双讲）</li><li>此时跳过权重更新</li></ul><p>下面是一个完整的可运行 Python 程序，模拟了 NLMS 回声消除系统，包括：</p><ul><li>模拟远端语音（正弦信号）</li><li>模拟真实回声路径（FIR 滤波器卷积）</li><li>加入本地讲话（近端人声）</li><li>使用 NLMS 算法自适应估计回声路径并消除回声</li><li>可视化：<ul><li>原始远端信号</li><li>麦克风信号（含回声 + 本地讲话）</li><li>回声抵消后输出</li><li>滤波器估计过程</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#66d9ef>as</span> plt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 参数配置</span>
</span></span><span style=display:flex><span>fs <span style=color:#f92672>=</span> <span style=color:#ae81ff>8000</span>                         <span style=color:#75715e># 采样率</span>
</span></span><span style=display:flex><span>duration <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>                    <span style=color:#75715e># 信号持续时间（秒）</span>
</span></span><span style=display:flex><span>N <span style=color:#f92672>=</span> int(fs <span style=color:#f92672>*</span> duration)            <span style=color:#75715e># 采样点数</span>
</span></span><span style=display:flex><span>filter_len <span style=color:#f92672>=</span> <span style=color:#ae81ff>64</span>                   <span style=color:#75715e># 回声路径长度</span>
</span></span><span style=display:flex><span>mu <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.1</span>                          <span style=color:#75715e># NLMS 步长</span>
</span></span><span style=display:flex><span>eps <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e-8</span>                        <span style=color:#75715e># 防止除零</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1. 模拟远端信号（sin + 噪声）</span>
</span></span><span style=display:flex><span>t <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>linspace(<span style=color:#ae81ff>0</span>, duration, N)
</span></span><span style=display:flex><span>far_end <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>sin(<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>pi <span style=color:#f92672>*</span> <span style=color:#ae81ff>440</span> <span style=color:#f92672>*</span> t) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.05</span> <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>randn(N)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 模拟真实回声路径</span>
</span></span><span style=display:flex><span>true_echo_path <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>randn(filter_len) <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>hanning(filter_len)
</span></span><span style=display:flex><span>true_echo_path <span style=color:#f92672>/=</span> np<span style=color:#f92672>.</span>linalg<span style=color:#f92672>.</span>norm(true_echo_path)  <span style=color:#75715e># 单位化</span>
</span></span><span style=display:flex><span>echo_signal <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>convolve(far_end, true_echo_path, mode<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;full&#39;</span>)[:N]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. 模拟近端人声（后半段双讲）</span>
</span></span><span style=display:flex><span>near_end <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(N)
</span></span><span style=display:flex><span>near_end[N <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>:] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.3</span> <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>sin(<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>pi <span style=color:#f92672>*</span> <span style=color:#ae81ff>220</span> <span style=color:#f92672>*</span> t[N <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>:])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 4. 麦克风接收信号 = 回声 + 近端人声</span>
</span></span><span style=display:flex><span>mic_signal <span style=color:#f92672>=</span> echo_signal <span style=color:#f92672>+</span> near_end
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 5. 初始化自适应滤波器参数</span>
</span></span><span style=display:flex><span>w <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(filter_len)     <span style=color:#75715e># 自适应滤波器权重</span>
</span></span><span style=display:flex><span>x_buf <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(filter_len) <span style=color:#75715e># 输入缓存</span>
</span></span><span style=display:flex><span>out_signal <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(N)     <span style=color:#75715e># 回声抵消后的输出</span>
</span></span><span style=display:flex><span>error_curve <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(N)    <span style=color:#75715e># 残差信号（误差）</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 6. NLMS + DTD 主循环</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> n <span style=color:#f92672>in</span> range(N):
</span></span><span style=display:flex><span>    <span style=color:#75715e># 更新输入缓存</span>
</span></span><span style=display:flex><span>    x_buf[<span style=color:#ae81ff>1</span>:] <span style=color:#f92672>=</span> x_buf[:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    x_buf[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> far_end[n]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 滤波器输出估计的回声</span>
</span></span><span style=display:flex><span>    y_hat <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>dot(w, x_buf)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 实际误差信号（麦克风 - 估计回声）</span>
</span></span><span style=display:flex><span>    e <span style=color:#f92672>=</span> mic_signal[n] <span style=color:#f92672>-</span> y_hat
</span></span><span style=display:flex><span>    error_curve[n] <span style=color:#f92672>=</span> e
</span></span><span style=display:flex><span>    out_signal[n] <span style=color:#f92672>=</span> e  <span style=color:#75715e># 去回声后的输出</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 简单双讲检测（energy 比值法）</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> np<span style=color:#f92672>.</span>dot(x_buf, x_buf) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.001</span> <span style=color:#f92672>and</span> np<span style=color:#f92672>.</span>abs(e) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1.0</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># NLMS 权重更新</span>
</span></span><span style=display:flex><span>        norm_factor <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>dot(x_buf, x_buf) <span style=color:#f92672>+</span> eps
</span></span><span style=display:flex><span>        w <span style=color:#f92672>+=</span> (mu <span style=color:#f92672>/</span> norm_factor) <span style=color:#f92672>*</span> e <span style=color:#f92672>*</span> x_buf
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 7. 绘图显示结果</span>
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>figure(figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>subplot(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>title(<span style=color:#e6db74>&#34;Far-end Signal (Speaker Output)&#34;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>plot(far_end)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>ylabel(<span style=color:#e6db74>&#34;Amplitude&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>subplot(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>title(<span style=color:#e6db74>&#34;Mic Signal (Echo + Near-end Speech)&#34;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>plot(mic_signal)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>ylabel(<span style=color:#e6db74>&#34;Amplitude&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>subplot(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>title(<span style=color:#e6db74>&#34;Output after Echo Cancellation&#34;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>plot(out_signal)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>ylabel(<span style=color:#e6db74>&#34;Amplitude&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>subplot(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>title(<span style=color:#e6db74>&#34;Estimated Echo Path (Filter Coefficients)&#34;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>plot(w, label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Estimated&#34;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>plot(true_echo_path, <span style=color:#e6db74>&#39;--&#39;</span>, label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;True&#34;</span>, alpha<span style=color:#f92672>=</span><span style=color:#ae81ff>0.7</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>legend()
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>xlabel(<span style=color:#e6db74>&#34;Taps&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>tight_layout()
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>show()
</span></span></code></pre></div><h2 id=总结与实践建议->总结与实践建议 💡<a hidden class=anchor aria-hidden=true href=#总结与实践建议->#</a></h2><ol><li><p><strong>系统设计考虑</strong></p><ul><li>选择合适的滤波器长度（权衡计算量和效果）</li><li>合理设置学习率（权衡收敛速度和稳定性）</li><li>考虑双讲检测机制</li></ul></li><li><p><strong>优化方向</strong></p><ul><li>非线性回声处理</li><li>自适应学习率调整</li><li>双讲场景优化</li></ul></li><li><p><strong>实际应用注意事项</strong></p><ul><li>系统延迟补偿</li><li>环境变化检测</li><li>计算资源优化</li></ul></li></ol><hr><p><em>参考文献与延伸阅读：</em></p><ol><li>Haykin, S. &ldquo;Adaptive Filter Theory&rdquo;</li><li>Benesty, J. &ldquo;Adaptive Signal Processing&rdquo;</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://xuyafei.github.io/personal-site/tags/%E8%A7%86%E9%A2%91%E4%BC%9A%E8%AE%AE/>视频会议</a></li><li><a href=https://xuyafei.github.io/personal-site/tags/%E8%AF%AD%E9%9F%B3%E5%A4%84%E7%90%86/>语音处理</a></li><li><a href=https://xuyafei.github.io/personal-site/tags/%E6%BB%A4%E6%B3%A2%E5%99%A8/>滤波器</a></li><li><a href=https://xuyafei.github.io/personal-site/tags/python/>Python</a></li></ul><nav class=paginav><a class=prev href=https://xuyafei.github.io/personal-site/posts/detailed-explanation-of-linearly-separable-binary-classification-problem/><span class=title>« Prev</span><br><span>线性可分的二分类问题详解</span>
</a><a class=next href=https://xuyafei.github.io/personal-site/posts/nonlinear_distortion_compensation/><span class=title>Next »</span><br><span>音频系统中的非线性失真补偿技术详解</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 自适应滤波器与回声消除（AEC）原理详解 on x" href="https://x.com/intent/tweet/?text=%e8%87%aa%e9%80%82%e5%ba%94%e6%bb%a4%e6%b3%a2%e5%99%a8%e4%b8%8e%e5%9b%9e%e5%a3%b0%e6%b6%88%e9%99%a4%ef%bc%88AEC%ef%bc%89%e5%8e%9f%e7%90%86%e8%af%a6%e8%a7%a3&amp;url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fadaptive_filter_aec%2f&amp;hashtags=%e8%a7%86%e9%a2%91%e4%bc%9a%e8%ae%ae%2c%e8%af%ad%e9%9f%b3%e5%a4%84%e7%90%86%2c%e6%bb%a4%e6%b3%a2%e5%99%a8%2cPython"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 自适应滤波器与回声消除（AEC）原理详解 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fadaptive_filter_aec%2f&amp;title=%e8%87%aa%e9%80%82%e5%ba%94%e6%bb%a4%e6%b3%a2%e5%99%a8%e4%b8%8e%e5%9b%9e%e5%a3%b0%e6%b6%88%e9%99%a4%ef%bc%88AEC%ef%bc%89%e5%8e%9f%e7%90%86%e8%af%a6%e8%a7%a3&amp;summary=%e8%87%aa%e9%80%82%e5%ba%94%e6%bb%a4%e6%b3%a2%e5%99%a8%e4%b8%8e%e5%9b%9e%e5%a3%b0%e6%b6%88%e9%99%a4%ef%bc%88AEC%ef%bc%89%e5%8e%9f%e7%90%86%e8%af%a6%e8%a7%a3&amp;source=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fadaptive_filter_aec%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 自适应滤波器与回声消除（AEC）原理详解 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fadaptive_filter_aec%2f&title=%e8%87%aa%e9%80%82%e5%ba%94%e6%bb%a4%e6%b3%a2%e5%99%a8%e4%b8%8e%e5%9b%9e%e5%a3%b0%e6%b6%88%e9%99%a4%ef%bc%88AEC%ef%bc%89%e5%8e%9f%e7%90%86%e8%af%a6%e8%a7%a3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 自适应滤波器与回声消除（AEC）原理详解 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fadaptive_filter_aec%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 自适应滤波器与回声消除（AEC）原理详解 on whatsapp" href="https://api.whatsapp.com/send?text=%e8%87%aa%e9%80%82%e5%ba%94%e6%bb%a4%e6%b3%a2%e5%99%a8%e4%b8%8e%e5%9b%9e%e5%a3%b0%e6%b6%88%e9%99%a4%ef%bc%88AEC%ef%bc%89%e5%8e%9f%e7%90%86%e8%af%a6%e8%a7%a3%20-%20https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fadaptive_filter_aec%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 自适应滤波器与回声消除（AEC）原理详解 on telegram" href="https://telegram.me/share/url?text=%e8%87%aa%e9%80%82%e5%ba%94%e6%bb%a4%e6%b3%a2%e5%99%a8%e4%b8%8e%e5%9b%9e%e5%a3%b0%e6%b6%88%e9%99%a4%ef%bc%88AEC%ef%bc%89%e5%8e%9f%e7%90%86%e8%af%a6%e8%a7%a3&amp;url=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fadaptive_filter_aec%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 自适应滤波器与回声消除（AEC）原理详解 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e8%87%aa%e9%80%82%e5%ba%94%e6%bb%a4%e6%b3%a2%e5%99%a8%e4%b8%8e%e5%9b%9e%e5%a3%b0%e6%b6%88%e9%99%a4%ef%bc%88AEC%ef%bc%89%e5%8e%9f%e7%90%86%e8%af%a6%e8%a7%a3&u=https%3a%2f%2fxuyafei.github.io%2fpersonal-site%2fposts%2fadaptive_filter_aec%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://xuyafei.github.io/personal-site/>我的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>