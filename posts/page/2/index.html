<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 我的博客</title>
<meta name=keywords content><meta name=description content="Posts - 我的博客"><meta name=author content><link rel=canonical href=https://xuyafei.github.io/personal-site/posts/><link crossorigin=anonymous href=/personal-site/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://xuyafei.github.io/personal-site/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xuyafei.github.io/personal-site/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://xuyafei.github.io/personal-site/favicon-32x32.png><link rel=apple-touch-icon href=https://xuyafei.github.io/personal-site/apple-touch-icon.png><link rel=mask-icon href=https://xuyafei.github.io/personal-site/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://xuyafei.github.io/personal-site/posts/index.xml><link rel=alternate hreflang=en href=https://xuyafei.github.io/personal-site/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAYQHy+K8nqKdr1EzvFzSQC+TAXx6gNQgoRxKtj+P9vvCCQTRWiV crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})})</script><script>MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta property="og:url" content="https://xuyafei.github.io/personal-site/posts/"><meta property="og:site_name" content="我的博客"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://xuyafei.github.io/personal-site/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xuyafei.github.io/personal-site/ accesskey=h title="我的博客 (Alt + H)">我的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xuyafei.github.io/personal-site/categories/ title=分类><span>分类</span></a></li><li><a href=https://xuyafei.github.io/personal-site/tags/ title=标签><span>标签</span></a></li><li><a href=https://xuyafei.github.io/personal-site/archives/ title=归档><span>归档</span></a></li><li><a href=https://xuyafei.github.io/personal-site/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://xuyafei.github.io/personal-site/>Home</a></div><h1>Posts
<a href=/personal-site/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>自适应滤波器与回声消除（AEC）原理详解</h2></header><div class=entry-content><p>自适应滤波器与回声消除（AEC）原理详解 核心原理 自适应滤波器之所以能够用于回声消除（AEC），核心原因在于它可以动态估计并还原"回声路径"，然后将这一估计出的回声信号从麦克风输入中减去，从而实现回声的抑制甚至消除。
原理简述 🧠 在回声消除系统中，自适应滤波器会根据扬声器输出（远端信号）来预测它在麦克风中会出现的形式（回声），然后从实际的麦克风输入中减去这个预测的信号。
基本信号模型 📦 设：
x(n)：远端信号（扬声器播放） d(n)：麦克风信号（含近端语音 + 回声） y(n)：自适应滤波器输出（回声的估计） e(n)：误差信号（d(n) - y(n)，理论上就是近端语音） 自适应滤波器目标是： $$ y(n) ≈ 回声分量 = x(n) * h(n) $$ 其中 h(n) 是回声路径（扬声器到麦克风的模拟传输特性，可能包含混响、设备响应等）。
最终： $$ e(n) = d(n) - y(n) ≈ 近端语音 $$
自适应滤波器工作机制 ⚙️ 使用如 LMS（Least Mean Square）或 NLMS 算法，通过最小化 e(n) 的能量来不断更新滤波器系数 当估计越来越准时，y(n) 趋近于回声，e(n) 就接近纯近端语音 为什么它能成功 🔍 因果建模：回声路径是因果的，即某时刻的扬声器输出 x(n) 会在未来若干毫秒后以回声的形式出现在麦克风中 线性建模有效：大多数设备在一定条件下，其声学路径可以较好地用线性模型（FIR 滤波器）表示 反馈优化：误差信号 e(n) 反馈用于更新滤波器参数，不断逼近真实的回声路径响应 挑战情况 🚫 双讲问题：远近端同时说话时，远端信号和近端语音混合后，误差信号不再纯粹代表回声误差，滤波器容易被误导 非线性失真：如设备中存在非线性放大、限幅等，使得简单线性滤波器难以完全建模 LMS 算法详解 LMS（Least Mean Squares，最小均方）算法是一种自适应滤波算法，它通过不断调整滤波器的系数，使得输出信号尽可能逼近目标信号（期望信号）。
...</p></div><footer class=entry-footer><span title='2024-04-22 00:00:00 +0000 UTC'>April 22, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;徐亚飞</footer><a class=entry-link aria-label="post link to 自适应滤波器与回声消除（AEC）原理详解" href=https://xuyafei.github.io/personal-site/posts/adaptive_filter_aec/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>音频系统中的非线性失真补偿技术详解</h2></header><div class=entry-content><p>非线性失真补偿技术概述 非线性失真补偿技术（nonlinear distortion compensation）主要用于在音频通信或音频处理系统中，修正由于放大器、扬声器、ADC/DAC 等系统部件引入的非线性畸变。这类失真在高质量语音通话、AEC（回声消除）、降噪、回放增强等领域非常关键。
什么是非线性失真？ 线性系统 满足两个条件：
齐次性：输入加倍，输出也加倍（如 y = 2x → 2y = 2·2x） 叠加性：两个输入信号的响应等于各自响应之和（如 A + B → 输出A + 输出B） 非线性失真 当系统违反这两个原则时就发生非线性，例如：
放大器过载（削波 Clipping） 扬声器磁饱和、谐波产生 数字信号压缩编码（Companding） D/A 或 A/D 分辨率太低 常见非线性失真类型 类型 表现形式 削波（Clipping） 输入过大被强行"截断" 谐波失真 多出原频率整数倍的频率成分 交调失真 多个频率信号相互干扰，产生额外频率 动态压缩失真 某些频率范围失真更严重 为什么 AEC/降噪时要考虑非线性失真？ 问题 AEC 使用自适应滤波器估计回声路径，但这个滤波器默认是线性的 FIR 滤波器，如果回声路径（如扬声器）存在非线性行为（如削波、失真），那你无法用线性滤波器准确估计它 → 导致残留回声。
非线性失真补偿技术分类 1. 预失真（Pre-Distortion）技术 原理：在信号送入非线性系统（如功放）前，先对其"预处理"一下，反向建模非线性，从而抵消即将发生的畸变。 应用：音频播放、无线通信前端 2. Volterra 滤波器 一种能建模非线性系统的高级滤波器（包含多阶项，如二阶、三阶互作用） 比传统 FIR 滤波器更复杂，但能表达非线性响应 y(n) = Σ h1[i]·x(n−i) + ΣΣ h2[i][j]·x(n−i)·x(n−j) + ... 3. 基于机器学习的建模 使用 DNN、LSTM、Transformers 等网络学习非线性映射关系 适合对"系统输出"和"干净目标"建模残差，进行非线性补偿 4. 非线性回声消除（NLAEC） 针对回声路径为非线性的场景，如手机扬声器压缩、蓝牙耳机饱和等 会联合使用： 多通道滤波器组 非线性特征提取（如平方、对数、激活函数） 自适应更新策略（NLMS+VAF、RLS变体） 应用中的策略示例 AEC 中的增强路径建模（LMS 估计基础上加入非线性残差估计） RNNoise / DeepFilterNet 之类的系统中，加入 DNN 估计非线性失真分量并减去 听觉模型补偿（加入感知失真度量，结合人耳模型做修正） WebRTC 中的非线性失真处理 背景：WebRTC 中非线性失真的本质 WebRTC 的 AEC 假设系统是线性的，即使用 NLMS 或 Frequency-domain LMS 去估计回声路径。但实际设备中的扬声器/功放常存在削波、饱和等现象，导致：
...</p></div><footer class=entry-footer><span title='2024-04-22 00:00:00 +0000 UTC'>April 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;徐亚飞</footer><a class=entry-link aria-label="post link to 音频系统中的非线性失真补偿技术详解" href=https://xuyafei.github.io/personal-site/posts/nonlinear_distortion_compensation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>全面解析C++中类(class)与结构体(struct)的区别</h2></header><div class=entry-content><p>全面解析C++中类(class)与结构体(struct)的区别 一、最核心区别：默认访问控制 在C++中，class和struct的唯一语法区别在于默认访问权限：
// 结构体示例 struct MyStruct { int x; // 默认public访问权限 void foo() {} // 默认public }; // 类示例 class MyClass { int x; // 默认private访问权限 void bar() {} // 默认private }; 继承时的默认权限 struct D1 : Base {}; // 默认public继承 class D2 : Base {}; // 默认private继承 二、历史起源与设计哲学 特性 struct (结构体) class (类) 诞生时间 源自C语言 C++新增概念 设计初衷 数据打包聚合 面向对象封装 核心理念 “这是一个数据集合” “这是一个具有行为的对象” 三、实际开发中的惯用准则 应该使用struct的场景 纯数据集合 struct Color { uint8_t r, g, b, a; // 全部公有 }; 简单值类型 struct Point { double x, y; // 可以包含简单方法 double distance() const { return sqrt(x*x + y*y); } }; 接口配置参数 struct Config { string title; int width; int height; }; 应该使用class的场景 需要封装的业务对象 class BankAccount { private: string owner_; double balance_; public: void deposit(double amount) { /*...*/ } bool withdraw(double amount) { /*...*/ } }; 需要复杂生命周期的资源管理 class DatabaseConnection { Connection* conn_; public: explicit DatabaseConnection(string url) { /*...*/ } ~DatabaseConnection() { /* 自动释放资源 */ } }; 需要多态继承的体系 class Shape { public: virtual double area() const = 0; }; 四、技术能力完全对比 语言特性 struct支持情况 class支持情况 示例代码 成员变量 ✓ ✓ int x; 成员函数 ✓ ✓ void f() {} 访问控制 ✓ ✓ public: 构造函数/析构函数 ✓ ✓ ~T() {} 运算符重载 ✓ ✓ T operator+() 继承 ✓ ✓ struct D : B {}; 虚函数 ✓ ✓ virtual void f() = 0; 友元 ✓ ✓ friend class F; 模板 ✓ ✓ template&lt;typename T> 五、模板元编程中的差异实践 struct在元编程中的优势 // 类型特征检查通常用struct实现 template&lt;typename T> struct is_pointer { static constexpr bool value = false; }; template&lt;typename T> struct is_pointer&lt;T*> { static constexpr bool value = true; }; // 使用示例 static_assert(is_pointer&lt;int*>::value, "必须是指针类型"); 原因分析 元编程通常需要公开所有成员 避免频繁写public关键字 符合"数据即接口"的元编程哲学 六、内存布局完全一致 struct S { int a; double b; }; class C { int a; double b; }; // 验证内存布局相同 static_assert(sizeof(S) == sizeof(C)); static_assert(offsetof(S, b) == offsetof(C, b)); 继承时的特殊情况 struct A { int x; }; class B : A { int y; }; // 私有继承可能影响空基类优化 七、与C语言的兼容性细节 特性 C struct C++ struct 类型声明 必须带struct关键字 可直接作为类型名 成员函数 不支持 支持 访问控制 无 支持 静态成员 不支持 支持 C/C++混合编程注意事项： #ifdef __cplusplus extern "C" { #endif // 确保C兼容的布局 struct CCompatStruct { int x; float y; }; #ifdef __cplusplus } #endif 八、现代C++中的最佳实践 结构化绑定(struct适用) struct Employee { string name; int id; double salary; }; auto [name, id, salary] = getEmployee(); // C++17结构化绑定 类的不变量维护(class适用) class Temperature { double kelvin_; public: void setCelsius(double c) { kelvin_ = c + 273.15; assert(kelvin_ > 0 && "绝对温度不能为负"); } }; 移动语义支持(两者均可) struct Buffer { vector&lt;uint8_t> data; Buffer(Buffer&& other) noexcept : data(std::move(other.data)) {} }; class FileHandle { FILE* handle_; public: FileHandle(FileHandle&& other) : handle_(other.handle_) { other.handle_ = nullptr; } }; 九、完整特性对比表格 对比维度 struct class 基本性质 关键字 struct class 默认访问权限 public private 默认继承方式 public private 设计用途 数据聚合 首选 可用但不惯用 对象封装 可用但不惯用 首选 接口定义 适合POD接口 适合抽象接口 语法特性 成员函数 支持 支持 虚函数 支持 支持 友元声明 支持 支持 其他特性 模板元编程 更常用 较少使用 C兼容性 部分兼容 不兼容 内存布局 与class相同 与struct相同 结构化绑定 天然适合 需要显式tuple接口 十、经典面试题解析 Q1：以下代码有何问题？ class Circle { double radius; public: double area() const { return 3.14 * radius * radius; } }; struct Square { double side; double area() const { return side * side; } }; 答案：
...</p></div><footer class=entry-footer><span title='2025-04-26 00:14:00 +0800 +0800'>April 26, 2025</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to 全面解析C++中类(class)与结构体(struct)的区别" href=https://xuyafei.github.io/personal-site/posts/cpp-class-vs-struct/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>KaTeX 测试</h2></header><div class=entry-content><p>这是一个测试页面，包含行内公式和块级公式。
✅ 行内公式示例： 牛顿第二定律：$F = ma$，这个公式描述了力和加速度的关系。
✅ 块级公式示例： 下面是偏导数的定义：
$$ \frac{\partial f}{\partial x_i} = \lim_{h \to 0} \frac{f(x_1, \dots, x_i + h, \dots, x_n) - f(x_1, \dots, x_n)}{h} $$</p></div><footer class=entry-footer><span title='2025-04-17 00:00:00 +0000 UTC'>April 17, 2025</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to KaTeX 测试" href=https://xuyafei.github.io/personal-site/posts/katex-test/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://xuyafei.github.io/personal-site/posts/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://xuyafei.github.io/personal-site/>我的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>