[{"content":"回归分析基础讲解与实战代码（附图表展示） 本文将详细讲解监督学习中的回归问题，特别是线性回归，包括其数学原理、编程实现以及如何通过图像分析模型表现，适合初学者快速入门，也适合有经验的开发者参考测试。\n一、什么是回归？ 在监督学习中，回归是一种用于预测连续值的方法。\n通俗地说，就是：\n给你一堆\u0026quot;输入-输出\u0026quot;的样本数据，让你学习出一个数学表达式，这个表达式能用来预测新数据的输出。\n就像一句比喻：\n\u0026ldquo;给出了一堆数据和结果，然后推导出一个公式\u0026rdquo;——这就是回归的核心本质。\n二、线性回归模型：单变量与多变量 2.1 线性回归的基本概念 线性回归是最基础也是最常用的回归分析方法。它通过建立因变量（预测目标）与自变量（特征）之间的线性关系来进行预测。\n数学表达式 线性回归的基本形式是： $$y = wx + b $$ 其中：\n$y $ 是预测值（因变量） $x $ 是特征（自变量） $w $ 是权重（斜率） $b $ 是偏置项（截距） 模型目标 线性回归的目标是找到最优的 $w $ 和 $b $，使得预测值与真实值之间的误差最小。通常使用均方误差（MSE）作为优化目标： $$MSE = \\frac{1}{n}\\sum_{i=1}^n(y_i - \\hat{y}_i)^2 $$ 其中 $y_i $ 是真实值，$\\hat{y}_i $ 是预测值。\n2.2 单变量线性回归 概念解释 单变量线性回归是最简单的线性回归形式，只使用一个特征（自变量）来预测目标值。\n特点 只有一个自变量（特征） 可以在二维平面上直观地表示为一条直线 适合研究两个变量之间的简单线性关系 应用场景 房价与面积的关系 销量与广告投入的关系 学习时间与考试成绩的关系 2.3 多变量线性回归 概念解释 多变量线性回归使用多个特征来预测目标值，是单变量线性回归的扩展。\n数学表达式 $$y = w_1x_1 + w_2x_2 + \u0026hellip; + w_nx_n + b $$ 其中：\n$x_1, x_2, \u0026hellip;, x_n $ 是不同的特征 $w_1, w_2, \u0026hellip;, w_n $是对应的权重 $b $ 是偏置项 特点 考虑多个影响因素 可以捕捉更复杂的关系 在高维空间中形成超平面 应用场景 房价预测（面积、位置、楼层等多个因素） 销量预测（广告投入、季节、竞品价格等） 用户行为分析（年龄、收入、消费习惯等） 2.4 模型评估 线性回归模型的常用评估指标：\nR²分数（决定系数）\n范围：0~1 越接近1表示模型拟合越好 计算公式：$R^2 = 1 - \\frac{\\sum(y - \\hat{y})^2}{\\sum(y - \\bar{y})^2} $ 均方误差（MSE）\n越小越好 计算公式：$MSE = \\frac{1}{n}\\sum_{i=1}^n(y_i - \\hat{y}_i)^2 $ 平均绝对误差（MAE）\n越小越好 计算公式：$MAE = \\frac{1}{n}\\sum_{i=1}^n|y_i - \\hat{y}_i| $ 2.5 实践示例 示例：房价 vs 面积 我们用一组简单的房价和面积数据，训练一个线性模型，预测房价。\n完整代码： import numpy as np import matplotlib.pyplot as plt from sklearn.linear_model import LinearRegression # 构造数据 area = np.array([30, 40, 50, 60, 70, 80]).reshape(-1, 1) price = np.array([100, 150, 200, 240, 280, 310]) # 建模 model = LinearRegression() model.fit(area, price) # 预测 area_pred = np.linspace(20, 100, 100).reshape(-1, 1) price_pred = model.predict(area_pred) # 可视化 plt.scatter(area, price, color=\u0026#39;blue\u0026#39;, label=\u0026#39;实际数据\u0026#39;) plt.plot(area_pred, price_pred, color=\u0026#39;red\u0026#39;, label=\u0026#39;预测线\u0026#39;) plt.xlabel(\u0026#39;面积（㎡）\u0026#39;) plt.ylabel(\u0026#39;房价（万元）\u0026#39;) plt.title(\u0026#39;房价 vs 面积（单变量线性回归）\u0026#39;) plt.legend() plt.grid(True) plt.show() 2.6 多变量线性回归示例 示例：房价 vs 面积 + 楼层 from sklearn.model_selection import train_test_split # 特征：面积、楼层 data = np.array([ [30, 2], [40, 3], [50, 5], [60, 6], [70, 8], [80, 9] ]) price = np.array([100, 140, 190, 230, 280, 320]) X_train, X_test, y_train, y_test = train_test_split( data, price, test_size=0.2, random_state=42 ) model = LinearRegression() model.fit(X_train, y_train) # 模型系数和截距 print(f\u0026#34;系数: {model.coef_}\u0026#34;) print(f\u0026#34;截距: {model.intercept_}\u0026#34;) # 预测 predictions = model.predict(X_test) print(f\u0026#34;预测值: {predictions}\u0026#34;) print(f\u0026#34;真实值: {y_test}\u0026#34;) 三、误差分析和特征权重分析 3.1 误差分析（残差分析） 概念解释 误差（残差） = 真实值 - 预测值 理想情况下，误差应当近似于正态分布，且均值为0 如果误差有明显偏移、模式，说明模型拟合不佳，可能需要换模型或加入更多特征 误差分析完整代码 import numpy as np import matplotlib.pyplot as plt from sklearn.linear_model import LinearRegression from sklearn.model_selection import train_test_split import seaborn as sns from sklearn.metrics import mean_squared_error # 构造示例数据 data = np.array([ [30, 2], [40, 3], [50, 5], [60, 6], [70, 8], [80, 9] ]) price = np.array([100, 140, 190, 230, 280, 320]) # 划分训练集和测试集 X_train, X_test, y_train, y_test = train_test_split( data, price, test_size=0.2, random_state=42 ) # 训练模型 model = LinearRegression() model.fit(X_train, y_train) # 预测和计算误差 predicted = model.predict(X_test) residuals = y_test - predicted # 绘制误差分布图 plt.figure(figsize=(10, 6)) sns.histplot(residuals, kde=True, bins=10, color=\u0026#39;purple\u0026#39;) plt.title(\u0026#39;预测误差分布图\u0026#39;) plt.xlabel(\u0026#39;预测误差（真实值 - 预测值）\u0026#39;) plt.ylabel(\u0026#39;频次\u0026#39;) plt.grid(True) plt.show() # 打印误差统计信息 print(f\u0026#34;平均误差: {np.mean(residuals):.2f}\u0026#34;) print(f\u0026#34;误差标准差: {np.std(residuals):.2f}\u0026#34;) print(f\u0026#34;均方误差(MSE): {mean_squared_error(y_test, predicted):.2f}\u0026#34;) 3.2 特征权重分析（系数） 概念解释 在线性模型中，每个特征的系数表示它对预测目标的\u0026quot;影响力\u0026quot; 系数越大（正负不重要），说明这个特征对预测结果越关键 可以用柱状图可视化权重大小 特征权重分析完整代码 import numpy as np import matplotlib.pyplot as plt from sklearn.linear_model import LinearRegression from sklearn.model_selection import train_test_split # 构造示例数据 data = np.array([ [30, 2], [40, 3], [50, 5], [60, 6], [70, 8], [80, 9] ]) price = np.array([100, 140, 190, 230, 280, 320]) # 训练模型 model = LinearRegression() model.fit(data, price) # 这里使用全部数据训练，因为我们只关注特征权重 # 准备数据 features = [\u0026#39;面积\u0026#39;, \u0026#39;楼层\u0026#39;] coefficients = model.coef_ # 创建特征权重可视化 plt.figure(figsize=(10, 6)) bars = plt.bar(features, coefficients, color=[\u0026#39;teal\u0026#39;, \u0026#39;coral\u0026#39;]) plt.title(\u0026#39;特征权重（回归系数）分析\u0026#39;) plt.ylabel(\u0026#39;权重大小\u0026#39;) plt.grid(True, axis=\u0026#39;y\u0026#39;) # 在柱状图上添加具体数值 for bar in bars: height = bar.get_height() plt.text(bar.get_x() + bar.get_width()/2., height, f\u0026#39;{height:.2f}\u0026#39;, ha=\u0026#39;center\u0026#39;, va=\u0026#39;bottom\u0026#39;) plt.show() # 打印特征权重信息 print(\u0026#34;特征权重分析:\u0026#34;) for feature, coef in zip(features, coefficients): print(f\u0026#34;{feature}: {coef:.2f}\u0026#34;) print(f\u0026#34;截距: {model.intercept_:.2f}\u0026#34;) 3.3 综合分析完整代码 如果你想同时进行误差分析和特征权重分析，可以使用下面的完整代码：\nimport numpy as np import matplotlib.pyplot as plt from sklearn.linear_model import LinearRegression from sklearn.model_selection import train_test_split import seaborn as sns from sklearn.metrics import mean_squared_error # 构造示例数据 data = np.array([ [30, 2], [40, 3], [50, 5], [60, 6], [70, 8], [80, 9] ]) price = np.array([100, 140, 190, 230, 280, 320]) # 划分训练集和测试集 X_train, X_test, y_train, y_test = train_test_split( data, price, test_size=0.2, random_state=42 ) # 训练模型 model = LinearRegression() model.fit(X_train, y_train) # 1. 误差分析 predicted = model.predict(X_test) residuals = y_test - predicted # 创建子图 plt.figure(figsize=(15, 6)) # 误差分布图 plt.subplot(1, 2, 1) sns.histplot(residuals, kde=True, bins=10, color=\u0026#39;purple\u0026#39;) plt.title(\u0026#39;预测误差分布图\u0026#39;) plt.xlabel(\u0026#39;预测误差（真实值 - 预测值）\u0026#39;) plt.ylabel(\u0026#39;频次\u0026#39;) plt.grid(True) # 2. 特征权重分析 features = [\u0026#39;面积\u0026#39;, \u0026#39;楼层\u0026#39;] coefficients = model.coef_ plt.subplot(1, 2, 2) bars = plt.bar(features, coefficients, color=[\u0026#39;teal\u0026#39;, \u0026#39;coral\u0026#39;]) plt.title(\u0026#39;特征权重（回归系数）分析\u0026#39;) plt.ylabel(\u0026#39;权重大小\u0026#39;) plt.grid(True, axis=\u0026#39;y\u0026#39;) # 在柱状图上添加具体数值 for bar in bars: height = bar.get_height() plt.text(bar.get_x() + bar.get_width()/2., height, f\u0026#39;{height:.2f}\u0026#39;, ha=\u0026#39;center\u0026#39;, va=\u0026#39;bottom\u0026#39;) plt.tight_layout() plt.show() # 打印分析结果 print(\u0026#34;误差分析:\u0026#34;) print(f\u0026#34;平均误差: {np.mean(residuals):.2f}\u0026#34;) print(f\u0026#34;误差标准差: {np.std(residuals):.2f}\u0026#34;) print(f\u0026#34;均方误差(MSE): {mean_squared_error(y_test, predicted):.2f}\u0026#34;) print(\u0026#34;\\n特征权重分析:\u0026#34;) for feature, coef in zip(features, coefficients): print(f\u0026#34;{feature}: {coef:.2f}\u0026#34;) print(f\u0026#34;截距: {model.intercept_:.2f}\u0026#34;) 四、进阶探索 如果你想继续深入，可以探索以下主题：\n多项式回归：处理非线性关系 正则化方法： Ridge回归（L2正则化） Lasso回归（L1正则化） 模型评价指标： R²（决定系数） MSE（均方误差） MAE（平均绝对误差） 可视化分析： 残差图 预测-真实散点图 特征工程： 高阶特征构造 特征选择方法 参考资料 scikit-learn官方文档 Python数据科学手册 机器学习实战 注：本文代码基于Python 3.8+和scikit-learn 1.0+版本。\n","permalink":"https://xuyafei.github.io/personal-site/posts/regression/","summary":"\u003ch1 id=\"回归分析基础讲解与实战代码附图表展示\"\u003e回归分析基础讲解与实战代码（附图表展示）\u003c/h1\u003e\n\u003cp\u003e本文将详细讲解监督学习中的回归问题，特别是线性回归，包括其数学原理、编程实现以及如何通过图像分析模型表现，适合初学者快速入门，也适合有经验的开发者参考测试。\u003c/p\u003e\n\u003ch2 id=\"一什么是回归\"\u003e一、什么是回归？\u003c/h2\u003e\n\u003cp\u003e在监督学习中，\u003cstrong\u003e回归\u003c/strong\u003e是一种用于预测连续值的方法。\u003c/p\u003e\n\u003cp\u003e通俗地说，就是：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e给你一堆\u0026quot;输入-输出\u0026quot;的样本数据，让你学习出一个数学表达式，这个表达式能用来预测新数据的输出。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e就像一句比喻：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u0026ldquo;给出了一堆数据和结果，然后推导出一个公式\u0026rdquo;——这就是回归的核心本质。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"二线性回归模型单变量与多变量\"\u003e二、线性回归模型：单变量与多变量\u003c/h2\u003e\n\u003ch3 id=\"21-线性回归的基本概念\"\u003e2.1 线性回归的基本概念\u003c/h3\u003e\n\u003cp\u003e线性回归是最基础也是最常用的回归分析方法。它通过建立因变量（预测目标）与自变量（特征）之间的线性关系来进行预测。\u003c/p\u003e\n\u003ch4 id=\"数学表达式\"\u003e数学表达式\u003c/h4\u003e\n\u003cp\u003e线性回归的基本形式是：\n$$y = wx + b $$\n其中：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$y $ 是预测值（因变量）\u003c/li\u003e\n\u003cli\u003e$x $ 是特征（自变量）\u003c/li\u003e\n\u003cli\u003e$w $ 是权重（斜率）\u003c/li\u003e\n\u003cli\u003e$b $ 是偏置项（截距）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"模型目标\"\u003e模型目标\u003c/h4\u003e\n\u003cp\u003e线性回归的目标是找到最优的 $w $ 和 $b $，使得预测值与真实值之间的误差最小。通常使用均方误差（MSE）作为优化目标：\n$$MSE = \\frac{1}{n}\\sum_{i=1}^n(y_i - \\hat{y}_i)^2 $$\n其中 $y_i $ 是真实值，$\\hat{y}_i $ 是预测值。\u003c/p\u003e\n\u003ch3 id=\"22-单变量线性回归\"\u003e2.2 单变量线性回归\u003c/h3\u003e\n\u003ch4 id=\"概念解释\"\u003e概念解释\u003c/h4\u003e\n\u003cp\u003e单变量线性回归是最简单的线性回归形式，只使用一个特征（自变量）来预测目标值。\u003c/p\u003e\n\u003ch4 id=\"特点\"\u003e特点\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e只有一个自变量（特征）\u003c/li\u003e\n\u003cli\u003e可以在二维平面上直观地表示为一条直线\u003c/li\u003e\n\u003cli\u003e适合研究两个变量之间的简单线性关系\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"应用场景\"\u003e应用场景\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e房价与面积的关系\u003c/li\u003e\n\u003cli\u003e销量与广告投入的关系\u003c/li\u003e\n\u003cli\u003e学习时间与考试成绩的关系\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"23-多变量线性回归\"\u003e2.3 多变量线性回归\u003c/h3\u003e\n\u003ch4 id=\"概念解释-1\"\u003e概念解释\u003c/h4\u003e\n\u003cp\u003e多变量线性回归使用多个特征来预测目标值，是单变量线性回归的扩展。\u003c/p\u003e","title":"回归分析基础讲解与实战代码（附图表展示）"},{"content":"权重的数学意义与本质 1. 权重的数学定义：\n在数学中，\u0026ldquo;权重（weight）\u0026ldquo;是一种系数，表示一个值在整体中所占的重要程度。在加权求和、加权平均、线性组合等常见结构中，权重决定了每一项对结果的影响大小。例如，加权平均值的公式如下：\n$$ \\bar{x} = \\frac{\\sum_{i=1}^{n} w_i x_i}{\\sum_{i=1}^{n} w_i} $$\n这里，( x_i ) 是第 ( i ) 个样本，( w_i ) 是其对应的权重。若所有权重相等，则公式退化为普通平均值。\n2. 权重的本质：线性代数视角\n从线性代数的角度看，权重构成了一个向量，用于对输入向量进行线性变换。例如：\n$$ y = \\mathbf{w}^T \\mathbf{x} = \\sum_{i=1}^{n} w_i x_i $$\n这里 $\\mathbf{w} \\in \\mathbb{R}^n $ 是权重向量，$\\mathbf{x} \\in \\mathbb{R}^n \\ $是输入特征向量。这个点积运算实际上在投影 $\\mathbf{x} $ 到 $ \\mathbf{w} $ 方向，衡量两者的对齐程度。若权重是单位向量，则 $ y $ 等于 $\\mathbf{x} $ 在该方向上的投影长度。\n因此，从本质上看，权重体现了“对哪个方向敏感”，代表了模型对不同特征维度的重要性认知。\n3. 权重的几何意义：决策边界与法向量\n在二维空间中，权重向量与决策边界的关系可以用下图直观展示：\n图1：权重向量、决策边界与法向量的几何关系\n这张图是一个二维坐标系，横轴是 $ x_1 $，纵轴是 $x_2 $。图中有三样重要的元素：\n决策边界$\\ w^T x = 0 $\n黑色的斜线就是决策边界，它把整个平面分成了两部分。 决策边界的方程是 ( w^T x = 0 )，也就是 ( w_1 x_1 + w_2 x_2 = 0 )。 它代表模型“认为”两类样本分界的位置。 权重向量 $\\ w $：\n从原点出发的一支粗箭头，指向右上方。 它是决策边界的法向量（垂直方向）。也就是说，权重向量的方向跟决策边界是正交（90度）的。 权重向量 $( w = (w_1, w_2) )$，其中 $( w_1 )$ 控制在 $( x_1 )$ 方向上的倾斜程度，$( w_2 )$ 控制在 $( x_2 )$ 方向上的倾斜程度。 几何意义：\n权重向量 $( w )$ 的方向，决定了“哪一边是正类，哪一边是负类”。 如果把某个点 $( x )$ 带入 $( w^T x )$： 如果结果 \u0026gt; 0，说明点在箭头指向的一侧（比如正类）。 如果结果 \u0026lt; 0，说明点在箭头反向的一侧（比如负类）。 权重的模长 $( | w | )$（就是箭头的长度）影响的是：决策边界两边的斜率陡峭程度，也和模型对输入变化的敏感程度有关。 简单总结：\n权重的方向决定了分类的方向； 权重的大小影响了分类面附近变化的敏感度（比如在 logistic 回归里对应决策曲线的陡峭程度）； 决策边界就是所有使 $( w^T x = 0 )$ 成立的点组成的直线。 4. 权重方向与决策边界的动态关系\n为了更直观地理解“权重方向变化=决策边界旋转”，请看下图：\n图2：不同权重方向下的决策边界变化示意\n这张图是一个更完整的二维坐标系（$( x_1 )$-轴 和 $( x_2 )$-轴），包含：\n三条决策边界线（从原点发散出去的三条直线）：\n它们分别对应不同方向的权重向量 $( w )$。 每条线都代表一组权重下，模型学习到的决策边界 $( w^T x = 0 )$。 三条线角度不同，说明权重方向变了，决策边界也跟着转动了。 粗箭头表示的权重向量 $( w )$：\n这支箭头指向介于中间的方向。 它表示当前的权重向量 $( w )$，而与之垂直的那条直线就是对应的决策边界。 注意：权重 $( w )$ 的方向总是和决策边界垂直，且箭头指向的是“模型预测为正类”的一侧。 $( w^T x = 0 )$ 的标注：\n标注在粗箭头正前方，强调这条对应于当前 $( w )$ 的决策边界是 $( w^T x = 0 )$。 这张图想表达的核心内容是：\n权重向量 $( w )$ 决定了决策边界的朝向。 改变 $( w )$ 的方向，相当于旋转决策边界，就像图里展示的那样。 在训练神经网络时，通过调整权重的方向，模型在不停地“旋转”决策边界，以便更好地区分不同类别的数据。 权重越大，决策面附近的变化越敏感，边界也可以变得更“陡峭”。 5. 权重与优化目标的关系\n在机器学习中，权重是优化目标函数中的变量，通过优化（如最小化损失）来寻找一组最优的权重。这些权重体现了模型对输入特征的“选择性记忆”。\n6. 权重与概率的联系\n在某些统计模型中，权重还可以解释为概率。例如在 softmax 分类器中，输入与权重的点积结果会通过指数函数和归一化，形成一组概率分布，体现每个类别的“权重”。\n权重在生活中的应用 成绩评定：\n学期总成绩 = 作业成绩 × 20% + 期中考试 × 30% + 期末考试 × 50%。这里的 20%、30%、50% 就是不同环节的权重。\n决策打分：\n在投标、人才选拔、风控等场景中，往往通过打分系统综合考虑多个因素（价格、能力、信用等），每个因素都有不同的权重。\n推荐系统：\n用户行为（点击、收藏、购买）的权重不同，系统根据权重加总行为得分，判断用户是否感兴趣。\n问卷调查与统计分析：\n不同群体（如年龄层、地区）在统计中可能被赋予不同的样本权重，以便结果更具代表性。\n权重在神经网络中的应用 权重作为学习参数：\n在最基础的神经网络（如全连接神经网络）中，每一条连接边都有一个权重，表示输入特征对神经元输出的影响大小。神经元的输入是各输入特征乘以对应权重后的加权和： $$ z = \\sum_{i} w_i x_i + b $$\n其中 $( w_i )$ 是权重，$( x_i )$ 是输入特征，$( b )$ 是偏置项。\n权重的学习过程：\n神经网络通过训练数据反复调整权重，使得输出尽可能接近目标值。这个过程依赖于损失函数和反向传播算法，权重在每次迭代中根据误差方向进行微调。\n权重的重要性：\n权重决定了神经网络对输入特征的敏感程度，也塑造了网络的决策边界和拟合能力。不同的权重组合，定义了不同的函数映射能力，直接影响模型的准确率、泛化能力与复杂度。\n过拟合与权重规模：\n如果权重过大，模型可能在训练集上表现很好但在测试集上过拟合。因此，常常需要对权重进行正则化（如 L2 正则化）来控制它们的大小，提高模型的泛化性能。\n初始权重的重要性：\n神经网络训练通常从随机初始化的权重开始。初始权重的分布对训练过程是否顺利、是否能收敛到较好的结果有重要影响，因此有特定的初始化方法（如 Xavier 初始化，He 初始化）。\n总结 权重是连接输入与输出、数据与模型、抽象与现实的桥梁。它既是数学中的重要概念，也是现实生活中决策与评估的工具，更是现代人工智能模型中不可或缺的核心参数。理解权重的本质，有助于我们更好地理解世界，也更好地构建模型来模拟世界。\n","permalink":"https://xuyafei.github.io/personal-site/posts/weights-and-math/","summary":"\u003ch3 id=\"权重的数学意义与本质\"\u003e权重的数学意义与本质\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e1. 权重的数学定义：\u003c/strong\u003e\u003cbr\u003e\n在数学中，\u0026ldquo;权重（weight）\u0026ldquo;是一种系数，表示一个值在整体中所占的重要程度。在加权求和、加权平均、线性组合等常见结构中，权重决定了每一项对结果的影响大小。例如，加权平均值的公式如下：\u003c/p\u003e\n\u003cp\u003e$$\n\\bar{x} = \\frac{\\sum_{i=1}^{n} w_i x_i}{\\sum_{i=1}^{n} w_i}\n$$\u003c/p\u003e\n\u003cp\u003e这里，( x_i ) 是第 ( i ) 个样本，( w_i ) 是其对应的权重。若所有权重相等，则公式退化为普通平均值。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2. 权重的本质：线性代数视角\u003c/strong\u003e\u003cbr\u003e\n从线性代数的角度看，权重构成了一个向量，用于对输入向量进行线性变换。例如：\u003c/p\u003e\n\u003cp\u003e$$\ny = \\mathbf{w}^T \\mathbf{x} = \\sum_{i=1}^{n} w_i x_i\n$$\u003c/p\u003e\n\u003cp\u003e这里 $\\mathbf{w} \\in \\mathbb{R}^n $ 是权重向量，$\\mathbf{x} \\in \\mathbb{R}^n \\ $是输入特征向量。这个点积运算实际上在投影 $\\mathbf{x} $ 到 $ \\mathbf{w} $ 方向，衡量两者的对齐程度。若权重是单位向量，则 $ y $ 等于 $\\mathbf{x} $ 在该方向上的投影长度。\u003c/p\u003e\n\u003cp\u003e因此，从本质上看，权重体现了“对哪个方向敏感”，代表了模型对不同特征维度的重要性认知。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3. 权重的几何意义：决策边界与法向量\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在二维空间中，权重向量与决策边界的关系可以用下图直观展示：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"权重与决策边界的几何关系\" loading=\"lazy\" src=\"/personal-site/posts/weights-and-math/figure1.png\"\u003e\n\u003cem\u003e图1：权重向量、决策边界与法向量的几何关系\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e这张图是一个二维坐标系，横轴是 $ x_1 $，纵轴是 $x_2 $。图中有三样重要的元素：\u003c/p\u003e","title":"权重的数学意义与应用"},{"content":"理解损失函数：机器学习中不可或缺的关键 1. 基本概念 在机器学习和深度学习的世界里，**损失函数（Loss Function）**扮演着至关重要的角色。它是模型学习过程中不可或缺的一部分，用来衡量模型的预测结果与真实值之间的差距。\n1.1 定义 损失函数是一种数学工具，量化了模型预测结果 $\\hat{y}$ 与真实标签 $y$ 之间的差异。损失越小，表明模型预测越准确；损失越大，说明模型需要进一步调整。\n通常记作 $L(\\hat{y}, y)$。\n1.2 作用 损失函数的存在，为模型训练指明了优化方向。通过不断最小化损失函数的值，我们可以逐步提升模型的预测能力和泛化能力。\n2. 四种常见损失函数详解与可视化 在机器学习与深度学习中，**损失函数（Loss Function）**是衡量模型预测结果与真实结果之间差异的重要工具。本文将系统讲解四种经典的损失函数，并通过可视化帮助理解它们的特点和适用场景。\n2.1 回归任务中的损失函数 2.1.1 均方误差（MSE，Mean Squared Error） 定义 均方误差是预测值与真实值差异的平方和的平均：\n$$ \\text{MSE} = \\frac{1}{n} \\sum_{i=1}^n (y_i - \\hat{y}_i)^2 $$\n其中 $y_i$ 是真实值，$\\hat{y}_i$ 是预测值。\n特点 对离群点敏感：由于平方项，大误差被放大，适合需要强烈惩罚大误差的场景。 连续且可导：适合用梯度下降等优化方法。 应用范围 回归问题：如房价预测、温度预测、股票价格预测等。 可视化 图1：MSE损失函数曲线，呈现出光滑的抛物线形状，预测值越接近真实值，损失越小。\n2.1.2 平均绝对误差（MAE，Mean Absolute Error） 定义 平均绝对误差是预测值与真实值差异的绝对值的平均：\n$$ \\text{MAE} = \\frac{1}{n} \\sum_{i=1}^n |y_i - \\hat{y}_i| $$\n特点 对离群点不敏感：相比 MSE，MAE 对单个极端错误不那么敏感。 不可导于0处：在误差为0的位置不可导，优化可能较慢。 应用范围 回归问题：尤其在需要对每个样本公平处理时（如中位数回归任务）。 可视化 图2：MAE损失函数曲线，呈现V型折线，误差线性增加。\n2.2 分类任务中的损失函数 2.2.1 交叉熵损失（Cross-Entropy Loss） 定义 常用于分类任务（二分类形式）：\n$$ \\text{Cross-Entropy} = -\\left( y \\log(\\hat{y}) + (1 - y) \\log(1 - \\hat{y}) \\right) $$\n其中 $y \\in {0,1}$ 是真实标签，$\\hat{y}$ 是预测的正类概率。\n特点 惩罚错误自信预测：如果模型预测很自信但错误，损失会非常大。 适合概率建模：自然适配 Softmax/Sigmoid 输出。 应用范围 分类问题：如图片分类（猫狗识别）、情感分析（正面/负面）。 可视化 图3：交叉熵损失函数曲线，当预测概率接近真实值时损失很小，但当预测概率远离真实标签时损失急剧上升。\n2.2.2 铰链损失（Hinge Loss） 定义 多用于支持向量机（SVM）分类器：\n$$ \\text{Hinge} = \\max(0, 1 - y \\times \\hat{y}) $$\n其中 $y \\in {-1, 1}$ 为标签，$\\hat{y}$ 是预测值。\n特点 推崇间隔最大化：不仅希望正确分类，还希望预测结果离决策边界远。 只关注支持向量：正确且安全距离够远的样本对损失无影响。 应用范围 SVM模型：传统 SVM 使用 Hinge Loss。 最大间隔分类任务。 可视化 图4：铰链损失函数曲线，呈一条线性下降后水平保持在0的折线，预测值超过1后损失即为0。\n2.3 四种损失函数特点总结 下表总结了上述四种常见损失函数的关键特征：\n损失函数 曲线形状 应用场景 对异常值敏感性 MSE 平滑抛物线 回归问题 高 MAE V字折线 回归问题 低 Cross-Entropy 曲率变化剧烈 分类问题 高 Hinge Loss 折线 分类 (SVM) 中 3. 直观理解 3.1 打靶比喻 想象把真实标签 $y$ 当作靶心，预测值 $\\hat{y}$ 是扔出的飞镖。损失函数就是计算飞镖离靶心的远近，训练的过程就是反复练习，不断让飞镖更接近靶心。\n4. 重要概念区分 4.1 损失函数 vs 代价函数 概念 定义 应用场景 损失函数（Loss Function） 一个样本的误差 单个样本评估 代价函数（Cost Function） 所有样本误差的平均值 整体模型评估 通常在训练中，我们最小化的是整个训练集的代价函数。\n5. 自定义损失函数 在实际应用中，如果标准损失函数不能满足需求，可以根据具体任务定义适合的损失函数，只要保证它可以进行梯度计算即可。\n6. 总结 损失函数是机器学习模型训练的核心组件，它：\n量化预测误差 指导模型优化方向 影响模型最终性能 可根据任务需求自定义 选择合适的损失函数对模型性能至关重要，需要根据具体任务类型和数据特点来决定。\n","permalink":"https://xuyafei.github.io/personal-site/posts/loss-function/","summary":"\u003ch1 id=\"理解损失函数机器学习中不可或缺的关键\"\u003e理解损失函数：机器学习中不可或缺的关键\u003c/h1\u003e\n\u003ch2 id=\"1-基本概念\"\u003e1. 基本概念\u003c/h2\u003e\n\u003cp\u003e在机器学习和深度学习的世界里，**损失函数（Loss Function）**扮演着至关重要的角色。它是模型学习过程中不可或缺的一部分，用来衡量模型的预测结果与真实值之间的差距。\u003c/p\u003e\n\u003ch3 id=\"11-定义\"\u003e1.1 定义\u003c/h3\u003e\n\u003cp\u003e损失函数是一种数学工具，量化了模型预测结果 $\\hat{y}$ 与真实标签 $y$ 之间的差异。损失越小，表明模型预测越准确；损失越大，说明模型需要进一步调整。\u003c/p\u003e\n\u003cp\u003e通常记作 $L(\\hat{y}, y)$。\u003c/p\u003e\n\u003ch3 id=\"12-作用\"\u003e1.2 作用\u003c/h3\u003e\n\u003cp\u003e损失函数的存在，为模型训练指明了优化方向。通过不断最小化损失函数的值，我们可以逐步提升模型的预测能力和泛化能力。\u003c/p\u003e\n\u003ch2 id=\"2-四种常见损失函数详解与可视化\"\u003e2. 四种常见损失函数详解与可视化\u003c/h2\u003e\n\u003cp\u003e在机器学习与深度学习中，**损失函数（Loss Function）**是衡量模型预测结果与真实结果之间差异的重要工具。本文将系统讲解四种经典的损失函数，并通过可视化帮助理解它们的特点和适用场景。\u003c/p\u003e\n\u003ch3 id=\"21-回归任务中的损失函数\"\u003e2.1 回归任务中的损失函数\u003c/h3\u003e\n\u003ch4 id=\"211-均方误差msemean-squared-error\"\u003e2.1.1 均方误差（MSE，Mean Squared Error）\u003c/h4\u003e\n\u003ch5 id=\"定义\"\u003e定义\u003c/h5\u003e\n\u003cp\u003e均方误差是预测值与真实值差异的平方和的平均：\u003c/p\u003e\n\u003cp\u003e$$\n\\text{MSE} = \\frac{1}{n} \\sum_{i=1}^n (y_i - \\hat{y}_i)^2\n$$\u003c/p\u003e\n\u003cp\u003e其中 $y_i$ 是真实值，$\\hat{y}_i$ 是预测值。\u003c/p\u003e\n\u003ch5 id=\"特点\"\u003e特点\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e对离群点敏感\u003c/strong\u003e：由于平方项，大误差被放大，适合需要强烈惩罚大误差的场景。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e连续且可导\u003c/strong\u003e：适合用梯度下降等优化方法。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"应用范围\"\u003e应用范围\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e回归问题：如房价预测、温度预测、股票价格预测等。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"可视化\"\u003e可视化\u003c/h5\u003e\n\u003cp\u003e\u003cimg alt=\"MSE损失函数曲线\" loading=\"lazy\" src=\"/personal-site/posts/loss-function/figure1.jpg\"\u003e\n\u003cem\u003e图1：MSE损失函数曲线，呈现出光滑的抛物线形状，预测值越接近真实值，损失越小。\u003c/em\u003e\u003c/p\u003e\n\u003ch4 id=\"212-平均绝对误差maemean-absolute-error\"\u003e2.1.2 平均绝对误差（MAE，Mean Absolute Error）\u003c/h4\u003e\n\u003ch5 id=\"定义-1\"\u003e定义\u003c/h5\u003e\n\u003cp\u003e平均绝对误差是预测值与真实值差异的绝对值的平均：\u003c/p\u003e\n\u003cp\u003e$$\n\\text{MAE} = \\frac{1}{n} \\sum_{i=1}^n |y_i - \\hat{y}_i|\n$$\u003c/p\u003e\n\u003ch5 id=\"特点-1\"\u003e特点\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e对离群点不敏感\u003c/strong\u003e：相比 MSE，MAE 对单个极端错误不那么敏感。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e不可导于0处\u003c/strong\u003e：在误差为0的位置不可导，优化可能较慢。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"应用范围-1\"\u003e应用范围\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e回归问题：尤其在需要对每个样本公平处理时（如中位数回归任务）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"可视化-1\"\u003e可视化\u003c/h5\u003e\n\u003cp\u003e\u003cimg alt=\"MAE损失函数曲线\" loading=\"lazy\" src=\"/personal-site/posts/loss-function/figure2.jpg\"\u003e\n\u003cem\u003e图2：MAE损失函数曲线，呈现V型折线，误差线性增加。\u003c/em\u003e\u003c/p\u003e","title":"理解损失函数：机器学习中不可或缺的关键"},{"content":"引言 C++ 的引用机制是该语言最强大且独特的特性之一。它不仅提供了一种安全的指针替代方案，还是现代 C++ 中移动语义和完美转发等高级特性的基础。本文将深入探讨 C++ 引用机制的各个方面，从基础概念到高级应用。\n引用的基本概念 什么是引用？ 引用可以看作是一个变量的别名。它在内存中不占用额外空间（在大多数实现中），必须在创建时初始化，并且一旦绑定到一个变量，就不能再引用其他变量。\nint x = 42; int\u0026amp; ref = x; // ref 是 x 的引用 ref = 24; // 修改 ref 就是修改 x 引用 vs 指针 引用和指针有一些重要的区别：\n初始化要求：\nint* ptr; // 合法，可以不初始化 int\u0026amp; ref; // 非法，引用必须初始化 重新赋值：\nint x = 1, y = 2; int* ptr = \u0026amp;x; ptr = \u0026amp;y; // 合法，指针可以指向新的地址 int\u0026amp; ref = x; ref = y; // 这是赋值操作，不是重新引用 空值：\nint* ptr = nullptr; // 合法 int\u0026amp; ref = nullptr; // 非法，引用不能为空 引用的类型 1. 左值引用 最基本的引用类型，用于引用可以取地址的表达式：\nint x = 42; int\u0026amp; ref = x; // 左值引用 // 不能引用字面量 int\u0026amp; ref2 = 42; // 错误！不能引用右值 2. 常量引用 可以引用常量，也可以引用右值：\nconst int\u0026amp; ref = 42; // 合法，可以引用右值 int x = 42; const int\u0026amp; ref2 = x; // 可以引用非常量 3. 右值引用 C++11 引入的新特性，用于支持移动语义：\nint\u0026amp;\u0026amp; rref = 42; // 右值引用 int x = 42; int\u0026amp;\u0026amp; rref2 = x; // 错误！不能绑定到左值 int\u0026amp;\u0026amp; rref3 = std::move(x); // 正确，std::move 将左值转换为右值 引用的常见应用场景 1. 函数参数 // 传值 void byValue(int x) { x = 42; // 不影响原始值 } // 引用传递 void byReference(int\u0026amp; x) { x = 42; // 修改原始值 } // 常量引用，用于大对象 void byConstReference(const std::string\u0026amp; str) { std::cout \u0026lt;\u0026lt; str; // 只读访问，避免拷贝 } 2. 函数返回值 // 返回引用 int\u0026amp; getElement(std::vector\u0026lt;int\u0026gt;\u0026amp; vec, size_t index) { return vec[index]; // 可以修改原始元素 } // 返回常量引用 const std::string\u0026amp; getString() { static std::string str = \u0026#34;Hello\u0026#34;; return str; // 返回静态对象的引用 } 3. 范围 for 循环 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; // 只读访问 for (const int\u0026amp; x : vec) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } // 修改元素 for (int\u0026amp; x : vec) { x *= 2; } 高级应用 1. 完美转发 使用模板和通用引用（universal reference）实现参数完美转发：\ntemplate\u0026lt;typename T\u0026gt; void wrapper(T\u0026amp;\u0026amp; arg) { // 完美转发参数 foo(std::forward\u0026lt;T\u0026gt;(arg)); } 2. 移动语义 使用右值引用实现高效的资源转移：\nclass MyString { public: // 移动构造函数 MyString(MyString\u0026amp;\u0026amp; other) noexcept { data_ = other.data_; other.data_ = nullptr; } private: char* data_; }; 3. 引用折叠 理解引用折叠规则对于模板编程很重要：\ntemplate\u0026lt;typename T\u0026gt; void foo(T\u0026amp;\u0026amp; x) { // 通用引用 // T\u0026amp; \u0026amp; 折叠为 T\u0026amp; // T\u0026amp; \u0026amp;\u0026amp; 折叠为 T\u0026amp; // T\u0026amp;\u0026amp; \u0026amp; 折叠为 T\u0026amp; // T\u0026amp;\u0026amp; \u0026amp;\u0026amp; 折叠为 T\u0026amp;\u0026amp; } 最佳实践 使用常量引用传递大对象：\nvoid process(const BigObject\u0026amp; obj); // 比传值效率高 避免返回局部变量的引用：\nint\u0026amp; bad() { int x = 42; return x; // 危险！返回局部变量的引用 } 使用右值引用实现移动语义：\nclass MyClass { MyClass(MyClass\u0026amp;\u0026amp; other) noexcept; // 移动构造函数 MyClass\u0026amp; operator=(MyClass\u0026amp;\u0026amp; other) noexcept; // 移动赋值运算符 }; 使用 std::ref 在需要时创建引用包装器：\nvoid foo(int\u0026amp; x); int x = 42; std::thread t(foo, std::ref(x)); // 传递引用给线程 注意事项 不要返回局部变量的引用 确保引用的对象生命周期足够长 使用常量引用来防止意外修改 理解右值引用和移动语义的关系 注意引用折叠规则在模板中的应用 总结 C++ 的引用机制是一个强大的特性，它不仅提供了一种安全的指针替代方案，还是现代 C++ 中许多高级特性的基础。通过合理使用不同类型的引用，我们可以编写出更高效、更安全的代码。\n理解引用机制对于掌握 C++ 至关重要，它不仅涉及基本的语言特性，还与移动语义、完美转发等现代 C++ 特性密切相关。在实际编程中，合理使用引用可以显著提高代码的性能和可维护性。\n参考资料 C++ 标准文档 Effective Modern C++ (Scott Meyers) C++ Templates: The Complete Guide ","permalink":"https://xuyafei.github.io/personal-site/posts/cpp-references/","summary":"\u003ch2 id=\"引言\"\u003e引言\u003c/h2\u003e\n\u003cp\u003eC++ 的引用机制是该语言最强大且独特的特性之一。它不仅提供了一种安全的指针替代方案，还是现代 C++ 中移动语义和完美转发等高级特性的基础。本文将深入探讨 C++ 引用机制的各个方面，从基础概念到高级应用。\u003c/p\u003e\n\u003ch2 id=\"引用的基本概念\"\u003e引用的基本概念\u003c/h2\u003e\n\u003ch3 id=\"什么是引用\"\u003e什么是引用？\u003c/h3\u003e\n\u003cp\u003e引用可以看作是一个变量的别名。它在内存中不占用额外空间（在大多数实现中），必须在创建时初始化，并且一旦绑定到一个变量，就不能再引用其他变量。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e x \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e42\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e ref \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e x;  \u003cspan style=\"color:#75715e\"\u003e// ref 是 x 的引用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003eref \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e24\u003c/span\u003e;      \u003cspan style=\"color:#75715e\"\u003e// 修改 ref 就是修改 x\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"引用-vs-指针\"\u003e引用 vs 指针\u003c/h3\u003e\n\u003cp\u003e引用和指针有一些重要的区别：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e初始化要求\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e ptr;     \u003cspan style=\"color:#75715e\"\u003e// 合法，可以不初始化\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e ref;     \u003cspan style=\"color:#75715e\"\u003e// 非法，引用必须初始化\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e重新赋值\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e x \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, y \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e ptr \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ex;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eptr \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ey;      \u003cspan style=\"color:#75715e\"\u003e// 合法，指针可以指向新的地址\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e ref \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e x;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eref \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e y;       \u003cspan style=\"color:#75715e\"\u003e// 这是赋值操作，不是重新引用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e空值\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e ptr \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enullptr\u003c/span\u003e;  \u003cspan style=\"color:#75715e\"\u003e// 合法\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e ref \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enullptr\u003c/span\u003e;  \u003cspan style=\"color:#75715e\"\u003e// 非法，引用不能为空\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"引用的类型\"\u003e引用的类型\u003c/h2\u003e\n\u003ch3 id=\"1-左值引用\"\u003e1. 左值引用\u003c/h3\u003e\n\u003cp\u003e最基本的引用类型，用于引用可以取地址的表达式：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e x \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e42\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e ref \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e x;  \u003cspan style=\"color:#75715e\"\u003e// 左值引用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 不能引用字面量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e ref2 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e42\u003c/span\u003e;  \u003cspan style=\"color:#75715e\"\u003e// 错误！不能引用右值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"2-常量引用\"\u003e2. 常量引用\u003c/h3\u003e\n\u003cp\u003e可以引用常量，也可以引用右值：\u003c/p\u003e","title":"C++ 引用详解：从基础到高级应用"},{"content":"梯度优化初步理解与推导 在训练机器学习模型时，我们经常会遇到一个核心任务：最小化一个损失函数。梯度优化就是最常见的一种优化方法，其中最基本的就是梯度下降法（Gradient Descent）。本文从最简单的单变量情况出发，逐步介绍梯度优化的基本概念，并通过推导来解释为什么变量的更新形式是\u0026quot;减去导数\u0026quot;。\n一、单变量函数的梯度优化 我们先考虑最简单的一维情形：目标是最小化一个单变量函数 $f(x)$。\n假设当前我们在位置 $x$，我们想要往某个方向移动一点，以期降低函数值。最直观的想法是，函数的导数（梯度）可以告诉我们函数在该点的变化趋势。\n如果导数为正，说明函数在这里是上升的，那么我们应该往左（负方向）走；如果导数为负，说明函数是下降的，我们应该往右（正方向）走。\n因此，我们更新变量的方向应当与导数方向相反。如果步长设置为 $( \\eta $（称为学习率），那么更新公式就是：\n$$ x_{\\text{new}} = x_{\\text{old}} - \\eta \\cdot f\u0026rsquo;(x_{\\text{old}}) $$\n二、学习率的引入 学习率 $( \\eta )$ 控制着我们每一步走多远。如果 $( \\eta )$ 太小，虽然方向对了，但前进非常缓慢，优化过程会很慢；如果 $( \\eta $ 太大，可能会越过最小值，甚至震荡不收敛。\n因此，选择合适的学习率非常关键。实际应用中可能会使用固定学习率、动态调整学习率、甚至使用不同优化器（如 Adam）来改进这个过程。\n三、为什么变量更新要\u0026quot;减去\u0026quot;导数？——从数学推导理解梯度下降 很多初学者会疑惑：为什么变量更新的公式是\u0026quot;减去\u0026quot;导数，而不是加上？这一节我们从泰勒展开和最优化理论的角度来做一个严格推导。\n3.1 优化目标：寻找最小值 我们希望寻找使函数 $( f(x) $ 最小的点。假设当前我们在某一点 $( x )$，下一步想往某个方向 $( d )$ 走一小步（大小为 $( \\alpha )$。新的点就是：\n$$ x_{\\text{new}} = x + \\alpha d $$\n3.2 用一阶泰勒展开近似函数变化 考虑函数 $( f(x + \\alpha d) )$ 在点 $( x )$ 附近的变化情况，一阶泰勒展开为：\n$$ f(x + \\alpha d) \\approx f(x) + \\alpha f\u0026rsquo;(x) \\cdot d $$\n我们希望让函数值变小，也就是说希望：\n$$ f(x + \\alpha d) \u0026lt; f(x) \\Rightarrow \\alpha f\u0026rsquo;(x) \\cdot d \u0026lt; 0 $$\n由于 $( \\alpha \u0026gt; 0 )$，这个不等式可以简化为：\n$$ f\u0026rsquo;(x) \\cdot d \u0026lt; 0 $$\n说明我们要选择一个方向 $( d )$，使得它和导数方向相反。\n3.3 最速下降方向是负梯度方向 那么，哪个方向能让函数下降得最快呢？答案是：\n当 $( d = -f\u0026rsquo;(x) )$ 时，函数下降最快，这就是最速下降法中的结论。\n于是，我们更新变量时就取这个方向：\n$$ x_{\\text{new}} = x + \\alpha \\cdot d = x - \\alpha \\cdot f\u0026rsquo;(x) $$\n我们将 $( \\alpha )$ 改名为学习率 $( \\eta )$，得到常用的梯度下降更新公式：\n$$ x_{\\text{new}} = x - \\eta \\cdot f\u0026rsquo;(x) $$\n四、示例：最小化一个简单函数 考虑函数 $( f(x) = (x - 2)^2 )$，它的导数是 $( f\u0026rsquo;(x) = 2(x - 2) )$。\n假设从 $( x_0 = 0 )$ 开始，学习率为 $( \\eta = 0.1 )$，那么：\n$$ x_1 = x_0 - 0.1 \\cdot f\u0026rsquo;(x_0) = 0 - 0.1 \\cdot (-4) = 0.4 $$\n继续迭代下去，就可以不断逼近函数的最小值 2。\n五、多变量函数的梯度优化 当我们面对的是一个多变量函数 ( f(x, y) ) 时，梯度优化依然成立。此时函数的梯度是一个向量：\n$$ \\nabla f(x, y) = \\left[ \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y} \\right] $$\n更新规则就变为：\n$$ \\begin{aligned} x_{\\text{new}} \u0026amp;= x - \\eta \\cdot \\frac{\\partial f}{\\partial x} \\ y_{\\text{new}} \u0026amp;= y - \\eta \\cdot \\frac{\\partial f}{\\partial y} \\end{aligned} $$\n在实际操作中，由于函数形状可能非常复杂（例如鞍点、局部极小值、陡峭或平缓区域等），多变量的梯度下降容易出现如下问题：\n陷入局部最小值或鞍点，而非全局最优； 在某些方向上下降缓慢（例如\u0026quot;峡谷\u0026quot;型函数）； 对初始点非常敏感。 多变量优化的可视化理解 在二维函数中，梯度优化的路径可以在等高线图（contour plot）上直观表现出来。\n函数 $( f(x, y) )$ 的等高线图是一个二维平面，其中每条曲线表示函数值相同的点。梯度下降的每一步都会沿着垂直于等高线、指向函数值减小的方向移动。\n换句话说：\n每一步的梯度方向都是当前等高线的法向量，下降轨迹会\u0026quot;穿越\u0026quot;这些等高线向最低点收敛。\n因此，观察一个函数的梯度下降路径，不仅可以判断收敛是否合理，还可以帮助我们理解学习率是否合适（太大会震荡、太小会缓慢）。\n六、小结 从数学推导可以看出，\u0026ldquo;变量减去导数\u0026quot;并不是拍脑袋的经验做法，而是有严密的逻辑：\n函数值想要下降，变量必须朝着导数的反方向移动； 负导数方向是函数下降最快的方向； 因此，变量更新应当是： $$ x \\leftarrow x - \\eta \\cdot f\u0026rsquo;(x) $$\n这个公式，就是梯度优化的起点。\n","permalink":"https://xuyafei.github.io/personal-site/posts/preliminary-understanding-and-derivation-of-gradient-optimization/","summary":"\u003ch2 id=\"梯度优化初步理解与推导\"\u003e梯度优化初步理解与推导\u003c/h2\u003e\n\u003cp\u003e在训练机器学习模型时，我们经常会遇到一个核心任务：\u003cstrong\u003e最小化一个损失函数\u003c/strong\u003e。梯度优化就是最常见的一种优化方法，其中最基本的就是\u003cstrong\u003e梯度下降法（Gradient Descent）\u003c/strong\u003e。本文从最简单的单变量情况出发，逐步介绍梯度优化的基本概念，并通过推导来解释为什么变量的更新形式是\u0026quot;减去导数\u0026quot;。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"一单变量函数的梯度优化\"\u003e一、单变量函数的梯度优化\u003c/h3\u003e\n\u003cp\u003e我们先考虑最简单的一维情形：目标是最小化一个单变量函数 $f(x)$。\u003c/p\u003e\n\u003cp\u003e假设当前我们在位置 $x$，我们想要往某个方向移动一点，以期降低函数值。最直观的想法是，函数的导数（梯度）可以告诉我们函数在该点的变化趋势。\u003c/p\u003e\n\u003cp\u003e如果导数为正，说明函数在这里是上升的，那么我们应该往左（负方向）走；如果导数为负，说明函数是下降的，我们应该往右（正方向）走。\u003c/p\u003e\n\u003cp\u003e因此，我们更新变量的方向应当\u003cstrong\u003e与导数方向相反\u003c/strong\u003e。如果步长设置为 $( \\eta $（称为\u003cstrong\u003e学习率\u003c/strong\u003e），那么更新公式就是：\u003c/p\u003e\n\u003cp\u003e$$\nx_{\\text{new}} = x_{\\text{old}} - \\eta \\cdot f\u0026rsquo;(x_{\\text{old}})\n$$\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"二学习率的引入\"\u003e二、学习率的引入\u003c/h3\u003e\n\u003cp\u003e学习率 $( \\eta )$ 控制着我们每一步走多远。如果 $( \\eta )$ 太小，虽然方向对了，但前进非常缓慢，优化过程会很慢；如果 $( \\eta $ 太大，可能会越过最小值，甚至震荡不收敛。\u003c/p\u003e\n\u003cp\u003e因此，选择合适的学习率非常关键。实际应用中可能会使用固定学习率、动态调整学习率、甚至使用不同优化器（如 Adam）来改进这个过程。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"三为什么变量更新要减去导数从数学推导理解梯度下降\"\u003e三、为什么变量更新要\u0026quot;减去\u0026quot;导数？——从数学推导理解梯度下降\u003c/h3\u003e\n\u003cp\u003e很多初学者会疑惑：为什么变量更新的公式是\u0026quot;减去\u0026quot;导数，而不是加上？这一节我们从泰勒展开和最优化理论的角度来做一个严格推导。\u003c/p\u003e\n\u003ch4 id=\"31-优化目标寻找最小值\"\u003e3.1 优化目标：寻找最小值\u003c/h4\u003e\n\u003cp\u003e我们希望寻找使函数 $( f(x) $ 最小的点。假设当前我们在某一点 $( x )$，下一步想往某个方向 $( d )$ 走一小步（大小为 $( \\alpha )$。新的点就是：\u003c/p\u003e\n\u003cp\u003e$$\nx_{\\text{new}} = x + \\alpha d\n$$\u003c/p\u003e\n\u003ch4 id=\"32-用一阶泰勒展开近似函数变化\"\u003e3.2 用一阶泰勒展开近似函数变化\u003c/h4\u003e\n\u003cp\u003e考虑函数 $( f(x + \\alpha d) )$ 在点 $( x )$ 附近的变化情况，一阶泰勒展开为：\u003c/p\u003e","title":"梯度优化初步理解与推导"},{"content":"1. 偏导数（Partial Derivative） 定义 偏导数是多元函数对某一个自变量的导数，表示当其他自变量固定时，函数沿该方向的变化率。\n通俗解释 想象你站在一个山坡上（函数 $f(x,y)$ 表示海拔）：\n对 $x$ 的偏导数（$\\frac{\\partial f}{\\partial x}$）是仅沿东西方向移动时的坡度。 对 $y$ 的偏导数（$\\frac{\\partial f}{\\partial y}$）是仅沿南北方向的坡度。 数学形式 对于函数 $f(x_1, x_2, \\dots, x_n)$：\n$$ \\frac{\\partial f}{\\partial x_i} = \\lim_{h \\to 0} \\frac{f(x_1, \\dots, x_i + h, \\dots, x_n) - f(x_1, \\dots, x_n)}{h} $$\n例子 设 $f(x,y) = x^2 + 3xy$：\n$\\frac{\\partial f}{\\partial x} = 2x + 3y$ （视 $y$ 为常数） $\\frac{\\partial f}{\\partial y} = 3x$ （视 $x$ 为常数） 2. 梯度（Gradient） 定义 梯度是一个向量，由函数在所有自变量上的偏导数组成，指向函数值增长最快的方向。\n通俗解释 梯度是山坡上\u0026quot;最陡的上坡方向\u0026quot;。 梯度的大小表示该方向的陡峭程度。 数学形式 对于 $f(x_1, x_2, \\dots, x_n)$，梯度记作 $\\nabla f$：\n$$ \\nabla f = \\left( \\frac{\\partial f}{\\partial x_1}, \\frac{\\partial f}{\\partial x_2}, \\dots, \\frac{\\partial f}{\\partial x_n} \\right) $$\n例子 继续用 $f(x,y) = x^2 + 3xy$：\n$$ \\nabla f = \\left( 2x + 3y, 3x \\right) $$\n在点 $(1, 2)$ 处的梯度为 $\\nabla f = (8, 3)$，表示从该点出发，沿方向 $(8, 3)$ 函数值增长最快。\n3. 关键点总结 偏导数：单一方向的变化率，其他变量固定。 梯度： 是所有偏导数的向量组合。 方向指向函数值最大增长方向。 在优化中，负梯度方向是函数值下降最快的方向。 4. 几何意义 梯度方向：函数增长最快的方向。 梯度大小：变化率的强度（越陡峭，梯度越大）。 等高线：梯度与等高线垂直。 5. 应用场景 机器学习：梯度下降法通过沿负梯度方向更新参数。 物理学：电势的梯度是电场强度。 工程优化：寻找多维函数的最优解。 注：本文使用 MathJax 渲染数学公式，确保最佳显示效果。\n","permalink":"https://xuyafei.github.io/personal-site/posts/partial-derivatives-and-gradients/","summary":"\u003ch2 id=\"1-偏导数partial-derivative\"\u003e1. 偏导数（Partial Derivative）\u003c/h2\u003e\n\u003ch3 id=\"定义\"\u003e定义\u003c/h3\u003e\n\u003cp\u003e偏导数是多元函数对\u003cstrong\u003e某一个自变量\u003c/strong\u003e的导数，表示当其他自变量固定时，函数沿该方向的变化率。\u003c/p\u003e\n\u003ch3 id=\"通俗解释\"\u003e通俗解释\u003c/h3\u003e\n\u003cp\u003e想象你站在一个山坡上（函数 $f(x,y)$ 表示海拔）：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对 $x$ 的偏导数（$\\frac{\\partial f}{\\partial x}$）是\u003cstrong\u003e仅沿东西方向\u003c/strong\u003e移动时的坡度。\u003c/li\u003e\n\u003cli\u003e对 $y$ 的偏导数（$\\frac{\\partial f}{\\partial y}$）是\u003cstrong\u003e仅沿南北方向\u003c/strong\u003e的坡度。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"数学形式\"\u003e数学形式\u003c/h3\u003e\n\u003cp\u003e对于函数 $f(x_1, x_2, \\dots, x_n)$：\u003c/p\u003e\n\u003cp\u003e$$\n\\frac{\\partial f}{\\partial x_i} = \\lim_{h \\to 0} \\frac{f(x_1, \\dots, x_i + h, \\dots, x_n) - f(x_1, \\dots, x_n)}{h}\n$$\u003c/p\u003e\n\u003ch3 id=\"例子\"\u003e例子\u003c/h3\u003e\n\u003cp\u003e设 $f(x,y) = x^2 + 3xy$：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$\\frac{\\partial f}{\\partial x} = 2x + 3y$ （视 $y$ 为常数）\u003c/li\u003e\n\u003cli\u003e$\\frac{\\partial f}{\\partial y} = 3x$ （视 $x$ 为常数）\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"2-梯度gradient\"\u003e2. 梯度（Gradient）\u003c/h2\u003e\n\u003ch3 id=\"定义-1\"\u003e定义\u003c/h3\u003e\n\u003cp\u003e梯度是一个向量，由函数在所有自变量上的偏导数组成，指向函数值\u003cstrong\u003e增长最快\u003c/strong\u003e的方向。\u003c/p\u003e","title":"偏导数与梯度的概念详解"},{"content":"全面解析C++中类(class)与结构体(struct)的区别 一、最核心区别：默认访问控制 在C++中，class和struct的唯一语法区别在于默认访问权限：\n// 结构体示例 struct MyStruct { int x; // 默认public访问权限 void foo() {} // 默认public }; // 类示例 class MyClass { int x; // 默认private访问权限 void bar() {} // 默认private }; 继承时的默认权限 struct D1 : Base {}; // 默认public继承 class D2 : Base {}; // 默认private继承 二、历史起源与设计哲学 特性 struct (结构体) class (类) 诞生时间 源自C语言 C++新增概念 设计初衷 数据打包聚合 面向对象封装 核心理念 \u0026ldquo;这是一个数据集合\u0026rdquo; \u0026ldquo;这是一个具有行为的对象\u0026rdquo; 三、实际开发中的惯用准则 应该使用struct的场景 纯数据集合 struct Color { uint8_t r, g, b, a; // 全部公有 }; 简单值类型 struct Point { double x, y; // 可以包含简单方法 double distance() const { return sqrt(x*x + y*y); } }; 接口配置参数 struct Config { string title; int width; int height; }; 应该使用class的场景 需要封装的业务对象 class BankAccount { private: string owner_; double balance_; public: void deposit(double amount) { /*...*/ } bool withdraw(double amount) { /*...*/ } }; 需要复杂生命周期的资源管理 class DatabaseConnection { Connection* conn_; public: explicit DatabaseConnection(string url) { /*...*/ } ~DatabaseConnection() { /* 自动释放资源 */ } }; 需要多态继承的体系 class Shape { public: virtual double area() const = 0; }; 四、技术能力完全对比 语言特性 struct支持情况 class支持情况 示例代码 成员变量 ✓ ✓ int x; 成员函数 ✓ ✓ void f() {} 访问控制 ✓ ✓ public: 构造函数/析构函数 ✓ ✓ ~T() {} 运算符重载 ✓ ✓ T operator+() 继承 ✓ ✓ struct D : B {}; 虚函数 ✓ ✓ virtual void f() = 0; 友元 ✓ ✓ friend class F; 模板 ✓ ✓ template\u0026lt;typename T\u0026gt; 五、模板元编程中的差异实践 struct在元编程中的优势 // 类型特征检查通常用struct实现 template\u0026lt;typename T\u0026gt; struct is_pointer { static constexpr bool value = false; }; template\u0026lt;typename T\u0026gt; struct is_pointer\u0026lt;T*\u0026gt; { static constexpr bool value = true; }; // 使用示例 static_assert(is_pointer\u0026lt;int*\u0026gt;::value, \u0026#34;必须是指针类型\u0026#34;); 原因分析 元编程通常需要公开所有成员 避免频繁写public关键字 符合\u0026quot;数据即接口\u0026quot;的元编程哲学 六、内存布局完全一致 struct S { int a; double b; }; class C { int a; double b; }; // 验证内存布局相同 static_assert(sizeof(S) == sizeof(C)); static_assert(offsetof(S, b) == offsetof(C, b)); 继承时的特殊情况 struct A { int x; }; class B : A { int y; }; // 私有继承可能影响空基类优化 七、与C语言的兼容性细节 特性 C struct C++ struct 类型声明 必须带struct关键字 可直接作为类型名 成员函数 不支持 支持 访问控制 无 支持 静态成员 不支持 支持 C/C++混合编程注意事项： #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif // 确保C兼容的布局 struct CCompatStruct { int x; float y; }; #ifdef __cplusplus } #endif 八、现代C++中的最佳实践 结构化绑定(struct适用) struct Employee { string name; int id; double salary; }; auto [name, id, salary] = getEmployee(); // C++17结构化绑定 类的不变量维护(class适用) class Temperature { double kelvin_; public: void setCelsius(double c) { kelvin_ = c + 273.15; assert(kelvin_ \u0026gt; 0 \u0026amp;\u0026amp; \u0026#34;绝对温度不能为负\u0026#34;); } }; 移动语义支持(两者均可) struct Buffer { vector\u0026lt;uint8_t\u0026gt; data; Buffer(Buffer\u0026amp;\u0026amp; other) noexcept : data(std::move(other.data)) {} }; class FileHandle { FILE* handle_; public: FileHandle(FileHandle\u0026amp;\u0026amp; other) : handle_(other.handle_) { other.handle_ = nullptr; } }; 九、完整特性对比表格 对比维度 struct class 基本性质 关键字 struct class 默认访问权限 public private 默认继承方式 public private 设计用途 数据聚合 首选 可用但不惯用 对象封装 可用但不惯用 首选 接口定义 适合POD接口 适合抽象接口 语法特性 成员函数 支持 支持 虚函数 支持 支持 友元声明 支持 支持 其他特性 模板元编程 更常用 较少使用 C兼容性 部分兼容 不兼容 内存布局 与class相同 与struct相同 结构化绑定 天然适合 需要显式tuple接口 十、经典面试题解析 Q1：以下代码有何问题？ class Circle { double radius; public: double area() const { return 3.14 * radius * radius; } }; struct Square { double side; double area() const { return side * side; } }; 答案：\n从技术上讲没有问题 但从设计角度看： Circle将数据隐藏是合理的 Square作为简单的几何图形，使用struct更合适 Q2：为什么STL中用struct实现迭代器特性？ template\u0026lt;class Iterator\u0026gt; struct iterator_traits { using value_type = typename Iterator::value_type; // ... }; 答案：\n特性类需要所有成员公开 避免频繁写public关键字 符合\u0026quot;特性即数据\u0026quot;的元编程哲学 总结选择策略 默认选择class当：\n需要维护不变量的类型 需要复杂生命周期的对象 需要多态继承的体系 默认选择struct当：\n纯数据集合 简单的值类型 需要与C交互的数据结构 模板元编程场景 永远保持一致：\n同一个项目中保持统一风格 在混合使用时明确标注原因 ","permalink":"https://xuyafei.github.io/personal-site/posts/cpp-class-vs-struct/","summary":"\u003ch1 id=\"全面解析c中类class与结构体struct的区别\"\u003e全面解析C++中类(class)与结构体(struct)的区别\u003c/h1\u003e\n\u003ch2 id=\"一最核心区别默认访问控制\"\u003e一、最核心区别：默认访问控制\u003c/h2\u003e\n\u003cp\u003e在C++中，\u003ccode\u003eclass\u003c/code\u003e和\u003ccode\u003estruct\u003c/code\u003e的唯一语法区别在于默认访问权限：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 结构体示例\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMyStruct\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e x;       \u003cspan style=\"color:#75715e\"\u003e// 默认public访问权限\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e() {} \u003cspan style=\"color:#75715e\"\u003e// 默认public\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 类示例\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMyClass\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e x;       \u003cspan style=\"color:#75715e\"\u003e// 默认private访问权限\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ebar\u003c/span\u003e() {} \u003cspan style=\"color:#75715e\"\u003e// 默认private\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"继承时的默认权限\"\u003e继承时的默认权限\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eD1\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e Base {};   \u003cspan style=\"color:#75715e\"\u003e// 默认public继承\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eD2\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e Base {};    \u003cspan style=\"color:#75715e\"\u003e// 默认private继承\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"二历史起源与设计哲学\"\u003e二、历史起源与设计哲学\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e特性\u003c/th\u003e\n          \u003cth\u003estruct (结构体)\u003c/th\u003e\n          \u003cth\u003eclass (类)\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e诞生时间\u003c/td\u003e\n          \u003ctd\u003e源自C语言\u003c/td\u003e\n          \u003ctd\u003eC++新增概念\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e设计初衷\u003c/td\u003e\n          \u003ctd\u003e数据打包聚合\u003c/td\u003e\n          \u003ctd\u003e面向对象封装\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e核心理念\u003c/td\u003e\n          \u003ctd\u003e\u0026ldquo;这是一个数据集合\u0026rdquo;\u003c/td\u003e\n          \u003ctd\u003e\u0026ldquo;这是一个具有行为的对象\u0026rdquo;\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"三实际开发中的惯用准则\"\u003e三、实际开发中的惯用准则\u003c/h2\u003e\n\u003ch3 id=\"应该使用struct的场景\"\u003e应该使用struct的场景\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e纯数据集合\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eColor\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e r, g, b, a;  \u003cspan style=\"color:#75715e\"\u003e// 全部公有\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e简单值类型\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePoint\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e x, y;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 可以包含简单方法\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edistance\u003c/span\u003e() \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e { \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e sqrt(x\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ex \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e y\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ey); }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e接口配置参数\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eConfig\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    string title;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e width;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e height;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"应该使用class的场景\"\u003e应该使用class的场景\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e需要封装的业务对象\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eBankAccount\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    string owner_;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e balance_;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e deposit(\u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e amount) { \u003cspan style=\"color:#75715e\"\u003e/*...*/\u003c/span\u003e }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ewithdraw\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e amount) { \u003cspan style=\"color:#75715e\"\u003e/*...*/\u003c/span\u003e }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e需要复杂生命周期的资源管理\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDatabaseConnection\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Connection\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e conn_;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eexplicit\u003c/span\u003e DatabaseConnection(string url) { \u003cspan style=\"color:#75715e\"\u003e/*...*/\u003c/span\u003e }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003e~\u003c/span\u003eDatabaseConnection() { \u003cspan style=\"color:#75715e\"\u003e/* 自动释放资源 */\u003c/span\u003e }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e需要多态继承的体系\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eShape\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evirtual\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e area() \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"四技术能力完全对比\"\u003e四、技术能力完全对比\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e语言特性\u003c/th\u003e\n          \u003cth\u003estruct支持情况\u003c/th\u003e\n          \u003cth\u003eclass支持情况\u003c/th\u003e\n          \u003cth\u003e示例代码\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e成员变量\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eint x;\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e成员函数\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003evoid f() {}\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e访问控制\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003epublic:\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e构造函数/析构函数\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003e~T() {}\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e运算符重载\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eT operator+()\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e继承\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003estruct D : B {};\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e虚函数\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003evirtual void f() = 0;\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e友元\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003efriend class F;\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e模板\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e✓\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003etemplate\u0026lt;typename T\u0026gt;\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"五模板元编程中的差异实践\"\u003e五、模板元编程中的差异实践\u003c/h2\u003e\n\u003ch3 id=\"struct在元编程中的优势\"\u003estruct在元编程中的优势\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 类型特征检查通常用struct实现\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eis_pointer\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003econstexpr\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e value \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e false;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eis_pointer\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#f92672\"\u003e*\u0026gt;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003econstexpr\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e value \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e true;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 使用示例\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003estatic_assert\u003c/span\u003e(is_pointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e*\u0026gt;::\u003c/span\u003evalue, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;必须是指针类型\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"原因分析\"\u003e原因分析\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e元编程通常需要公开所有成员\u003c/li\u003e\n\u003cli\u003e避免频繁写public关键字\u003c/li\u003e\n\u003cli\u003e符合\u0026quot;数据即接口\u0026quot;的元编程哲学\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"六内存布局完全一致\"\u003e六、内存布局完全一致\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eS\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e b;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eC\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e b;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 验证内存布局相同\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003estatic_assert\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003esizeof\u003c/span\u003e(S) \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003esizeof\u003c/span\u003e(C));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estatic_assert\u003c/span\u003e(offsetof(S, b) \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e offsetof(C, b));\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"继承时的特殊情况\"\u003e继承时的特殊情况\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eA\u003c/span\u003e { \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e x; };\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eB\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e A { \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e y; };  \u003cspan style=\"color:#75715e\"\u003e// 私有继承可能影响空基类优化\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"七与c语言的兼容性细节\"\u003e七、与C语言的兼容性细节\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e特性\u003c/th\u003e\n          \u003cth\u003eC struct\u003c/th\u003e\n          \u003cth\u003eC++ struct\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e类型声明\u003c/td\u003e\n          \u003ctd\u003e必须带struct关键字\u003c/td\u003e\n          \u003ctd\u003e可直接作为类型名\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e成员函数\u003c/td\u003e\n          \u003ctd\u003e不支持\u003c/td\u003e\n          \u003ctd\u003e支持\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e访问控制\u003c/td\u003e\n          \u003ctd\u003e无\u003c/td\u003e\n          \u003ctd\u003e支持\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e静态成员\u003c/td\u003e\n          \u003ctd\u003e不支持\u003c/td\u003e\n          \u003ctd\u003e支持\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"cc混合编程注意事项\"\u003eC/C++混合编程注意事项：\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#ifdef __cplusplus\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eextern\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;C\u0026#34;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#endif\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 确保C兼容的布局\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eCCompatStruct\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e x;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efloat\u003c/span\u003e y;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#ifdef __cplusplus\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#endif\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"八现代c中的最佳实践\"\u003e八、现代C++中的最佳实践\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e结构化绑定(struct适用)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eEmployee\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    string name;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e id;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e salary;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e [name, id, salary] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e getEmployee(); \u003cspan style=\"color:#75715e\"\u003e// C++17结构化绑定\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e类的不变量维护(class适用)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eTemperature\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e kelvin_;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e setCelsius(\u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e c) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        kelvin_ \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e c \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e273.15\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        assert(kelvin_ \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;绝对温度不能为负\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e移动语义支持(两者均可)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eBuffer\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003euint8_t\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e data;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Buffer(Buffer\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e other) \u003cspan style=\"color:#66d9ef\"\u003enoexcept\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e data(std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003emove(other.data)) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFileHandle\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    FILE\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e handle_;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    FileHandle(FileHandle\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e other) \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e handle_(other.handle_) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        other.handle_ \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enullptr\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"九完整特性对比表格\"\u003e九、完整特性对比表格\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e对比维度\u003c/th\u003e\n          \u003cth\u003estruct\u003c/th\u003e\n          \u003cth\u003eclass\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e基本性质\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e关键字\u003c/td\u003e\n          \u003ctd\u003estruct\u003c/td\u003e\n          \u003ctd\u003eclass\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e默认访问权限\u003c/td\u003e\n          \u003ctd\u003epublic\u003c/td\u003e\n          \u003ctd\u003eprivate\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e默认继承方式\u003c/td\u003e\n          \u003ctd\u003epublic\u003c/td\u003e\n          \u003ctd\u003eprivate\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e设计用途\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e数据聚合\u003c/td\u003e\n          \u003ctd\u003e首选\u003c/td\u003e\n          \u003ctd\u003e可用但不惯用\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e对象封装\u003c/td\u003e\n          \u003ctd\u003e可用但不惯用\u003c/td\u003e\n          \u003ctd\u003e首选\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e接口定义\u003c/td\u003e\n          \u003ctd\u003e适合POD接口\u003c/td\u003e\n          \u003ctd\u003e适合抽象接口\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e语法特性\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e成员函数\u003c/td\u003e\n          \u003ctd\u003e支持\u003c/td\u003e\n          \u003ctd\u003e支持\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e虚函数\u003c/td\u003e\n          \u003ctd\u003e支持\u003c/td\u003e\n          \u003ctd\u003e支持\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e友元声明\u003c/td\u003e\n          \u003ctd\u003e支持\u003c/td\u003e\n          \u003ctd\u003e支持\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e其他特性\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e模板元编程\u003c/td\u003e\n          \u003ctd\u003e更常用\u003c/td\u003e\n          \u003ctd\u003e较少使用\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eC兼容性\u003c/td\u003e\n          \u003ctd\u003e部分兼容\u003c/td\u003e\n          \u003ctd\u003e不兼容\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e内存布局\u003c/td\u003e\n          \u003ctd\u003e与class相同\u003c/td\u003e\n          \u003ctd\u003e与struct相同\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e结构化绑定\u003c/td\u003e\n          \u003ctd\u003e天然适合\u003c/td\u003e\n          \u003ctd\u003e需要显式tuple接口\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"十经典面试题解析\"\u003e十、经典面试题解析\u003c/h2\u003e\n\u003ch3 id=\"q1以下代码有何问题\"\u003eQ1：以下代码有何问题？\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eCircle\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e radius;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e area() \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e { \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e3.14\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e radius \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e radius; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSquare\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e side;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earea\u003c/span\u003e() \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e { \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e side \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e side; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e答案：\u003c/strong\u003e\u003c/p\u003e","title":"全面解析C++中类(class)与结构体(struct)的区别"},{"content":"这是一个测试页面，包含行内公式和块级公式。\n✅ 行内公式示例： 牛顿第二定律：$F = ma$，这个公式描述了力和加速度的关系。\n✅ 块级公式示例： 下面是偏导数的定义：\n$$ \\frac{\\partial f}{\\partial x_i} = \\lim_{h \\to 0} \\frac{f(x_1, \\dots, x_i + h, \\dots, x_n) - f(x_1, \\dots, x_n)}{h} $$\n","permalink":"https://xuyafei.github.io/personal-site/posts/katex-test/","summary":"\u003cp\u003e这是一个测试页面，包含行内公式和块级公式。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"-行内公式示例\"\u003e✅ 行内公式示例：\u003c/h3\u003e\n\u003cp\u003e牛顿第二定律：$F = ma$，这个公式描述了力和加速度的关系。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"-块级公式示例\"\u003e✅ 块级公式示例：\u003c/h3\u003e\n\u003cp\u003e下面是偏导数的定义：\u003c/p\u003e\n\u003cp\u003e$$\n\\frac{\\partial f}{\\partial x_i} = \\lim_{h \\to 0} \\frac{f(x_1, \\dots, x_i + h, \\dots, x_n) - f(x_1, \\dots, x_n)}{h}\n$$\u003c/p\u003e","title":"KaTeX 测试"}]